


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > Lifecycle</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.springframework.boot.buildpack.platform.build</a>
</div>

<h1>Coverage Summary for Class: Lifecycle (org.springframework.boot.buildpack.platform.build)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Lifecycle</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/25)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/121)
  </span>
</td>
</tr>
  <tr>
    <td class="name">Lifecycle$Directory</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/25)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/121)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2012-2024 the original author or authors.
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *      https://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;
&nbsp;package org.springframework.boot.buildpack.platform.build;
&nbsp;
&nbsp;import java.io.Closeable;
&nbsp;import java.io.IOException;
&nbsp;import java.nio.file.Files;
&nbsp;import java.nio.file.Path;
&nbsp;import java.util.Collections;
&nbsp;import java.util.List;
&nbsp;import java.util.function.Consumer;
&nbsp;
&nbsp;import com.sun.jna.Platform;
&nbsp;
&nbsp;import org.springframework.boot.buildpack.platform.docker.DockerApi;
&nbsp;import org.springframework.boot.buildpack.platform.docker.LogUpdateEvent;
&nbsp;import org.springframework.boot.buildpack.platform.docker.configuration.ResolvedDockerHost;
&nbsp;import org.springframework.boot.buildpack.platform.docker.type.Binding;
&nbsp;import org.springframework.boot.buildpack.platform.docker.type.ContainerConfig;
&nbsp;import org.springframework.boot.buildpack.platform.docker.type.ContainerContent;
&nbsp;import org.springframework.boot.buildpack.platform.docker.type.ContainerReference;
&nbsp;import org.springframework.boot.buildpack.platform.docker.type.ContainerStatus;
&nbsp;import org.springframework.boot.buildpack.platform.docker.type.ImageReference;
&nbsp;import org.springframework.boot.buildpack.platform.docker.type.VolumeName;
&nbsp;import org.springframework.boot.buildpack.platform.io.TarArchive;
&nbsp;import org.springframework.util.Assert;
&nbsp;import org.springframework.util.FileSystemUtils;
&nbsp;
&nbsp;/**
&nbsp; * A buildpack lifecycle used to run the build {@link Phase phases} needed to package an
&nbsp; * application.
&nbsp; *
&nbsp; * @author Phillip Webb
&nbsp; * @author Scott Frederick
&nbsp; * @author Jeroen Meijer
&nbsp; * @author Julian Liebig
&nbsp; */
&nbsp;class Lifecycle implements Closeable {
&nbsp;
<b class="nc">&nbsp;	private static final LifecycleVersion LOGGING_MINIMUM_VERSION = LifecycleVersion.parse(&quot;0.0.5&quot;);</b>
&nbsp;
&nbsp;	private static final String PLATFORM_API_VERSION_KEY = &quot;CNB_PLATFORM_API&quot;;
&nbsp;
&nbsp;	private static final String SOURCE_DATE_EPOCH_KEY = &quot;SOURCE_DATE_EPOCH&quot;;
&nbsp;
&nbsp;	private static final String DOMAIN_SOCKET_PATH = &quot;/var/run/docker.sock&quot;;
&nbsp;
<b class="nc">&nbsp;	private static final List&lt;String&gt; DEFAULT_SECURITY_OPTIONS = List.of(&quot;label=disable&quot;);</b>
&nbsp;
&nbsp;	private final BuildLog log;
&nbsp;
&nbsp;	private final DockerApi docker;
&nbsp;
&nbsp;	private final ResolvedDockerHost dockerHost;
&nbsp;
&nbsp;	private final BuildRequest request;
&nbsp;
&nbsp;	private final EphemeralBuilder builder;
&nbsp;
&nbsp;	private final LifecycleVersion lifecycleVersion;
&nbsp;
&nbsp;	private final ApiVersion platformVersion;
&nbsp;
&nbsp;	private final Cache layers;
&nbsp;
&nbsp;	private final Cache application;
&nbsp;
&nbsp;	private final Cache buildCache;
&nbsp;
&nbsp;	private final Cache launchCache;
&nbsp;
&nbsp;	private final String applicationDirectory;
&nbsp;
&nbsp;	private final List&lt;String&gt; securityOptions;
&nbsp;
&nbsp;	private boolean executed;
&nbsp;
&nbsp;	private boolean applicationVolumePopulated;
&nbsp;
&nbsp;	/**
&nbsp;	 * Create a new {@link Lifecycle} instance.
&nbsp;	 * @param log build output log
&nbsp;	 * @param docker the Docker API
&nbsp;	 * @param dockerHost the Docker host information
&nbsp;	 * @param request the request to process
&nbsp;	 * @param builder the ephemeral builder used to run the phases
&nbsp;	 */
&nbsp;	Lifecycle(BuildLog log, DockerApi docker, ResolvedDockerHost dockerHost, BuildRequest request,
<b class="nc">&nbsp;			EphemeralBuilder builder) {</b>
<b class="nc">&nbsp;		this.log = log;</b>
<b class="nc">&nbsp;		this.docker = docker;</b>
<b class="nc">&nbsp;		this.dockerHost = dockerHost;</b>
<b class="nc">&nbsp;		this.request = request;</b>
<b class="nc">&nbsp;		this.builder = builder;</b>
<b class="nc">&nbsp;		this.lifecycleVersion = LifecycleVersion.parse(builder.getBuilderMetadata().getLifecycle().getVersion());</b>
<b class="nc">&nbsp;		this.platformVersion = getPlatformVersion(builder.getBuilderMetadata().getLifecycle());</b>
<b class="nc">&nbsp;		this.layers = getLayersBindingSource(request);</b>
<b class="nc">&nbsp;		this.application = getApplicationBindingSource(request);</b>
<b class="nc">&nbsp;		this.buildCache = getBuildCache(request);</b>
<b class="nc">&nbsp;		this.launchCache = getLaunchCache(request);</b>
<b class="nc">&nbsp;		this.applicationDirectory = getApplicationDirectory(request);</b>
<b class="nc">&nbsp;		this.securityOptions = getSecurityOptions(request);</b>
&nbsp;	}
&nbsp;
&nbsp;	private Cache getBuildCache(BuildRequest request) {
<b class="nc">&nbsp;		if (request.getBuildCache() != null) {</b>
<b class="nc">&nbsp;			return request.getBuildCache();</b>
&nbsp;		}
<b class="nc">&nbsp;		return createVolumeCache(request, &quot;build&quot;);</b>
&nbsp;	}
&nbsp;
&nbsp;	private Cache getLaunchCache(BuildRequest request) {
<b class="nc">&nbsp;		if (request.getLaunchCache() != null) {</b>
<b class="nc">&nbsp;			return request.getLaunchCache();</b>
&nbsp;		}
<b class="nc">&nbsp;		return createVolumeCache(request, &quot;launch&quot;);</b>
&nbsp;	}
&nbsp;
&nbsp;	private String getApplicationDirectory(BuildRequest request) {
<b class="nc">&nbsp;		return (request.getApplicationDirectory() != null) ? request.getApplicationDirectory() : Directory.APPLICATION;</b>
&nbsp;	}
&nbsp;
&nbsp;	private List&lt;String&gt; getSecurityOptions(BuildRequest request) {
<b class="nc">&nbsp;		if (request.getSecurityOptions() != null) {</b>
<b class="nc">&nbsp;			return request.getSecurityOptions();</b>
&nbsp;		}
<b class="nc">&nbsp;		return (Platform.isWindows()) ? Collections.emptyList() : DEFAULT_SECURITY_OPTIONS;</b>
&nbsp;	}
&nbsp;
&nbsp;	private ApiVersion getPlatformVersion(BuilderMetadata.Lifecycle lifecycle) {
<b class="nc">&nbsp;		if (lifecycle.getApis().getPlatform() != null) {</b>
<b class="nc">&nbsp;			String[] supportedVersions = lifecycle.getApis().getPlatform();</b>
<b class="nc">&nbsp;			return ApiVersions.SUPPORTED_PLATFORMS.findLatestSupported(supportedVersions);</b>
&nbsp;		}
<b class="nc">&nbsp;		String version = lifecycle.getApi().getPlatform();</b>
<b class="nc">&nbsp;		return ApiVersions.SUPPORTED_PLATFORMS.findLatestSupported(version);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Execute this lifecycle by running each phase in turn.
&nbsp;	 * @throws IOException on IO error
&nbsp;	 */
&nbsp;	void execute() throws IOException {
<b class="nc">&nbsp;		Assert.state(!this.executed, &quot;Lifecycle has already been executed&quot;);</b>
<b class="nc">&nbsp;		this.executed = true;</b>
<b class="nc">&nbsp;		this.log.executingLifecycle(this.request, this.lifecycleVersion, this.buildCache);</b>
<b class="nc">&nbsp;		if (this.request.isCleanCache()) {</b>
<b class="nc">&nbsp;			deleteCache(this.buildCache);</b>
&nbsp;		}
<b class="nc">&nbsp;		run(createPhase());</b>
<b class="nc">&nbsp;		this.log.executedLifecycle(this.request);</b>
&nbsp;	}
&nbsp;
&nbsp;	private Phase createPhase() {
<b class="nc">&nbsp;		Phase phase = new Phase(&quot;creator&quot;, isVerboseLogging());</b>
<b class="nc">&nbsp;		phase.withDaemonAccess();</b>
<b class="nc">&nbsp;		configureDaemonAccess(phase);</b>
<b class="nc">&nbsp;		phase.withLogLevelArg();</b>
<b class="nc">&nbsp;		phase.withArgs(&quot;-app&quot;, this.applicationDirectory);</b>
<b class="nc">&nbsp;		phase.withArgs(&quot;-platform&quot;, Directory.PLATFORM);</b>
<b class="nc">&nbsp;		phase.withArgs(&quot;-run-image&quot;, this.request.getRunImage());</b>
<b class="nc">&nbsp;		phase.withArgs(&quot;-layers&quot;, Directory.LAYERS);</b>
<b class="nc">&nbsp;		phase.withArgs(&quot;-cache-dir&quot;, Directory.CACHE);</b>
<b class="nc">&nbsp;		phase.withArgs(&quot;-launch-cache&quot;, Directory.LAUNCH_CACHE);</b>
<b class="nc">&nbsp;		phase.withArgs(&quot;-daemon&quot;);</b>
<b class="nc">&nbsp;		if (this.request.isCleanCache()) {</b>
<b class="nc">&nbsp;			phase.withArgs(&quot;-skip-restore&quot;);</b>
&nbsp;		}
<b class="nc">&nbsp;		if (requiresProcessTypeDefault()) {</b>
<b class="nc">&nbsp;			phase.withArgs(&quot;-process-type=web&quot;);</b>
&nbsp;		}
<b class="nc">&nbsp;		phase.withArgs(this.request.getName());</b>
<b class="nc">&nbsp;		phase.withBinding(Binding.from(getCacheBindingSource(this.layers), Directory.LAYERS));</b>
<b class="nc">&nbsp;		phase.withBinding(Binding.from(getCacheBindingSource(this.application), this.applicationDirectory));</b>
<b class="nc">&nbsp;		phase.withBinding(Binding.from(getCacheBindingSource(this.buildCache), Directory.CACHE));</b>
<b class="nc">&nbsp;		phase.withBinding(Binding.from(getCacheBindingSource(this.launchCache), Directory.LAUNCH_CACHE));</b>
<b class="nc">&nbsp;		if (this.request.getBindings() != null) {</b>
<b class="nc">&nbsp;			this.request.getBindings().forEach(phase::withBinding);</b>
&nbsp;		}
<b class="nc">&nbsp;		phase.withEnv(PLATFORM_API_VERSION_KEY, this.platformVersion.toString());</b>
<b class="nc">&nbsp;		if (this.request.getNetwork() != null) {</b>
<b class="nc">&nbsp;			phase.withNetworkMode(this.request.getNetwork());</b>
&nbsp;		}
<b class="nc">&nbsp;		if (this.request.getCreatedDate() != null) {</b>
<b class="nc">&nbsp;			phase.withEnv(SOURCE_DATE_EPOCH_KEY, Long.toString(this.request.getCreatedDate().getEpochSecond()));</b>
&nbsp;		}
<b class="nc">&nbsp;		return phase;</b>
&nbsp;	}
&nbsp;
&nbsp;	private Cache getLayersBindingSource(BuildRequest request) {
<b class="nc">&nbsp;		if (request.getBuildWorkspace() != null) {</b>
<b class="nc">&nbsp;			return getBuildWorkspaceBindingSource(request.getBuildWorkspace(), &quot;layers&quot;);</b>
&nbsp;		}
<b class="nc">&nbsp;		return createVolumeCache(&quot;pack-layers-&quot;);</b>
&nbsp;	}
&nbsp;
&nbsp;	private Cache getApplicationBindingSource(BuildRequest request) {
<b class="nc">&nbsp;		if (request.getBuildWorkspace() != null) {</b>
<b class="nc">&nbsp;			return getBuildWorkspaceBindingSource(request.getBuildWorkspace(), &quot;app&quot;);</b>
&nbsp;		}
<b class="nc">&nbsp;		return createVolumeCache(&quot;pack-app-&quot;);</b>
&nbsp;	}
&nbsp;
&nbsp;	private Cache getBuildWorkspaceBindingSource(Cache buildWorkspace, String suffix) {
<b class="nc">&nbsp;		return (buildWorkspace.getVolume() != null) ? Cache.volume(buildWorkspace.getVolume().getName() + &quot;-&quot; + suffix)</b>
<b class="nc">&nbsp;				: Cache.bind(buildWorkspace.getBind().getSource() + &quot;-&quot; + suffix);</b>
&nbsp;	}
&nbsp;
&nbsp;	private String getCacheBindingSource(Cache cache) {
<b class="nc">&nbsp;		return (cache.getVolume() != null) ? cache.getVolume().getName() : cache.getBind().getSource();</b>
&nbsp;	}
&nbsp;
&nbsp;	private Cache createVolumeCache(String prefix) {
<b class="nc">&nbsp;		return Cache.volume(createRandomVolumeName(prefix));</b>
&nbsp;	}
&nbsp;
&nbsp;	private Cache createVolumeCache(BuildRequest request, String suffix) {
<b class="nc">&nbsp;		return Cache.volume(</b>
<b class="nc">&nbsp;				VolumeName.basedOn(request.getName(), ImageReference::toLegacyString, &quot;pack-cache-&quot;, &quot;.&quot; + suffix, 6));</b>
&nbsp;	}
&nbsp;
&nbsp;	protected VolumeName createRandomVolumeName(String prefix) {
<b class="nc">&nbsp;		return VolumeName.random(prefix);</b>
&nbsp;	}
&nbsp;
&nbsp;	private void configureDaemonAccess(Phase phase) {
<b class="nc">&nbsp;		if (this.dockerHost != null) {</b>
<b class="nc">&nbsp;			if (this.dockerHost.isRemote()) {</b>
<b class="nc">&nbsp;				phase.withEnv(&quot;DOCKER_HOST&quot;, this.dockerHost.getAddress());</b>
<b class="nc">&nbsp;				if (this.dockerHost.isSecure()) {</b>
<b class="nc">&nbsp;					phase.withEnv(&quot;DOCKER_TLS_VERIFY&quot;, &quot;1&quot;);</b>
<b class="nc">&nbsp;					phase.withEnv(&quot;DOCKER_CERT_PATH&quot;, this.dockerHost.getCertificatePath());</b>
&nbsp;				}
&nbsp;			}
&nbsp;			else {
<b class="nc">&nbsp;				phase.withBinding(Binding.from(this.dockerHost.getAddress(), DOMAIN_SOCKET_PATH));</b>
&nbsp;			}
&nbsp;		}
&nbsp;		else {
<b class="nc">&nbsp;			phase.withBinding(Binding.from(DOMAIN_SOCKET_PATH, DOMAIN_SOCKET_PATH));</b>
&nbsp;		}
<b class="nc">&nbsp;		if (this.securityOptions != null) {</b>
<b class="nc">&nbsp;			this.securityOptions.forEach(phase::withSecurityOption);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private boolean isVerboseLogging() {
<b class="nc">&nbsp;		return this.request.isVerboseLogging() &amp;&amp; this.lifecycleVersion.isEqualOrGreaterThan(LOGGING_MINIMUM_VERSION);</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean requiresProcessTypeDefault() {
<b class="nc">&nbsp;		return this.platformVersion.supportsAny(ApiVersion.of(0, 4), ApiVersion.of(0, 5));</b>
&nbsp;	}
&nbsp;
&nbsp;	private void run(Phase phase) throws IOException {
<b class="nc">&nbsp;		Consumer&lt;LogUpdateEvent&gt; logConsumer = this.log.runningPhase(this.request, phase.getName());</b>
<b class="nc">&nbsp;		ContainerConfig containerConfig = ContainerConfig.of(this.builder.getName(), phase::apply);</b>
<b class="nc">&nbsp;		ContainerReference reference = createContainer(containerConfig);</b>
&nbsp;		try {
<b class="nc">&nbsp;			this.docker.container().start(reference);</b>
<b class="nc">&nbsp;			this.docker.container().logs(reference, logConsumer::accept);</b>
<b class="nc">&nbsp;			ContainerStatus status = this.docker.container().wait(reference);</b>
<b class="nc">&nbsp;			if (status.getStatusCode() != 0) {</b>
<b class="nc">&nbsp;				throw new BuilderException(phase.getName(), status.getStatusCode());</b>
&nbsp;			}
&nbsp;		}
&nbsp;		finally {
<b class="nc">&nbsp;			this.docker.container().remove(reference, true);</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	private ContainerReference createContainer(ContainerConfig config) throws IOException {
<b class="nc">&nbsp;		if (this.applicationVolumePopulated) {</b>
<b class="nc">&nbsp;			return this.docker.container().create(config);</b>
&nbsp;		}
&nbsp;		try {
<b class="nc">&nbsp;			if (this.application.getBind() != null) {</b>
<b class="nc">&nbsp;				Files.createDirectories(Path.of(this.application.getBind().getSource()));</b>
&nbsp;			}
<b class="nc">&nbsp;			TarArchive applicationContent = this.request.getApplicationContent(this.builder.getBuildOwner());</b>
<b class="nc">&nbsp;			return this.docker.container()</b>
<b class="nc">&nbsp;				.create(config, ContainerContent.of(applicationContent, this.applicationDirectory));</b>
&nbsp;		}
&nbsp;		finally {
<b class="nc">&nbsp;			this.applicationVolumePopulated = true;</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void close() throws IOException {
<b class="nc">&nbsp;		deleteCache(this.layers);</b>
<b class="nc">&nbsp;		deleteCache(this.application);</b>
&nbsp;	}
&nbsp;
&nbsp;	private void deleteCache(Cache cache) throws IOException {
<b class="nc">&nbsp;		if (cache.getVolume() != null) {</b>
<b class="nc">&nbsp;			deleteVolume(cache.getVolume().getVolumeName());</b>
&nbsp;		}
<b class="nc">&nbsp;		if (cache.getBind() != null) {</b>
<b class="nc">&nbsp;			deleteBind(cache.getBind().getSource());</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private void deleteVolume(VolumeName name) throws IOException {
<b class="nc">&nbsp;		this.docker.volume().delete(name, true);</b>
&nbsp;	}
&nbsp;
&nbsp;	private void deleteBind(String source) {
&nbsp;		try {
<b class="nc">&nbsp;			FileSystemUtils.deleteRecursively(Path.of(source));</b>
&nbsp;		}
<b class="nc">&nbsp;		catch (IOException ex) {</b>
<b class="nc">&nbsp;			throw new IllegalStateException(&quot;Error cleaning bind mount directory &#39;&quot; + source + &quot;&#39;&quot;, ex);</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Common directories used by the various phases.
&nbsp;	 */
&nbsp;	private static final class Directory {
&nbsp;
&nbsp;		/**
&nbsp;		 * The directory used by buildpacks to write their layer contributions. A new
&nbsp;		 * layer directory is created for each lifecycle execution.
&nbsp;		 * &lt;p&gt;
&nbsp;		 * Maps to the {@code &lt;layers...&gt;} concept in the
&nbsp;		 * &lt;a href=&quot;https://github.com/buildpacks/spec/blob/master/buildpack.md&quot;&gt;buildpack
&nbsp;		 * specification&lt;/a&gt; and the {@code -layers} argument from the reference lifecycle
&nbsp;		 * implementation.
&nbsp;		 */
&nbsp;		static final String LAYERS = &quot;/layers&quot;;
&nbsp;
&nbsp;		/**
&nbsp;		 * The directory containing the original contributed application. A new
&nbsp;		 * application directory is created for each lifecycle execution.
&nbsp;		 * &lt;p&gt;
&nbsp;		 * Maps to the {@code &lt;app...&gt;} concept in the
&nbsp;		 * &lt;a href=&quot;https://github.com/buildpacks/spec/blob/master/buildpack.md&quot;&gt;buildpack
&nbsp;		 * specification&lt;/a&gt; and the {@code -app} argument from the reference lifecycle
&nbsp;		 * implementation. The reference lifecycle follows the Kubernetes/Docker
&nbsp;		 * convention of using {@code &#39;/workspace&#39;}.
&nbsp;		 * &lt;p&gt;
&nbsp;		 * Note that application content is uploaded to the container with the first phase
&nbsp;		 * that runs and saved in a volume that is passed to subsequent phases. The
&nbsp;		 * directory is mutable and buildpacks may modify the content.
&nbsp;		 */
&nbsp;		static final String APPLICATION = &quot;/workspace&quot;;
&nbsp;
&nbsp;		/**
&nbsp;		 * The directory used by buildpacks to obtain environment variables and platform
&nbsp;		 * specific concerns. The platform directory is read-only and is created/populated
&nbsp;		 * by the {@link EphemeralBuilder}.
&nbsp;		 * &lt;p&gt;
&nbsp;		 * Maps to the {@code &lt;platform&gt;/env} and {@code &lt;platform&gt;/#} concepts in the
&nbsp;		 * &lt;a href=&quot;https://github.com/buildpacks/spec/blob/master/buildpack.md&quot;&gt;buildpack
&nbsp;		 * specification&lt;/a&gt; and the {@code -platform} argument from the reference
&nbsp;		 * lifecycle implementation.
&nbsp;		 */
&nbsp;		static final String PLATFORM = &quot;/platform&quot;;
&nbsp;
&nbsp;		/**
&nbsp;		 * The directory used by buildpacks for caching. The volume name is based on the
&nbsp;		 * image {@link BuildRequest#getName() name} being built, and is persistent across
&nbsp;		 * invocations even if the application content has changed.
&nbsp;		 * &lt;p&gt;
&nbsp;		 * Maps to the {@code -path} argument from the reference lifecycle implementation
&nbsp;		 * cache and restore phases
&nbsp;		 */
&nbsp;		static final String CACHE = &quot;/cache&quot;;
&nbsp;
&nbsp;		/**
&nbsp;		 * The directory used by buildpacks for launch related caching. The volume name is
&nbsp;		 * based on the image {@link BuildRequest#getName() name} being built, and is
&nbsp;		 * persistent across invocations even if the application content has changed.
&nbsp;		 * &lt;p&gt;
&nbsp;		 * Maps to the {@code -launch-cache} argument from the reference lifecycle
&nbsp;		 * implementation export phase
&nbsp;		 */
&nbsp;		static final String LAUNCH_CACHE = &quot;/launch-cache&quot;;
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-04-01 11:12</div>
</div>
</body>
</html>
