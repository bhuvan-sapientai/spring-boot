


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > ZipString</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.springframework.boot.loader.zip</a>
</div>

<h1>Coverage Summary for Class: ZipString (org.springframework.boot.loader.zip)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">ZipString</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/14)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/134)
  </span>
</td>
</tr>
  <tr>
    <td class="name">ZipString$CompareType</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/16)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/136)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2012-2023 the original author or authors.
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *      https://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;
&nbsp;package org.springframework.boot.loader.zip;
&nbsp;
&nbsp;import java.io.EOFException;
&nbsp;import java.io.IOException;
&nbsp;import java.io.UncheckedIOException;
&nbsp;import java.nio.ByteBuffer;
&nbsp;import java.nio.ByteOrder;
&nbsp;import java.nio.charset.StandardCharsets;
&nbsp;
&nbsp;import org.springframework.boot.loader.log.DebugLogger;
&nbsp;
&nbsp;/**
&nbsp; * Internal utility class for working with the string content of zip records. Provides
&nbsp; * methods that work with raw bytes to save creating temporary strings.
&nbsp; *
&nbsp; * @author Phillip Webb
&nbsp; * @author Andy Wilkinson
&nbsp; */
&nbsp;final class ZipString {
&nbsp;
<b class="nc">&nbsp;	private static final DebugLogger debug = DebugLogger.get(ZipString.class);</b>
&nbsp;
&nbsp;	static final int BUFFER_SIZE = 256;
&nbsp;
<b class="nc">&nbsp;	private static final int[] INITIAL_BYTE_BITMASK = { 0x7F, 0x1F, 0x0F, 0x07 };</b>
&nbsp;
&nbsp;	private static final int SUBSEQUENT_BYTE_BITMASK = 0x3F;
&nbsp;
<b class="nc">&nbsp;	private static final int EMPTY_HASH = &quot;&quot;.hashCode();</b>
&nbsp;
<b class="nc">&nbsp;	private static final int EMPTY_SLASH_HASH = &quot;/&quot;.hashCode();</b>
&nbsp;
&nbsp;	private ZipString() {
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Return a hash for a char sequence, optionally appending &#39;/&#39;.
&nbsp;	 * @param charSequence the source char sequence
&nbsp;	 * @param addEndSlash if slash should be added to the string if it&#39;s not already
&nbsp;	 * present
&nbsp;	 * @return the hash
&nbsp;	 */
&nbsp;	static int hash(CharSequence charSequence, boolean addEndSlash) {
<b class="nc">&nbsp;		return hash(0, charSequence, addEndSlash);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Return a hash for a char sequence, optionally appending &#39;/&#39;.
&nbsp;	 * @param initialHash the initial hash value
&nbsp;	 * @param charSequence the source char sequence
&nbsp;	 * @param addEndSlash if slash should be added to the string if it&#39;s not already
&nbsp;	 * present
&nbsp;	 * @return the hash
&nbsp;	 */
&nbsp;	static int hash(int initialHash, CharSequence charSequence, boolean addEndSlash) {
<b class="nc">&nbsp;		if (charSequence == null || charSequence.isEmpty()) {</b>
<b class="nc">&nbsp;			return (!addEndSlash) ? EMPTY_HASH : EMPTY_SLASH_HASH;</b>
&nbsp;		}
<b class="nc">&nbsp;		boolean endsWithSlash = charSequence.charAt(charSequence.length() - 1) == &#39;/&#39;;</b>
<b class="nc">&nbsp;		int hash = initialHash;</b>
<b class="nc">&nbsp;		if (charSequence instanceof String &amp;&amp; initialHash == 0) {</b>
&nbsp;			// We&#39;re compatible with String.hashCode and it might be already calculated
<b class="nc">&nbsp;			hash = charSequence.hashCode();</b>
&nbsp;		}
&nbsp;		else {
<b class="nc">&nbsp;			for (int i = 0; i &lt; charSequence.length(); i++) {</b>
<b class="nc">&nbsp;				char ch = charSequence.charAt(i);</b>
<b class="nc">&nbsp;				hash = 31 * hash + ch;</b>
&nbsp;			}
&nbsp;		}
<b class="nc">&nbsp;		hash = (addEndSlash &amp;&amp; !endsWithSlash) ? 31 * hash + &#39;/&#39; : hash;</b>
<b class="nc">&nbsp;		debug.log(&quot;%s calculated for charsequence &#39;%s&#39; (addEndSlash=%s)&quot;, hash, charSequence, endsWithSlash);</b>
<b class="nc">&nbsp;		return hash;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Return a hash for bytes read from a {@link DataBlock}, optionally appending &#39;/&#39;.
&nbsp;	 * @param buffer the buffer to use or {@code null}
&nbsp;	 * @param dataBlock the source data block
&nbsp;	 * @param pos the position in the data block where the string starts
&nbsp;	 * @param len the number of bytes to read from the block
&nbsp;	 * @param addEndSlash if slash should be added to the string if it&#39;s not already
&nbsp;	 * present
&nbsp;	 * @return the hash
&nbsp;	 * @throws IOException on I/O error
&nbsp;	 */
&nbsp;	static int hash(ByteBuffer buffer, DataBlock dataBlock, long pos, int len, boolean addEndSlash) throws IOException {
<b class="nc">&nbsp;		if (len == 0) {</b>
<b class="nc">&nbsp;			return (!addEndSlash) ? EMPTY_HASH : EMPTY_SLASH_HASH;</b>
&nbsp;		}
<b class="nc">&nbsp;		buffer = (buffer != null) ? buffer : ByteBuffer.allocate(BUFFER_SIZE);</b>
<b class="nc">&nbsp;		byte[] bytes = buffer.array();</b>
<b class="nc">&nbsp;		int hash = 0;</b>
<b class="nc">&nbsp;		char lastChar = 0;</b>
<b class="nc">&nbsp;		int codePointSize = 1;</b>
<b class="nc">&nbsp;		while (len &gt; 0) {</b>
<b class="nc">&nbsp;			int count = readInBuffer(dataBlock, pos, buffer, len, codePointSize);</b>
<b class="nc">&nbsp;			for (int byteIndex = 0; byteIndex &lt; count;) {</b>
<b class="nc">&nbsp;				codePointSize = getCodePointSize(bytes, byteIndex);</b>
<b class="nc">&nbsp;				if (!hasEnoughBytes(byteIndex, codePointSize, count)) {</b>
<b class="nc">&nbsp;					break;</b>
&nbsp;				}
<b class="nc">&nbsp;				int codePoint = getCodePoint(bytes, byteIndex, codePointSize);</b>
<b class="nc">&nbsp;				if (codePoint &lt;= 0xFFFF) {</b>
<b class="nc">&nbsp;					lastChar = (char) (codePoint &amp; 0xFFFF);</b>
<b class="nc">&nbsp;					hash = 31 * hash + lastChar;</b>
&nbsp;				}
&nbsp;				else {
<b class="nc">&nbsp;					lastChar = 0;</b>
<b class="nc">&nbsp;					hash = 31 * hash + Character.highSurrogate(codePoint);</b>
<b class="nc">&nbsp;					hash = 31 * hash + Character.lowSurrogate(codePoint);</b>
&nbsp;				}
<b class="nc">&nbsp;				byteIndex += codePointSize;</b>
<b class="nc">&nbsp;				pos += codePointSize;</b>
<b class="nc">&nbsp;				len -= codePointSize;</b>
<b class="nc">&nbsp;				codePointSize = 1;</b>
<b class="nc">&nbsp;			}</b>
<b class="nc">&nbsp;		}</b>
<b class="nc">&nbsp;		hash = (addEndSlash &amp;&amp; lastChar != &#39;/&#39;) ? 31 * hash + &#39;/&#39; : hash;</b>
<b class="nc">&nbsp;		debug.log(&quot;%08X calculated for datablock position %s size %s (addEndSlash=%s)&quot;, hash, pos, len, addEndSlash);</b>
<b class="nc">&nbsp;		return hash;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Return if the bytes read from a {@link DataBlock} matches the give
&nbsp;	 * {@link CharSequence}.
&nbsp;	 * @param buffer the buffer to use or {@code null}
&nbsp;	 * @param dataBlock the source data block
&nbsp;	 * @param pos the position in the data block where the string starts
&nbsp;	 * @param len the number of bytes to read from the block
&nbsp;	 * @param charSequence the char sequence with which to compare
&nbsp;	 * @param addSlash also accept {@code charSequence + &#39;/&#39;} when it doesn&#39;t already end
&nbsp;	 * with one
&nbsp;	 * @return true if the contents are considered equal
&nbsp;	 */
&nbsp;	static boolean matches(ByteBuffer buffer, DataBlock dataBlock, long pos, int len, CharSequence charSequence,
&nbsp;			boolean addSlash) {
<b class="nc">&nbsp;		if (charSequence.isEmpty()) {</b>
<b class="nc">&nbsp;			return true;</b>
&nbsp;		}
<b class="nc">&nbsp;		buffer = (buffer != null) ? buffer : ByteBuffer.allocate(BUFFER_SIZE);</b>
&nbsp;		try {
<b class="nc">&nbsp;			return compare(buffer, dataBlock, pos, len, charSequence,</b>
<b class="nc">&nbsp;					(!addSlash) ? CompareType.MATCHES : CompareType.MATCHES_ADDING_SLASH) != -1;</b>
&nbsp;		}
<b class="nc">&nbsp;		catch (IOException ex) {</b>
<b class="nc">&nbsp;			throw new UncheckedIOException(ex);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns if the bytes read from a {@link DataBlock} starts with the given
&nbsp;	 * {@link CharSequence}.
&nbsp;	 * @param buffer the buffer to use or {@code null}
&nbsp;	 * @param dataBlock the source data block
&nbsp;	 * @param pos the position in the data block where the string starts
&nbsp;	 * @param len the number of bytes to read from the block
&nbsp;	 * @param charSequence the required starting chars
&nbsp;	 * @return {@code -1} if the data block does not start with the char sequence, or a
&nbsp;	 * positive number indicating the number of bytes that contain the starting chars
&nbsp;	 */
&nbsp;	static int startsWith(ByteBuffer buffer, DataBlock dataBlock, long pos, int len, CharSequence charSequence) {
<b class="nc">&nbsp;		if (charSequence.isEmpty()) {</b>
<b class="nc">&nbsp;			return 0;</b>
&nbsp;		}
<b class="nc">&nbsp;		buffer = (buffer != null) ? buffer : ByteBuffer.allocate(BUFFER_SIZE);</b>
&nbsp;		try {
<b class="nc">&nbsp;			return compare(buffer, dataBlock, pos, len, charSequence, CompareType.STARTS_WITH);</b>
&nbsp;		}
<b class="nc">&nbsp;		catch (IOException ex) {</b>
<b class="nc">&nbsp;			throw new UncheckedIOException(ex);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private static int compare(ByteBuffer buffer, DataBlock dataBlock, long pos, int len, CharSequence charSequence,
&nbsp;			CompareType compareType) throws IOException {
<b class="nc">&nbsp;		if (charSequence.isEmpty()) {</b>
<b class="nc">&nbsp;			return 0;</b>
&nbsp;		}
<b class="nc">&nbsp;		boolean addSlash = compareType == CompareType.MATCHES_ADDING_SLASH &amp;&amp; !endsWith(charSequence, &#39;/&#39;);</b>
<b class="nc">&nbsp;		int charSequenceIndex = 0;</b>
<b class="nc">&nbsp;		int maxCharSequenceLength = (!addSlash) ? charSequence.length() : charSequence.length() + 1;</b>
<b class="nc">&nbsp;		int result = 0;</b>
<b class="nc">&nbsp;		byte[] bytes = buffer.array();</b>
<b class="nc">&nbsp;		int codePointSize = 1;</b>
<b class="nc">&nbsp;		while (len &gt; 0) {</b>
<b class="nc">&nbsp;			int count = readInBuffer(dataBlock, pos, buffer, len, codePointSize);</b>
<b class="nc">&nbsp;			for (int byteIndex = 0; byteIndex &lt; count;) {</b>
<b class="nc">&nbsp;				codePointSize = getCodePointSize(bytes, byteIndex);</b>
<b class="nc">&nbsp;				if (!hasEnoughBytes(byteIndex, codePointSize, count)) {</b>
<b class="nc">&nbsp;					break;</b>
&nbsp;				}
<b class="nc">&nbsp;				int codePoint = getCodePoint(bytes, byteIndex, codePointSize);</b>
<b class="nc">&nbsp;				if (codePoint &lt;= 0xFFFF) {</b>
<b class="nc">&nbsp;					char ch = (char) (codePoint &amp; 0xFFFF);</b>
<b class="nc">&nbsp;					if (charSequenceIndex &gt;= maxCharSequenceLength</b>
<b class="nc">&nbsp;							|| getChar(charSequence, charSequenceIndex++) != ch) {</b>
<b class="nc">&nbsp;						return -1;</b>
&nbsp;					}
<b class="nc">&nbsp;				}</b>
&nbsp;				else {
<b class="nc">&nbsp;					char ch = Character.highSurrogate(codePoint);</b>
<b class="nc">&nbsp;					if (charSequenceIndex &gt;= maxCharSequenceLength</b>
<b class="nc">&nbsp;							|| getChar(charSequence, charSequenceIndex++) != ch) {</b>
<b class="nc">&nbsp;						return -1;</b>
&nbsp;					}
<b class="nc">&nbsp;					ch = Character.lowSurrogate(codePoint);</b>
<b class="nc">&nbsp;					if (charSequenceIndex &gt;= charSequence.length()</b>
<b class="nc">&nbsp;							|| getChar(charSequence, charSequenceIndex++) != ch) {</b>
<b class="nc">&nbsp;						return -1;</b>
&nbsp;					}
&nbsp;				}
<b class="nc">&nbsp;				byteIndex += codePointSize;</b>
<b class="nc">&nbsp;				pos += codePointSize;</b>
<b class="nc">&nbsp;				len -= codePointSize;</b>
<b class="nc">&nbsp;				result += codePointSize;</b>
<b class="nc">&nbsp;				codePointSize = 1;</b>
<b class="nc">&nbsp;				if (compareType == CompareType.STARTS_WITH &amp;&amp; charSequenceIndex &gt;= charSequence.length()) {</b>
<b class="nc">&nbsp;					return result;</b>
&nbsp;				}
<b class="nc">&nbsp;			}</b>
<b class="nc">&nbsp;		}</b>
<b class="nc">&nbsp;		return (charSequenceIndex &gt;= charSequence.length()) ? result : -1;</b>
&nbsp;	}
&nbsp;
&nbsp;	private static boolean hasEnoughBytes(int byteIndex, int codePointSize, int count) {
<b class="nc">&nbsp;		return (byteIndex + codePointSize - 1) &lt; count;</b>
&nbsp;	}
&nbsp;
&nbsp;	private static boolean endsWith(CharSequence charSequence, char ch) {
<b class="nc">&nbsp;		return !charSequence.isEmpty() &amp;&amp; charSequence.charAt(charSequence.length() - 1) == ch;</b>
&nbsp;	}
&nbsp;
&nbsp;	private static char getChar(CharSequence charSequence, int index) {
<b class="nc">&nbsp;		return (index != charSequence.length()) ? charSequence.charAt(index) : &#39;/&#39;;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Read a string value from the given data block.
&nbsp;	 * @param data the source data
&nbsp;	 * @param pos the position to read from
&nbsp;	 * @param len the number of bytes to read
&nbsp;	 * @return the contents as a string
&nbsp;	 */
&nbsp;	static String readString(DataBlock data, long pos, long len) {
&nbsp;		try {
<b class="nc">&nbsp;			if (len &gt; Integer.MAX_VALUE) {</b>
<b class="nc">&nbsp;				throw new IllegalStateException(&quot;String is too long to read&quot;);</b>
&nbsp;			}
<b class="nc">&nbsp;			ByteBuffer buffer = ByteBuffer.allocate((int) len);</b>
<b class="nc">&nbsp;			buffer.order(ByteOrder.LITTLE_ENDIAN);</b>
<b class="nc">&nbsp;			data.readFully(buffer, pos);</b>
<b class="nc">&nbsp;			return new String(buffer.array(), StandardCharsets.UTF_8);</b>
&nbsp;		}
<b class="nc">&nbsp;		catch (IOException ex) {</b>
<b class="nc">&nbsp;			throw new UncheckedIOException(ex);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private static int readInBuffer(DataBlock dataBlock, long pos, ByteBuffer buffer, int maxLen, int minLen)
&nbsp;			throws IOException {
<b class="nc">&nbsp;		buffer.clear();</b>
<b class="nc">&nbsp;		if (buffer.remaining() &gt; maxLen) {</b>
<b class="nc">&nbsp;			buffer.limit(maxLen);</b>
&nbsp;		}
<b class="nc">&nbsp;		int result = 0;</b>
<b class="nc">&nbsp;		while (result &lt; minLen) {</b>
<b class="nc">&nbsp;			int count = dataBlock.read(buffer, pos);</b>
<b class="nc">&nbsp;			if (count &lt;= 0) {</b>
<b class="nc">&nbsp;				throw new EOFException();</b>
&nbsp;			}
<b class="nc">&nbsp;			result += count;</b>
<b class="nc">&nbsp;			pos += count;</b>
<b class="nc">&nbsp;		}</b>
<b class="nc">&nbsp;		return result;</b>
&nbsp;	}
&nbsp;
&nbsp;	private static int getCodePointSize(byte[] bytes, int i) {
<b class="nc">&nbsp;		int b = Byte.toUnsignedInt(bytes[i]);</b>
<b class="nc">&nbsp;		if ((b &amp; 0b1_0000000) == 0b0_0000000) {</b>
<b class="nc">&nbsp;			return 1;</b>
&nbsp;		}
<b class="nc">&nbsp;		if ((b &amp; 0b111_00000) == 0b110_00000) {</b>
<b class="nc">&nbsp;			return 2;</b>
&nbsp;		}
<b class="nc">&nbsp;		if ((b &amp; 0b1111_0000) == 0b1110_0000) {</b>
<b class="nc">&nbsp;			return 3;</b>
&nbsp;		}
<b class="nc">&nbsp;		return 4;</b>
&nbsp;	}
&nbsp;
&nbsp;	private static int getCodePoint(byte[] bytes, int i, int codePointSize) {
<b class="nc">&nbsp;		int codePoint = Byte.toUnsignedInt(bytes[i]);</b>
<b class="nc">&nbsp;		codePoint &amp;= INITIAL_BYTE_BITMASK[codePointSize - 1];</b>
<b class="nc">&nbsp;		for (int j = 1; j &lt; codePointSize; j++) {</b>
<b class="nc">&nbsp;			codePoint = (codePoint &lt;&lt; 6) + (bytes[i + j] &amp; SUBSEQUENT_BYTE_BITMASK);</b>
&nbsp;		}
<b class="nc">&nbsp;		return codePoint;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Supported compare types.
&nbsp;	 */
<b class="nc">&nbsp;	private enum CompareType {</b>
&nbsp;
<b class="nc">&nbsp;		MATCHES, MATCHES_ADDING_SLASH, STARTS_WITH</b>
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-04-01 11:12</div>
</div>
</body>
</html>
