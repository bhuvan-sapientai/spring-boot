


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > KafkaProperties</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.springframework.boot.autoconfigure.kafka</a>
</div>

<h1>Coverage Summary for Class: KafkaProperties (org.springframework.boot.autoconfigure.kafka)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">KafkaProperties</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/25)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/54)
  </span>
</td>
</tr>
  <tr>
    <td class="name">KafkaProperties$Admin</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/17)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/24)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">KafkaProperties$Cleanup</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">KafkaProperties$Consumer</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/31)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/61)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">KafkaProperties$IsolationLevel</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">KafkaProperties$Jaas</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">KafkaProperties$Listener</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/39)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/44)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">KafkaProperties$Listener$Type</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">KafkaProperties$Producer</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/25)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/43)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">KafkaProperties$Properties</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">KafkaProperties$Retry</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">KafkaProperties$Retry$Topic</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/13)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/18)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">KafkaProperties$Security</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">KafkaProperties$Ssl</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/35)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/72)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">KafkaProperties$Streams</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/20)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/35)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">KafkaProperties$Template</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/241)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/403)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2012-2024 the original author or authors.
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *      https://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;
&nbsp;package org.springframework.boot.autoconfigure.kafka;
&nbsp;
&nbsp;import java.io.IOException;
&nbsp;import java.time.Duration;
&nbsp;import java.time.temporal.ChronoUnit;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Collections;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.List;
&nbsp;import java.util.Locale;
&nbsp;import java.util.Map;
&nbsp;
&nbsp;import org.apache.kafka.clients.CommonClientConfigs;
&nbsp;import org.apache.kafka.clients.consumer.ConsumerConfig;
&nbsp;import org.apache.kafka.clients.producer.ProducerConfig;
&nbsp;import org.apache.kafka.common.config.SslConfigs;
&nbsp;import org.apache.kafka.common.serialization.StringDeserializer;
&nbsp;import org.apache.kafka.common.serialization.StringSerializer;
&nbsp;
&nbsp;import org.springframework.boot.context.properties.ConfigurationProperties;
&nbsp;import org.springframework.boot.context.properties.PropertyMapper;
&nbsp;import org.springframework.boot.context.properties.source.MutuallyExclusiveConfigurationPropertiesException;
&nbsp;import org.springframework.boot.convert.DurationUnit;
&nbsp;import org.springframework.boot.ssl.SslBundle;
&nbsp;import org.springframework.boot.ssl.SslBundles;
&nbsp;import org.springframework.core.io.Resource;
&nbsp;import org.springframework.kafka.listener.ContainerProperties.AckMode;
&nbsp;import org.springframework.kafka.security.jaas.KafkaJaasLoginModuleInitializer;
&nbsp;import org.springframework.util.CollectionUtils;
&nbsp;import org.springframework.util.unit.DataSize;
&nbsp;
&nbsp;/**
&nbsp; * Configuration properties for Spring for Apache Kafka.
&nbsp; * &lt;p&gt;
&nbsp; * Users should refer to Kafka documentation for complete descriptions of these
&nbsp; * properties.
&nbsp; *
&nbsp; * @author Gary Russell
&nbsp; * @author Stephane Nicoll
&nbsp; * @author Artem Bilan
&nbsp; * @author Nakul Mishra
&nbsp; * @author Tomaz Fernandes
&nbsp; * @author Andy Wilkinson
&nbsp; * @author Scott Frederick
&nbsp; * @since 1.5.0
&nbsp; */
&nbsp;@ConfigurationProperties(prefix = &quot;spring.kafka&quot;)
<b class="nc">&nbsp;public class KafkaProperties {</b>
&nbsp;
&nbsp;	/**
&nbsp;	 * Comma-delimited list of host:port pairs to use for establishing the initial
&nbsp;	 * connections to the Kafka cluster. Applies to all components unless overridden.
&nbsp;	 */
<b class="nc">&nbsp;	private List&lt;String&gt; bootstrapServers = new ArrayList&lt;&gt;(Collections.singletonList(&quot;localhost:9092&quot;));</b>
&nbsp;
&nbsp;	/**
&nbsp;	 * ID to pass to the server when making requests. Used for server-side logging.
&nbsp;	 */
&nbsp;	private String clientId;
&nbsp;
&nbsp;	/**
&nbsp;	 * Additional properties, common to producers and consumers, used to configure the
&nbsp;	 * client.
&nbsp;	 */
<b class="nc">&nbsp;	private final Map&lt;String, String&gt; properties = new HashMap&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;	private final Consumer consumer = new Consumer();</b>
&nbsp;
<b class="nc">&nbsp;	private final Producer producer = new Producer();</b>
&nbsp;
<b class="nc">&nbsp;	private final Admin admin = new Admin();</b>
&nbsp;
<b class="nc">&nbsp;	private final Streams streams = new Streams();</b>
&nbsp;
<b class="nc">&nbsp;	private final Listener listener = new Listener();</b>
&nbsp;
<b class="nc">&nbsp;	private final Ssl ssl = new Ssl();</b>
&nbsp;
<b class="nc">&nbsp;	private final Jaas jaas = new Jaas();</b>
&nbsp;
<b class="nc">&nbsp;	private final Template template = new Template();</b>
&nbsp;
<b class="nc">&nbsp;	private final Security security = new Security();</b>
&nbsp;
<b class="nc">&nbsp;	private final Retry retry = new Retry();</b>
&nbsp;
&nbsp;	public List&lt;String&gt; getBootstrapServers() {
<b class="nc">&nbsp;		return this.bootstrapServers;</b>
&nbsp;	}
&nbsp;
&nbsp;	public void setBootstrapServers(List&lt;String&gt; bootstrapServers) {
<b class="nc">&nbsp;		this.bootstrapServers = bootstrapServers;</b>
&nbsp;	}
&nbsp;
&nbsp;	public String getClientId() {
<b class="nc">&nbsp;		return this.clientId;</b>
&nbsp;	}
&nbsp;
&nbsp;	public void setClientId(String clientId) {
<b class="nc">&nbsp;		this.clientId = clientId;</b>
&nbsp;	}
&nbsp;
&nbsp;	public Map&lt;String, String&gt; getProperties() {
<b class="nc">&nbsp;		return this.properties;</b>
&nbsp;	}
&nbsp;
&nbsp;	public Consumer getConsumer() {
<b class="nc">&nbsp;		return this.consumer;</b>
&nbsp;	}
&nbsp;
&nbsp;	public Producer getProducer() {
<b class="nc">&nbsp;		return this.producer;</b>
&nbsp;	}
&nbsp;
&nbsp;	public Listener getListener() {
<b class="nc">&nbsp;		return this.listener;</b>
&nbsp;	}
&nbsp;
&nbsp;	public Admin getAdmin() {
<b class="nc">&nbsp;		return this.admin;</b>
&nbsp;	}
&nbsp;
&nbsp;	public Streams getStreams() {
<b class="nc">&nbsp;		return this.streams;</b>
&nbsp;	}
&nbsp;
&nbsp;	public Ssl getSsl() {
<b class="nc">&nbsp;		return this.ssl;</b>
&nbsp;	}
&nbsp;
&nbsp;	public Jaas getJaas() {
<b class="nc">&nbsp;		return this.jaas;</b>
&nbsp;	}
&nbsp;
&nbsp;	public Template getTemplate() {
<b class="nc">&nbsp;		return this.template;</b>
&nbsp;	}
&nbsp;
&nbsp;	public Security getSecurity() {
<b class="nc">&nbsp;		return this.security;</b>
&nbsp;	}
&nbsp;
&nbsp;	public Retry getRetry() {
<b class="nc">&nbsp;		return this.retry;</b>
&nbsp;	}
&nbsp;
&nbsp;	private Map&lt;String, Object&gt; buildCommonProperties(SslBundles sslBundles) {
<b class="nc">&nbsp;		Map&lt;String, Object&gt; properties = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;		if (this.bootstrapServers != null) {</b>
<b class="nc">&nbsp;			properties.put(CommonClientConfigs.BOOTSTRAP_SERVERS_CONFIG, this.bootstrapServers);</b>
&nbsp;		}
<b class="nc">&nbsp;		if (this.clientId != null) {</b>
<b class="nc">&nbsp;			properties.put(CommonClientConfigs.CLIENT_ID_CONFIG, this.clientId);</b>
&nbsp;		}
<b class="nc">&nbsp;		properties.putAll(this.ssl.buildProperties(sslBundles));</b>
<b class="nc">&nbsp;		properties.putAll(this.security.buildProperties());</b>
<b class="nc">&nbsp;		if (!CollectionUtils.isEmpty(this.properties)) {</b>
<b class="nc">&nbsp;			properties.putAll(this.properties);</b>
&nbsp;		}
<b class="nc">&nbsp;		return properties;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Create an initial map of consumer properties from the state of this instance.
&nbsp;	 * &lt;p&gt;
&nbsp;	 * This allows you to add additional properties, if necessary, and override the
&nbsp;	 * default {@code kafkaConsumerFactory} bean.
&nbsp;	 * @return the consumer properties initialized with the customizations defined on this
&nbsp;	 * instance
&nbsp;	 * @deprecated since 3.2.0 for removal in 3.4.0 in favor of
&nbsp;	 * {@link #buildConsumerProperties(SslBundles)}}
&nbsp;	 */
&nbsp;	@Deprecated(since = &quot;3.2.0&quot;, forRemoval = true)
&nbsp;	public Map&lt;String, Object&gt; buildConsumerProperties() {
<b class="nc">&nbsp;		return buildConsumerProperties(null);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Create an initial map of consumer properties from the state of this instance.
&nbsp;	 * &lt;p&gt;
&nbsp;	 * This allows you to add additional properties, if necessary, and override the
&nbsp;	 * default {@code kafkaConsumerFactory} bean.
&nbsp;	 * @param sslBundles bundles providing SSL trust material
&nbsp;	 * @return the consumer properties initialized with the customizations defined on this
&nbsp;	 * instance
&nbsp;	 */
&nbsp;	public Map&lt;String, Object&gt; buildConsumerProperties(SslBundles sslBundles) {
<b class="nc">&nbsp;		Map&lt;String, Object&gt; properties = buildCommonProperties(sslBundles);</b>
<b class="nc">&nbsp;		properties.putAll(this.consumer.buildProperties(sslBundles));</b>
<b class="nc">&nbsp;		return properties;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Create an initial map of producer properties from the state of this instance.
&nbsp;	 * &lt;p&gt;
&nbsp;	 * This allows you to add additional properties, if necessary, and override the
&nbsp;	 * default {@code kafkaProducerFactory} bean.
&nbsp;	 * @return the producer properties initialized with the customizations defined on this
&nbsp;	 * instance
&nbsp;	 * @deprecated since 3.2.0 for removal in 3.4.0 in favor of
&nbsp;	 * {@link #buildProducerProperties(SslBundles)}}
&nbsp;	 */
&nbsp;	@Deprecated(since = &quot;3.2.0&quot;, forRemoval = true)
&nbsp;	public Map&lt;String, Object&gt; buildProducerProperties() {
<b class="nc">&nbsp;		return buildProducerProperties(null);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Create an initial map of producer properties from the state of this instance.
&nbsp;	 * &lt;p&gt;
&nbsp;	 * This allows you to add additional properties, if necessary, and override the
&nbsp;	 * default {@code kafkaProducerFactory} bean.
&nbsp;	 * @param sslBundles bundles providing SSL trust material
&nbsp;	 * @return the producer properties initialized with the customizations defined on this
&nbsp;	 * instance
&nbsp;	 */
&nbsp;	public Map&lt;String, Object&gt; buildProducerProperties(SslBundles sslBundles) {
<b class="nc">&nbsp;		Map&lt;String, Object&gt; properties = buildCommonProperties(sslBundles);</b>
<b class="nc">&nbsp;		properties.putAll(this.producer.buildProperties(sslBundles));</b>
<b class="nc">&nbsp;		return properties;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Create an initial map of admin properties from the state of this instance.
&nbsp;	 * &lt;p&gt;
&nbsp;	 * This allows you to add additional properties, if necessary, and override the
&nbsp;	 * default {@code kafkaAdmin} bean.
&nbsp;	 * @return the admin properties initialized with the customizations defined on this
&nbsp;	 * instance
&nbsp;	 * @deprecated since 3.2.0 for removal in 3.4.0 in favor of
&nbsp;	 * {@link #buildAdminProperties(SslBundles)}}
&nbsp;	 */
&nbsp;	@Deprecated(since = &quot;3.2.0&quot;, forRemoval = true)
&nbsp;	public Map&lt;String, Object&gt; buildAdminProperties() {
<b class="nc">&nbsp;		return buildAdminProperties(null);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Create an initial map of admin properties from the state of this instance.
&nbsp;	 * &lt;p&gt;
&nbsp;	 * This allows you to add additional properties, if necessary, and override the
&nbsp;	 * default {@code kafkaAdmin} bean.
&nbsp;	 * @param sslBundles bundles providing SSL trust material
&nbsp;	 * @return the admin properties initialized with the customizations defined on this
&nbsp;	 * instance
&nbsp;	 */
&nbsp;	public Map&lt;String, Object&gt; buildAdminProperties(SslBundles sslBundles) {
<b class="nc">&nbsp;		Map&lt;String, Object&gt; properties = buildCommonProperties(sslBundles);</b>
<b class="nc">&nbsp;		properties.putAll(this.admin.buildProperties(sslBundles));</b>
<b class="nc">&nbsp;		return properties;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Create an initial map of streams properties from the state of this instance.
&nbsp;	 * &lt;p&gt;
&nbsp;	 * This allows you to add additional properties, if necessary.
&nbsp;	 * @return the streams properties initialized with the customizations defined on this
&nbsp;	 * instance
&nbsp;	 * @deprecated since 3.2.0 for removal in 3.4.0 in favor of
&nbsp;	 * {@link #buildStreamsProperties(SslBundles)}}
&nbsp;	 */
&nbsp;	@Deprecated(since = &quot;3.2.0&quot;, forRemoval = true)
&nbsp;	public Map&lt;String, Object&gt; buildStreamsProperties() {
<b class="nc">&nbsp;		return buildStreamsProperties(null);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Create an initial map of streams properties from the state of this instance.
&nbsp;	 * &lt;p&gt;
&nbsp;	 * This allows you to add additional properties, if necessary.
&nbsp;	 * @param sslBundles bundles providing SSL trust material
&nbsp;	 * @return the streams properties initialized with the customizations defined on this
&nbsp;	 * instance
&nbsp;	 */
&nbsp;	public Map&lt;String, Object&gt; buildStreamsProperties(SslBundles sslBundles) {
<b class="nc">&nbsp;		Map&lt;String, Object&gt; properties = buildCommonProperties(sslBundles);</b>
<b class="nc">&nbsp;		properties.putAll(this.streams.buildProperties(sslBundles));</b>
<b class="nc">&nbsp;		return properties;</b>
&nbsp;	}
&nbsp;
<b class="nc">&nbsp;	public static class Consumer {</b>
&nbsp;
<b class="nc">&nbsp;		private final Ssl ssl = new Ssl();</b>
&nbsp;
<b class="nc">&nbsp;		private final Security security = new Security();</b>
&nbsp;
&nbsp;		/**
&nbsp;		 * Frequency with which the consumer offsets are auto-committed to Kafka if
&nbsp;		 * &#39;enable.auto.commit&#39; is set to true.
&nbsp;		 */
&nbsp;		private Duration autoCommitInterval;
&nbsp;
&nbsp;		/**
&nbsp;		 * What to do when there is no initial offset in Kafka or if the current offset no
&nbsp;		 * longer exists on the server.
&nbsp;		 */
&nbsp;		private String autoOffsetReset;
&nbsp;
&nbsp;		/**
&nbsp;		 * Comma-delimited list of host:port pairs to use for establishing the initial
&nbsp;		 * connections to the Kafka cluster. Overrides the global property, for consumers.
&nbsp;		 */
&nbsp;		private List&lt;String&gt; bootstrapServers;
&nbsp;
&nbsp;		/**
&nbsp;		 * ID to pass to the server when making requests. Used for server-side logging.
&nbsp;		 */
&nbsp;		private String clientId;
&nbsp;
&nbsp;		/**
&nbsp;		 * Whether the consumer&#39;s offset is periodically committed in the background.
&nbsp;		 */
&nbsp;		private Boolean enableAutoCommit;
&nbsp;
&nbsp;		/**
&nbsp;		 * Maximum amount of time the server blocks before answering the fetch request if
&nbsp;		 * there isn&#39;t sufficient data to immediately satisfy the requirement given by
&nbsp;		 * &quot;fetch-min-size&quot;.
&nbsp;		 */
&nbsp;		private Duration fetchMaxWait;
&nbsp;
&nbsp;		/**
&nbsp;		 * Minimum amount of data the server should return for a fetch request.
&nbsp;		 */
&nbsp;		private DataSize fetchMinSize;
&nbsp;
&nbsp;		/**
&nbsp;		 * Unique string that identifies the consumer group to which this consumer
&nbsp;		 * belongs.
&nbsp;		 */
&nbsp;		private String groupId;
&nbsp;
&nbsp;		/**
&nbsp;		 * Expected time between heartbeats to the consumer coordinator.
&nbsp;		 */
&nbsp;		private Duration heartbeatInterval;
&nbsp;
&nbsp;		/**
&nbsp;		 * Isolation level for reading messages that have been written transactionally.
&nbsp;		 */
<b class="nc">&nbsp;		private IsolationLevel isolationLevel = IsolationLevel.READ_UNCOMMITTED;</b>
&nbsp;
&nbsp;		/**
&nbsp;		 * Deserializer class for keys.
&nbsp;		 */
<b class="nc">&nbsp;		private Class&lt;?&gt; keyDeserializer = StringDeserializer.class;</b>
&nbsp;
&nbsp;		/**
&nbsp;		 * Deserializer class for values.
&nbsp;		 */
<b class="nc">&nbsp;		private Class&lt;?&gt; valueDeserializer = StringDeserializer.class;</b>
&nbsp;
&nbsp;		/**
&nbsp;		 * Maximum number of records returned in a single call to poll().
&nbsp;		 */
&nbsp;		private Integer maxPollRecords;
&nbsp;
&nbsp;		/**
&nbsp;		 * Additional consumer-specific properties used to configure the client.
&nbsp;		 */
<b class="nc">&nbsp;		private final Map&lt;String, String&gt; properties = new HashMap&lt;&gt;();</b>
&nbsp;
&nbsp;		public Ssl getSsl() {
<b class="nc">&nbsp;			return this.ssl;</b>
&nbsp;		}
&nbsp;
&nbsp;		public Security getSecurity() {
<b class="nc">&nbsp;			return this.security;</b>
&nbsp;		}
&nbsp;
&nbsp;		public Duration getAutoCommitInterval() {
<b class="nc">&nbsp;			return this.autoCommitInterval;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setAutoCommitInterval(Duration autoCommitInterval) {
<b class="nc">&nbsp;			this.autoCommitInterval = autoCommitInterval;</b>
&nbsp;		}
&nbsp;
&nbsp;		public String getAutoOffsetReset() {
<b class="nc">&nbsp;			return this.autoOffsetReset;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setAutoOffsetReset(String autoOffsetReset) {
<b class="nc">&nbsp;			this.autoOffsetReset = autoOffsetReset;</b>
&nbsp;		}
&nbsp;
&nbsp;		public List&lt;String&gt; getBootstrapServers() {
<b class="nc">&nbsp;			return this.bootstrapServers;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setBootstrapServers(List&lt;String&gt; bootstrapServers) {
<b class="nc">&nbsp;			this.bootstrapServers = bootstrapServers;</b>
&nbsp;		}
&nbsp;
&nbsp;		public String getClientId() {
<b class="nc">&nbsp;			return this.clientId;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setClientId(String clientId) {
<b class="nc">&nbsp;			this.clientId = clientId;</b>
&nbsp;		}
&nbsp;
&nbsp;		public Boolean getEnableAutoCommit() {
<b class="nc">&nbsp;			return this.enableAutoCommit;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setEnableAutoCommit(Boolean enableAutoCommit) {
<b class="nc">&nbsp;			this.enableAutoCommit = enableAutoCommit;</b>
&nbsp;		}
&nbsp;
&nbsp;		public Duration getFetchMaxWait() {
<b class="nc">&nbsp;			return this.fetchMaxWait;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setFetchMaxWait(Duration fetchMaxWait) {
<b class="nc">&nbsp;			this.fetchMaxWait = fetchMaxWait;</b>
&nbsp;		}
&nbsp;
&nbsp;		public DataSize getFetchMinSize() {
<b class="nc">&nbsp;			return this.fetchMinSize;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setFetchMinSize(DataSize fetchMinSize) {
<b class="nc">&nbsp;			this.fetchMinSize = fetchMinSize;</b>
&nbsp;		}
&nbsp;
&nbsp;		public String getGroupId() {
<b class="nc">&nbsp;			return this.groupId;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setGroupId(String groupId) {
<b class="nc">&nbsp;			this.groupId = groupId;</b>
&nbsp;		}
&nbsp;
&nbsp;		public Duration getHeartbeatInterval() {
<b class="nc">&nbsp;			return this.heartbeatInterval;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setHeartbeatInterval(Duration heartbeatInterval) {
<b class="nc">&nbsp;			this.heartbeatInterval = heartbeatInterval;</b>
&nbsp;		}
&nbsp;
&nbsp;		public IsolationLevel getIsolationLevel() {
<b class="nc">&nbsp;			return this.isolationLevel;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setIsolationLevel(IsolationLevel isolationLevel) {
<b class="nc">&nbsp;			this.isolationLevel = isolationLevel;</b>
&nbsp;		}
&nbsp;
&nbsp;		public Class&lt;?&gt; getKeyDeserializer() {
<b class="nc">&nbsp;			return this.keyDeserializer;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setKeyDeserializer(Class&lt;?&gt; keyDeserializer) {
<b class="nc">&nbsp;			this.keyDeserializer = keyDeserializer;</b>
&nbsp;		}
&nbsp;
&nbsp;		public Class&lt;?&gt; getValueDeserializer() {
<b class="nc">&nbsp;			return this.valueDeserializer;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setValueDeserializer(Class&lt;?&gt; valueDeserializer) {
<b class="nc">&nbsp;			this.valueDeserializer = valueDeserializer;</b>
&nbsp;		}
&nbsp;
&nbsp;		public Integer getMaxPollRecords() {
<b class="nc">&nbsp;			return this.maxPollRecords;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setMaxPollRecords(Integer maxPollRecords) {
<b class="nc">&nbsp;			this.maxPollRecords = maxPollRecords;</b>
&nbsp;		}
&nbsp;
&nbsp;		public Map&lt;String, String&gt; getProperties() {
<b class="nc">&nbsp;			return this.properties;</b>
&nbsp;		}
&nbsp;
&nbsp;		public Map&lt;String, Object&gt; buildProperties(SslBundles sslBundles) {
<b class="nc">&nbsp;			Properties properties = new Properties();</b>
<b class="nc">&nbsp;			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();</b>
<b class="nc">&nbsp;			map.from(this::getAutoCommitInterval)</b>
<b class="nc">&nbsp;				.asInt(Duration::toMillis)</b>
<b class="nc">&nbsp;				.to(properties.in(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG));</b>
<b class="nc">&nbsp;			map.from(this::getAutoOffsetReset).to(properties.in(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG));</b>
<b class="nc">&nbsp;			map.from(this::getBootstrapServers).to(properties.in(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG));</b>
<b class="nc">&nbsp;			map.from(this::getClientId).to(properties.in(ConsumerConfig.CLIENT_ID_CONFIG));</b>
<b class="nc">&nbsp;			map.from(this::getEnableAutoCommit).to(properties.in(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG));</b>
<b class="nc">&nbsp;			map.from(this::getFetchMaxWait)</b>
<b class="nc">&nbsp;				.asInt(Duration::toMillis)</b>
<b class="nc">&nbsp;				.to(properties.in(ConsumerConfig.FETCH_MAX_WAIT_MS_CONFIG));</b>
<b class="nc">&nbsp;			map.from(this::getFetchMinSize)</b>
<b class="nc">&nbsp;				.asInt(DataSize::toBytes)</b>
<b class="nc">&nbsp;				.to(properties.in(ConsumerConfig.FETCH_MIN_BYTES_CONFIG));</b>
<b class="nc">&nbsp;			map.from(this::getGroupId).to(properties.in(ConsumerConfig.GROUP_ID_CONFIG));</b>
<b class="nc">&nbsp;			map.from(this::getHeartbeatInterval)</b>
<b class="nc">&nbsp;				.asInt(Duration::toMillis)</b>
<b class="nc">&nbsp;				.to(properties.in(ConsumerConfig.HEARTBEAT_INTERVAL_MS_CONFIG));</b>
<b class="nc">&nbsp;			map.from(() -&gt; getIsolationLevel().name().toLowerCase(Locale.ROOT))</b>
<b class="nc">&nbsp;				.to(properties.in(ConsumerConfig.ISOLATION_LEVEL_CONFIG));</b>
<b class="nc">&nbsp;			map.from(this::getKeyDeserializer).to(properties.in(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG));</b>
<b class="nc">&nbsp;			map.from(this::getValueDeserializer).to(properties.in(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG));</b>
<b class="nc">&nbsp;			map.from(this::getMaxPollRecords).to(properties.in(ConsumerConfig.MAX_POLL_RECORDS_CONFIG));</b>
<b class="nc">&nbsp;			return properties.with(this.ssl, this.security, this.properties, sslBundles);</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
<b class="nc">&nbsp;	public static class Producer {</b>
&nbsp;
<b class="nc">&nbsp;		private final Ssl ssl = new Ssl();</b>
&nbsp;
<b class="nc">&nbsp;		private final Security security = new Security();</b>
&nbsp;
&nbsp;		/**
&nbsp;		 * Number of acknowledgments the producer requires the leader to have received
&nbsp;		 * before considering a request complete.
&nbsp;		 */
&nbsp;		private String acks;
&nbsp;
&nbsp;		/**
&nbsp;		 * Default batch size. A small batch size will make batching less common and may
&nbsp;		 * reduce throughput (a batch size of zero disables batching entirely).
&nbsp;		 */
&nbsp;		private DataSize batchSize;
&nbsp;
&nbsp;		/**
&nbsp;		 * Comma-delimited list of host:port pairs to use for establishing the initial
&nbsp;		 * connections to the Kafka cluster. Overrides the global property, for producers.
&nbsp;		 */
&nbsp;		private List&lt;String&gt; bootstrapServers;
&nbsp;
&nbsp;		/**
&nbsp;		 * Total memory size the producer can use to buffer records waiting to be sent to
&nbsp;		 * the server.
&nbsp;		 */
&nbsp;		private DataSize bufferMemory;
&nbsp;
&nbsp;		/**
&nbsp;		 * ID to pass to the server when making requests. Used for server-side logging.
&nbsp;		 */
&nbsp;		private String clientId;
&nbsp;
&nbsp;		/**
&nbsp;		 * Compression type for all data generated by the producer.
&nbsp;		 */
&nbsp;		private String compressionType;
&nbsp;
&nbsp;		/**
&nbsp;		 * Serializer class for keys.
&nbsp;		 */
<b class="nc">&nbsp;		private Class&lt;?&gt; keySerializer = StringSerializer.class;</b>
&nbsp;
&nbsp;		/**
&nbsp;		 * Serializer class for values.
&nbsp;		 */
<b class="nc">&nbsp;		private Class&lt;?&gt; valueSerializer = StringSerializer.class;</b>
&nbsp;
&nbsp;		/**
&nbsp;		 * When greater than zero, enables retrying of failed sends.
&nbsp;		 */
&nbsp;		private Integer retries;
&nbsp;
&nbsp;		/**
&nbsp;		 * When non empty, enables transaction support for producer.
&nbsp;		 */
&nbsp;		private String transactionIdPrefix;
&nbsp;
&nbsp;		/**
&nbsp;		 * Additional producer-specific properties used to configure the client.
&nbsp;		 */
<b class="nc">&nbsp;		private final Map&lt;String, String&gt; properties = new HashMap&lt;&gt;();</b>
&nbsp;
&nbsp;		public Ssl getSsl() {
<b class="nc">&nbsp;			return this.ssl;</b>
&nbsp;		}
&nbsp;
&nbsp;		public Security getSecurity() {
<b class="nc">&nbsp;			return this.security;</b>
&nbsp;		}
&nbsp;
&nbsp;		public String getAcks() {
<b class="nc">&nbsp;			return this.acks;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setAcks(String acks) {
<b class="nc">&nbsp;			this.acks = acks;</b>
&nbsp;		}
&nbsp;
&nbsp;		public DataSize getBatchSize() {
<b class="nc">&nbsp;			return this.batchSize;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setBatchSize(DataSize batchSize) {
<b class="nc">&nbsp;			this.batchSize = batchSize;</b>
&nbsp;		}
&nbsp;
&nbsp;		public List&lt;String&gt; getBootstrapServers() {
<b class="nc">&nbsp;			return this.bootstrapServers;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setBootstrapServers(List&lt;String&gt; bootstrapServers) {
<b class="nc">&nbsp;			this.bootstrapServers = bootstrapServers;</b>
&nbsp;		}
&nbsp;
&nbsp;		public DataSize getBufferMemory() {
<b class="nc">&nbsp;			return this.bufferMemory;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setBufferMemory(DataSize bufferMemory) {
<b class="nc">&nbsp;			this.bufferMemory = bufferMemory;</b>
&nbsp;		}
&nbsp;
&nbsp;		public String getClientId() {
<b class="nc">&nbsp;			return this.clientId;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setClientId(String clientId) {
<b class="nc">&nbsp;			this.clientId = clientId;</b>
&nbsp;		}
&nbsp;
&nbsp;		public String getCompressionType() {
<b class="nc">&nbsp;			return this.compressionType;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setCompressionType(String compressionType) {
<b class="nc">&nbsp;			this.compressionType = compressionType;</b>
&nbsp;		}
&nbsp;
&nbsp;		public Class&lt;?&gt; getKeySerializer() {
<b class="nc">&nbsp;			return this.keySerializer;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setKeySerializer(Class&lt;?&gt; keySerializer) {
<b class="nc">&nbsp;			this.keySerializer = keySerializer;</b>
&nbsp;		}
&nbsp;
&nbsp;		public Class&lt;?&gt; getValueSerializer() {
<b class="nc">&nbsp;			return this.valueSerializer;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setValueSerializer(Class&lt;?&gt; valueSerializer) {
<b class="nc">&nbsp;			this.valueSerializer = valueSerializer;</b>
&nbsp;		}
&nbsp;
&nbsp;		public Integer getRetries() {
<b class="nc">&nbsp;			return this.retries;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setRetries(Integer retries) {
<b class="nc">&nbsp;			this.retries = retries;</b>
&nbsp;		}
&nbsp;
&nbsp;		public String getTransactionIdPrefix() {
<b class="nc">&nbsp;			return this.transactionIdPrefix;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setTransactionIdPrefix(String transactionIdPrefix) {
<b class="nc">&nbsp;			this.transactionIdPrefix = transactionIdPrefix;</b>
&nbsp;		}
&nbsp;
&nbsp;		public Map&lt;String, String&gt; getProperties() {
<b class="nc">&nbsp;			return this.properties;</b>
&nbsp;		}
&nbsp;
&nbsp;		public Map&lt;String, Object&gt; buildProperties(SslBundles sslBundles) {
<b class="nc">&nbsp;			Properties properties = new Properties();</b>
<b class="nc">&nbsp;			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();</b>
<b class="nc">&nbsp;			map.from(this::getAcks).to(properties.in(ProducerConfig.ACKS_CONFIG));</b>
<b class="nc">&nbsp;			map.from(this::getBatchSize).asInt(DataSize::toBytes).to(properties.in(ProducerConfig.BATCH_SIZE_CONFIG));</b>
<b class="nc">&nbsp;			map.from(this::getBootstrapServers).to(properties.in(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG));</b>
<b class="nc">&nbsp;			map.from(this::getBufferMemory)</b>
<b class="nc">&nbsp;				.as(DataSize::toBytes)</b>
<b class="nc">&nbsp;				.to(properties.in(ProducerConfig.BUFFER_MEMORY_CONFIG));</b>
<b class="nc">&nbsp;			map.from(this::getClientId).to(properties.in(ProducerConfig.CLIENT_ID_CONFIG));</b>
<b class="nc">&nbsp;			map.from(this::getCompressionType).to(properties.in(ProducerConfig.COMPRESSION_TYPE_CONFIG));</b>
<b class="nc">&nbsp;			map.from(this::getKeySerializer).to(properties.in(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG));</b>
<b class="nc">&nbsp;			map.from(this::getRetries).to(properties.in(ProducerConfig.RETRIES_CONFIG));</b>
<b class="nc">&nbsp;			map.from(this::getValueSerializer).to(properties.in(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG));</b>
<b class="nc">&nbsp;			return properties.with(this.ssl, this.security, this.properties, sslBundles);</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
<b class="nc">&nbsp;	public static class Admin {</b>
&nbsp;
<b class="nc">&nbsp;		private final Ssl ssl = new Ssl();</b>
&nbsp;
<b class="nc">&nbsp;		private final Security security = new Security();</b>
&nbsp;
&nbsp;		/**
&nbsp;		 * ID to pass to the server when making requests. Used for server-side logging.
&nbsp;		 */
&nbsp;		private String clientId;
&nbsp;
&nbsp;		/**
&nbsp;		 * Additional admin-specific properties used to configure the client.
&nbsp;		 */
<b class="nc">&nbsp;		private final Map&lt;String, String&gt; properties = new HashMap&lt;&gt;();</b>
&nbsp;
&nbsp;		/**
&nbsp;		 * Close timeout.
&nbsp;		 */
&nbsp;		private Duration closeTimeout;
&nbsp;
&nbsp;		/**
&nbsp;		 * Operation timeout.
&nbsp;		 */
&nbsp;		private Duration operationTimeout;
&nbsp;
&nbsp;		/**
&nbsp;		 * Whether to fail fast if the broker is not available on startup.
&nbsp;		 */
&nbsp;		private boolean failFast;
&nbsp;
&nbsp;		/**
&nbsp;		 * Whether to enable modification of existing topic configuration.
&nbsp;		 */
&nbsp;		private boolean modifyTopicConfigs;
&nbsp;
&nbsp;		/**
&nbsp;		 * Whether to automatically create topics during context initialization. When set
&nbsp;		 * to false, disables automatic topic creation during context initialization.
&nbsp;		 */
<b class="nc">&nbsp;		private boolean autoCreate = true;</b>
&nbsp;
&nbsp;		public Ssl getSsl() {
<b class="nc">&nbsp;			return this.ssl;</b>
&nbsp;		}
&nbsp;
&nbsp;		public Security getSecurity() {
<b class="nc">&nbsp;			return this.security;</b>
&nbsp;		}
&nbsp;
&nbsp;		public String getClientId() {
<b class="nc">&nbsp;			return this.clientId;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setClientId(String clientId) {
<b class="nc">&nbsp;			this.clientId = clientId;</b>
&nbsp;		}
&nbsp;
&nbsp;		public Duration getCloseTimeout() {
<b class="nc">&nbsp;			return this.closeTimeout;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setCloseTimeout(Duration closeTimeout) {
<b class="nc">&nbsp;			this.closeTimeout = closeTimeout;</b>
&nbsp;		}
&nbsp;
&nbsp;		public Duration getOperationTimeout() {
<b class="nc">&nbsp;			return this.operationTimeout;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setOperationTimeout(Duration operationTimeout) {
<b class="nc">&nbsp;			this.operationTimeout = operationTimeout;</b>
&nbsp;		}
&nbsp;
&nbsp;		public boolean isFailFast() {
<b class="nc">&nbsp;			return this.failFast;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setFailFast(boolean failFast) {
<b class="nc">&nbsp;			this.failFast = failFast;</b>
&nbsp;		}
&nbsp;
&nbsp;		public boolean isModifyTopicConfigs() {
<b class="nc">&nbsp;			return this.modifyTopicConfigs;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setModifyTopicConfigs(boolean modifyTopicConfigs) {
<b class="nc">&nbsp;			this.modifyTopicConfigs = modifyTopicConfigs;</b>
&nbsp;		}
&nbsp;
&nbsp;		public boolean isAutoCreate() {
<b class="nc">&nbsp;			return this.autoCreate;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setAutoCreate(boolean autoCreate) {
<b class="nc">&nbsp;			this.autoCreate = autoCreate;</b>
&nbsp;		}
&nbsp;
&nbsp;		public Map&lt;String, String&gt; getProperties() {
<b class="nc">&nbsp;			return this.properties;</b>
&nbsp;		}
&nbsp;
&nbsp;		public Map&lt;String, Object&gt; buildProperties(SslBundles sslBundles) {
<b class="nc">&nbsp;			Properties properties = new Properties();</b>
<b class="nc">&nbsp;			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();</b>
<b class="nc">&nbsp;			map.from(this::getClientId).to(properties.in(ProducerConfig.CLIENT_ID_CONFIG));</b>
<b class="nc">&nbsp;			return properties.with(this.ssl, this.security, this.properties, sslBundles);</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * High (and some medium) priority Streams properties and a general properties bucket.
&nbsp;	 */
<b class="nc">&nbsp;	public static class Streams {</b>
&nbsp;
<b class="nc">&nbsp;		private final Ssl ssl = new Ssl();</b>
&nbsp;
<b class="nc">&nbsp;		private final Security security = new Security();</b>
&nbsp;
<b class="nc">&nbsp;		private final Cleanup cleanup = new Cleanup();</b>
&nbsp;
&nbsp;		/**
&nbsp;		 * Kafka streams application.id property; default spring.application.name.
&nbsp;		 */
&nbsp;		private String applicationId;
&nbsp;
&nbsp;		/**
&nbsp;		 * Whether to auto-start the streams factory bean.
&nbsp;		 */
<b class="nc">&nbsp;		private boolean autoStartup = true;</b>
&nbsp;
&nbsp;		/**
&nbsp;		 * Comma-delimited list of host:port pairs to use for establishing the initial
&nbsp;		 * connections to the Kafka cluster. Overrides the global property, for streams.
&nbsp;		 */
&nbsp;		private List&lt;String&gt; bootstrapServers;
&nbsp;
&nbsp;		/**
&nbsp;		 * Maximum size of the in-memory state store cache across all threads.
&nbsp;		 */
&nbsp;		private DataSize stateStoreCacheMaxSize;
&nbsp;
&nbsp;		/**
&nbsp;		 * ID to pass to the server when making requests. Used for server-side logging.
&nbsp;		 */
&nbsp;		private String clientId;
&nbsp;
&nbsp;		/**
&nbsp;		 * The replication factor for change log topics and repartition topics created by
&nbsp;		 * the stream processing application.
&nbsp;		 */
&nbsp;		private Integer replicationFactor;
&nbsp;
&nbsp;		/**
&nbsp;		 * Directory location for the state store.
&nbsp;		 */
&nbsp;		private String stateDir;
&nbsp;
&nbsp;		/**
&nbsp;		 * Additional Kafka properties used to configure the streams.
&nbsp;		 */
<b class="nc">&nbsp;		private final Map&lt;String, String&gt; properties = new HashMap&lt;&gt;();</b>
&nbsp;
&nbsp;		public Ssl getSsl() {
<b class="nc">&nbsp;			return this.ssl;</b>
&nbsp;		}
&nbsp;
&nbsp;		public Security getSecurity() {
<b class="nc">&nbsp;			return this.security;</b>
&nbsp;		}
&nbsp;
&nbsp;		public Cleanup getCleanup() {
<b class="nc">&nbsp;			return this.cleanup;</b>
&nbsp;		}
&nbsp;
&nbsp;		public String getApplicationId() {
<b class="nc">&nbsp;			return this.applicationId;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setApplicationId(String applicationId) {
<b class="nc">&nbsp;			this.applicationId = applicationId;</b>
&nbsp;		}
&nbsp;
&nbsp;		public boolean isAutoStartup() {
<b class="nc">&nbsp;			return this.autoStartup;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setAutoStartup(boolean autoStartup) {
<b class="nc">&nbsp;			this.autoStartup = autoStartup;</b>
&nbsp;		}
&nbsp;
&nbsp;		public List&lt;String&gt; getBootstrapServers() {
<b class="nc">&nbsp;			return this.bootstrapServers;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setBootstrapServers(List&lt;String&gt; bootstrapServers) {
<b class="nc">&nbsp;			this.bootstrapServers = bootstrapServers;</b>
&nbsp;		}
&nbsp;
&nbsp;		public DataSize getStateStoreCacheMaxSize() {
<b class="nc">&nbsp;			return this.stateStoreCacheMaxSize;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setStateStoreCacheMaxSize(DataSize stateStoreCacheMaxSize) {
<b class="nc">&nbsp;			this.stateStoreCacheMaxSize = stateStoreCacheMaxSize;</b>
&nbsp;		}
&nbsp;
&nbsp;		public String getClientId() {
<b class="nc">&nbsp;			return this.clientId;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setClientId(String clientId) {
<b class="nc">&nbsp;			this.clientId = clientId;</b>
&nbsp;		}
&nbsp;
&nbsp;		public Integer getReplicationFactor() {
<b class="nc">&nbsp;			return this.replicationFactor;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setReplicationFactor(Integer replicationFactor) {
<b class="nc">&nbsp;			this.replicationFactor = replicationFactor;</b>
&nbsp;		}
&nbsp;
&nbsp;		public String getStateDir() {
<b class="nc">&nbsp;			return this.stateDir;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setStateDir(String stateDir) {
<b class="nc">&nbsp;			this.stateDir = stateDir;</b>
&nbsp;		}
&nbsp;
&nbsp;		public Map&lt;String, String&gt; getProperties() {
<b class="nc">&nbsp;			return this.properties;</b>
&nbsp;		}
&nbsp;
&nbsp;		public Map&lt;String, Object&gt; buildProperties(SslBundles sslBundles) {
<b class="nc">&nbsp;			Properties properties = new Properties();</b>
<b class="nc">&nbsp;			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();</b>
<b class="nc">&nbsp;			map.from(this::getApplicationId).to(properties.in(&quot;application.id&quot;));</b>
<b class="nc">&nbsp;			map.from(this::getBootstrapServers).to(properties.in(CommonClientConfigs.BOOTSTRAP_SERVERS_CONFIG));</b>
<b class="nc">&nbsp;			map.from(this::getStateStoreCacheMaxSize)</b>
<b class="nc">&nbsp;				.asInt(DataSize::toBytes)</b>
<b class="nc">&nbsp;				.to(properties.in(&quot;statestore.cache.max.bytes&quot;));</b>
<b class="nc">&nbsp;			map.from(this::getClientId).to(properties.in(CommonClientConfigs.CLIENT_ID_CONFIG));</b>
<b class="nc">&nbsp;			map.from(this::getReplicationFactor).to(properties.in(&quot;replication.factor&quot;));</b>
<b class="nc">&nbsp;			map.from(this::getStateDir).to(properties.in(&quot;state.dir&quot;));</b>
<b class="nc">&nbsp;			return properties.with(this.ssl, this.security, this.properties, sslBundles);</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
<b class="nc">&nbsp;	public static class Template {</b>
&nbsp;
&nbsp;		/**
&nbsp;		 * Default topic to which messages are sent.
&nbsp;		 */
&nbsp;		private String defaultTopic;
&nbsp;
&nbsp;		/**
&nbsp;		 * Transaction id prefix, override the transaction id prefix in the producer
&nbsp;		 * factory.
&nbsp;		 */
&nbsp;		private String transactionIdPrefix;
&nbsp;
&nbsp;		/**
&nbsp;		 * Whether to enable observation.
&nbsp;		 */
&nbsp;		private boolean observationEnabled;
&nbsp;
&nbsp;		public String getDefaultTopic() {
<b class="nc">&nbsp;			return this.defaultTopic;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setDefaultTopic(String defaultTopic) {
<b class="nc">&nbsp;			this.defaultTopic = defaultTopic;</b>
&nbsp;		}
&nbsp;
&nbsp;		public String getTransactionIdPrefix() {
<b class="nc">&nbsp;			return this.transactionIdPrefix;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setTransactionIdPrefix(String transactionIdPrefix) {
<b class="nc">&nbsp;			this.transactionIdPrefix = transactionIdPrefix;</b>
&nbsp;		}
&nbsp;
&nbsp;		public boolean isObservationEnabled() {
<b class="nc">&nbsp;			return this.observationEnabled;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setObservationEnabled(boolean observationEnabled) {
<b class="nc">&nbsp;			this.observationEnabled = observationEnabled;</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
<b class="nc">&nbsp;	public static class Listener {</b>
&nbsp;
<b class="nc">&nbsp;		public enum Type {</b>
&nbsp;
&nbsp;			/**
&nbsp;			 * Invokes the endpoint with one ConsumerRecord at a time.
&nbsp;			 */
<b class="nc">&nbsp;			SINGLE,</b>
&nbsp;
&nbsp;			/**
&nbsp;			 * Invokes the endpoint with a batch of ConsumerRecords.
&nbsp;			 */
<b class="nc">&nbsp;			BATCH</b>
&nbsp;
&nbsp;		}
&nbsp;
&nbsp;		/**
&nbsp;		 * Listener type.
&nbsp;		 */
<b class="nc">&nbsp;		private Type type = Type.SINGLE;</b>
&nbsp;
&nbsp;		/**
&nbsp;		 * Listener AckMode. See the spring-kafka documentation.
&nbsp;		 */
&nbsp;		private AckMode ackMode;
&nbsp;
&nbsp;		/**
&nbsp;		 * Support for asynchronous record acknowledgements. Only applies when
&nbsp;		 * spring.kafka.listener.ack-mode is manual or manual-immediate.
&nbsp;		 */
&nbsp;		private Boolean asyncAcks;
&nbsp;
&nbsp;		/**
&nbsp;		 * Prefix for the listener&#39;s consumer client.id property.
&nbsp;		 */
&nbsp;		private String clientId;
&nbsp;
&nbsp;		/**
&nbsp;		 * Number of threads to run in the listener containers.
&nbsp;		 */
&nbsp;		private Integer concurrency;
&nbsp;
&nbsp;		/**
&nbsp;		 * Timeout to use when polling the consumer.
&nbsp;		 */
&nbsp;		private Duration pollTimeout;
&nbsp;
&nbsp;		/**
&nbsp;		 * Multiplier applied to &quot;pollTimeout&quot; to determine if a consumer is
&nbsp;		 * non-responsive.
&nbsp;		 */
&nbsp;		private Float noPollThreshold;
&nbsp;
&nbsp;		/**
&nbsp;		 * Number of records between offset commits when ackMode is &quot;COUNT&quot; or
&nbsp;		 * &quot;COUNT_TIME&quot;.
&nbsp;		 */
&nbsp;		private Integer ackCount;
&nbsp;
&nbsp;		/**
&nbsp;		 * Time between offset commits when ackMode is &quot;TIME&quot; or &quot;COUNT_TIME&quot;.
&nbsp;		 */
&nbsp;		private Duration ackTime;
&nbsp;
&nbsp;		/**
&nbsp;		 * Sleep interval between Consumer.poll(Duration) calls.
&nbsp;		 */
<b class="nc">&nbsp;		private Duration idleBetweenPolls = Duration.ZERO;</b>
&nbsp;
&nbsp;		/**
&nbsp;		 * Time between publishing idle consumer events (no data received).
&nbsp;		 */
&nbsp;		private Duration idleEventInterval;
&nbsp;
&nbsp;		/**
&nbsp;		 * Time between publishing idle partition consumer events (no data received for
&nbsp;		 * partition).
&nbsp;		 */
&nbsp;		private Duration idlePartitionEventInterval;
&nbsp;
&nbsp;		/**
&nbsp;		 * Time between checks for non-responsive consumers. If a duration suffix is not
&nbsp;		 * specified, seconds will be used.
&nbsp;		 */
&nbsp;		@DurationUnit(ChronoUnit.SECONDS)
&nbsp;		private Duration monitorInterval;
&nbsp;
&nbsp;		/**
&nbsp;		 * Whether to log the container configuration during initialization (INFO level).
&nbsp;		 */
&nbsp;		private Boolean logContainerConfig;
&nbsp;
&nbsp;		/**
&nbsp;		 * Whether the container should fail to start if at least one of the configured
&nbsp;		 * topics are not present on the broker.
&nbsp;		 */
<b class="nc">&nbsp;		private boolean missingTopicsFatal = false;</b>
&nbsp;
&nbsp;		/**
&nbsp;		 * Whether the container stops after the current record is processed or after all
&nbsp;		 * the records from the previous poll are processed.
&nbsp;		 */
<b class="nc">&nbsp;		private boolean immediateStop = false;</b>
&nbsp;
&nbsp;		/**
&nbsp;		 * Whether to auto start the container.
&nbsp;		 */
<b class="nc">&nbsp;		private boolean autoStartup = true;</b>
&nbsp;
&nbsp;		/**
&nbsp;		 * Whether to instruct the container to change the consumer thread name during
&nbsp;		 * initialization.
&nbsp;		 */
&nbsp;		private Boolean changeConsumerThreadName;
&nbsp;
&nbsp;		/**
&nbsp;		 * Whether to enable observation.
&nbsp;		 */
&nbsp;		private boolean observationEnabled;
&nbsp;
&nbsp;		public Type getType() {
<b class="nc">&nbsp;			return this.type;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setType(Type type) {
<b class="nc">&nbsp;			this.type = type;</b>
&nbsp;		}
&nbsp;
&nbsp;		public AckMode getAckMode() {
<b class="nc">&nbsp;			return this.ackMode;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setAckMode(AckMode ackMode) {
<b class="nc">&nbsp;			this.ackMode = ackMode;</b>
&nbsp;		}
&nbsp;
&nbsp;		public Boolean getAsyncAcks() {
<b class="nc">&nbsp;			return this.asyncAcks;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setAsyncAcks(Boolean asyncAcks) {
<b class="nc">&nbsp;			this.asyncAcks = asyncAcks;</b>
&nbsp;		}
&nbsp;
&nbsp;		public String getClientId() {
<b class="nc">&nbsp;			return this.clientId;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setClientId(String clientId) {
<b class="nc">&nbsp;			this.clientId = clientId;</b>
&nbsp;		}
&nbsp;
&nbsp;		public Integer getConcurrency() {
<b class="nc">&nbsp;			return this.concurrency;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setConcurrency(Integer concurrency) {
<b class="nc">&nbsp;			this.concurrency = concurrency;</b>
&nbsp;		}
&nbsp;
&nbsp;		public Duration getPollTimeout() {
<b class="nc">&nbsp;			return this.pollTimeout;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setPollTimeout(Duration pollTimeout) {
<b class="nc">&nbsp;			this.pollTimeout = pollTimeout;</b>
&nbsp;		}
&nbsp;
&nbsp;		public Float getNoPollThreshold() {
<b class="nc">&nbsp;			return this.noPollThreshold;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setNoPollThreshold(Float noPollThreshold) {
<b class="nc">&nbsp;			this.noPollThreshold = noPollThreshold;</b>
&nbsp;		}
&nbsp;
&nbsp;		public Integer getAckCount() {
<b class="nc">&nbsp;			return this.ackCount;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setAckCount(Integer ackCount) {
<b class="nc">&nbsp;			this.ackCount = ackCount;</b>
&nbsp;		}
&nbsp;
&nbsp;		public Duration getAckTime() {
<b class="nc">&nbsp;			return this.ackTime;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setAckTime(Duration ackTime) {
<b class="nc">&nbsp;			this.ackTime = ackTime;</b>
&nbsp;		}
&nbsp;
&nbsp;		public Duration getIdleBetweenPolls() {
<b class="nc">&nbsp;			return this.idleBetweenPolls;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setIdleBetweenPolls(Duration idleBetweenPolls) {
<b class="nc">&nbsp;			this.idleBetweenPolls = idleBetweenPolls;</b>
&nbsp;		}
&nbsp;
&nbsp;		public Duration getIdleEventInterval() {
<b class="nc">&nbsp;			return this.idleEventInterval;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setIdleEventInterval(Duration idleEventInterval) {
<b class="nc">&nbsp;			this.idleEventInterval = idleEventInterval;</b>
&nbsp;		}
&nbsp;
&nbsp;		public Duration getIdlePartitionEventInterval() {
<b class="nc">&nbsp;			return this.idlePartitionEventInterval;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setIdlePartitionEventInterval(Duration idlePartitionEventInterval) {
<b class="nc">&nbsp;			this.idlePartitionEventInterval = idlePartitionEventInterval;</b>
&nbsp;		}
&nbsp;
&nbsp;		public Duration getMonitorInterval() {
<b class="nc">&nbsp;			return this.monitorInterval;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setMonitorInterval(Duration monitorInterval) {
<b class="nc">&nbsp;			this.monitorInterval = monitorInterval;</b>
&nbsp;		}
&nbsp;
&nbsp;		public Boolean getLogContainerConfig() {
<b class="nc">&nbsp;			return this.logContainerConfig;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setLogContainerConfig(Boolean logContainerConfig) {
<b class="nc">&nbsp;			this.logContainerConfig = logContainerConfig;</b>
&nbsp;		}
&nbsp;
&nbsp;		public boolean isMissingTopicsFatal() {
<b class="nc">&nbsp;			return this.missingTopicsFatal;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setMissingTopicsFatal(boolean missingTopicsFatal) {
<b class="nc">&nbsp;			this.missingTopicsFatal = missingTopicsFatal;</b>
&nbsp;		}
&nbsp;
&nbsp;		public boolean isImmediateStop() {
<b class="nc">&nbsp;			return this.immediateStop;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setImmediateStop(boolean immediateStop) {
<b class="nc">&nbsp;			this.immediateStop = immediateStop;</b>
&nbsp;		}
&nbsp;
&nbsp;		public boolean isAutoStartup() {
<b class="nc">&nbsp;			return this.autoStartup;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setAutoStartup(boolean autoStartup) {
<b class="nc">&nbsp;			this.autoStartup = autoStartup;</b>
&nbsp;		}
&nbsp;
&nbsp;		public Boolean getChangeConsumerThreadName() {
<b class="nc">&nbsp;			return this.changeConsumerThreadName;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setChangeConsumerThreadName(Boolean changeConsumerThreadName) {
<b class="nc">&nbsp;			this.changeConsumerThreadName = changeConsumerThreadName;</b>
&nbsp;		}
&nbsp;
&nbsp;		public boolean isObservationEnabled() {
<b class="nc">&nbsp;			return this.observationEnabled;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setObservationEnabled(boolean observationEnabled) {
<b class="nc">&nbsp;			this.observationEnabled = observationEnabled;</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
<b class="nc">&nbsp;	public static class Ssl {</b>
&nbsp;
&nbsp;		/**
&nbsp;		 * Name of the SSL bundle to use.
&nbsp;		 */
&nbsp;		private String bundle;
&nbsp;
&nbsp;		/**
&nbsp;		 * Password of the private key in either key store key or key store file.
&nbsp;		 */
&nbsp;		private String keyPassword;
&nbsp;
&nbsp;		/**
&nbsp;		 * Certificate chain in PEM format with a list of X.509 certificates.
&nbsp;		 */
&nbsp;		private String keyStoreCertificateChain;
&nbsp;
&nbsp;		/**
&nbsp;		 * Private key in PEM format with PKCS#8 keys.
&nbsp;		 */
&nbsp;		private String keyStoreKey;
&nbsp;
&nbsp;		/**
&nbsp;		 * Location of the key store file.
&nbsp;		 */
&nbsp;		private Resource keyStoreLocation;
&nbsp;
&nbsp;		/**
&nbsp;		 * Store password for the key store file.
&nbsp;		 */
&nbsp;		private String keyStorePassword;
&nbsp;
&nbsp;		/**
&nbsp;		 * Type of the key store.
&nbsp;		 */
&nbsp;		private String keyStoreType;
&nbsp;
&nbsp;		/**
&nbsp;		 * Trusted certificates in PEM format with X.509 certificates.
&nbsp;		 */
&nbsp;		private String trustStoreCertificates;
&nbsp;
&nbsp;		/**
&nbsp;		 * Location of the trust store file.
&nbsp;		 */
&nbsp;		private Resource trustStoreLocation;
&nbsp;
&nbsp;		/**
&nbsp;		 * Store password for the trust store file.
&nbsp;		 */
&nbsp;		private String trustStorePassword;
&nbsp;
&nbsp;		/**
&nbsp;		 * Type of the trust store.
&nbsp;		 */
&nbsp;		private String trustStoreType;
&nbsp;
&nbsp;		/**
&nbsp;		 * SSL protocol to use.
&nbsp;		 */
&nbsp;		private String protocol;
&nbsp;
&nbsp;		public String getBundle() {
<b class="nc">&nbsp;			return this.bundle;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setBundle(String bundle) {
<b class="nc">&nbsp;			this.bundle = bundle;</b>
&nbsp;		}
&nbsp;
&nbsp;		public String getKeyPassword() {
<b class="nc">&nbsp;			return this.keyPassword;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setKeyPassword(String keyPassword) {
<b class="nc">&nbsp;			this.keyPassword = keyPassword;</b>
&nbsp;		}
&nbsp;
&nbsp;		public String getKeyStoreCertificateChain() {
<b class="nc">&nbsp;			return this.keyStoreCertificateChain;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setKeyStoreCertificateChain(String keyStoreCertificateChain) {
<b class="nc">&nbsp;			this.keyStoreCertificateChain = keyStoreCertificateChain;</b>
&nbsp;		}
&nbsp;
&nbsp;		public String getKeyStoreKey() {
<b class="nc">&nbsp;			return this.keyStoreKey;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setKeyStoreKey(String keyStoreKey) {
<b class="nc">&nbsp;			this.keyStoreKey = keyStoreKey;</b>
&nbsp;		}
&nbsp;
&nbsp;		public Resource getKeyStoreLocation() {
<b class="nc">&nbsp;			return this.keyStoreLocation;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setKeyStoreLocation(Resource keyStoreLocation) {
<b class="nc">&nbsp;			this.keyStoreLocation = keyStoreLocation;</b>
&nbsp;		}
&nbsp;
&nbsp;		public String getKeyStorePassword() {
<b class="nc">&nbsp;			return this.keyStorePassword;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setKeyStorePassword(String keyStorePassword) {
<b class="nc">&nbsp;			this.keyStorePassword = keyStorePassword;</b>
&nbsp;		}
&nbsp;
&nbsp;		public String getKeyStoreType() {
<b class="nc">&nbsp;			return this.keyStoreType;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setKeyStoreType(String keyStoreType) {
<b class="nc">&nbsp;			this.keyStoreType = keyStoreType;</b>
&nbsp;		}
&nbsp;
&nbsp;		public String getTrustStoreCertificates() {
<b class="nc">&nbsp;			return this.trustStoreCertificates;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setTrustStoreCertificates(String trustStoreCertificates) {
<b class="nc">&nbsp;			this.trustStoreCertificates = trustStoreCertificates;</b>
&nbsp;		}
&nbsp;
&nbsp;		public Resource getTrustStoreLocation() {
<b class="nc">&nbsp;			return this.trustStoreLocation;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setTrustStoreLocation(Resource trustStoreLocation) {
<b class="nc">&nbsp;			this.trustStoreLocation = trustStoreLocation;</b>
&nbsp;		}
&nbsp;
&nbsp;		public String getTrustStorePassword() {
<b class="nc">&nbsp;			return this.trustStorePassword;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setTrustStorePassword(String trustStorePassword) {
<b class="nc">&nbsp;			this.trustStorePassword = trustStorePassword;</b>
&nbsp;		}
&nbsp;
&nbsp;		public String getTrustStoreType() {
<b class="nc">&nbsp;			return this.trustStoreType;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setTrustStoreType(String trustStoreType) {
<b class="nc">&nbsp;			this.trustStoreType = trustStoreType;</b>
&nbsp;		}
&nbsp;
&nbsp;		public String getProtocol() {
<b class="nc">&nbsp;			return this.protocol;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setProtocol(String protocol) {
<b class="nc">&nbsp;			this.protocol = protocol;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Deprecated(since = &quot;3.2.0&quot;, forRemoval = true)
&nbsp;		public Map&lt;String, Object&gt; buildProperties() {
<b class="nc">&nbsp;			return buildProperties(null);</b>
&nbsp;		}
&nbsp;
&nbsp;		public Map&lt;String, Object&gt; buildProperties(SslBundles sslBundles) {
<b class="nc">&nbsp;			validate();</b>
<b class="nc">&nbsp;			Properties properties = new Properties();</b>
<b class="nc">&nbsp;			if (getBundle() != null) {</b>
<b class="nc">&nbsp;				properties.in(SslConfigs.SSL_ENGINE_FACTORY_CLASS_CONFIG)</b>
<b class="nc">&nbsp;					.accept(SslBundleSslEngineFactory.class.getName());</b>
<b class="nc">&nbsp;				properties.in(SslBundle.class.getName()).accept(sslBundles.getBundle(getBundle()));</b>
&nbsp;			}
&nbsp;			else {
<b class="nc">&nbsp;				PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();</b>
<b class="nc">&nbsp;				map.from(this::getKeyPassword).to(properties.in(SslConfigs.SSL_KEY_PASSWORD_CONFIG));</b>
<b class="nc">&nbsp;				map.from(this::getKeyStoreCertificateChain)</b>
<b class="nc">&nbsp;					.to(properties.in(SslConfigs.SSL_KEYSTORE_CERTIFICATE_CHAIN_CONFIG));</b>
<b class="nc">&nbsp;				map.from(this::getKeyStoreKey).to(properties.in(SslConfigs.SSL_KEYSTORE_KEY_CONFIG));</b>
<b class="nc">&nbsp;				map.from(this::getKeyStoreLocation)</b>
<b class="nc">&nbsp;					.as(this::resourceToPath)</b>
<b class="nc">&nbsp;					.to(properties.in(SslConfigs.SSL_KEYSTORE_LOCATION_CONFIG));</b>
<b class="nc">&nbsp;				map.from(this::getKeyStorePassword).to(properties.in(SslConfigs.SSL_KEYSTORE_PASSWORD_CONFIG));</b>
<b class="nc">&nbsp;				map.from(this::getKeyStoreType).to(properties.in(SslConfigs.SSL_KEYSTORE_TYPE_CONFIG));</b>
<b class="nc">&nbsp;				map.from(this::getTrustStoreCertificates)</b>
<b class="nc">&nbsp;					.to(properties.in(SslConfigs.SSL_TRUSTSTORE_CERTIFICATES_CONFIG));</b>
<b class="nc">&nbsp;				map.from(this::getTrustStoreLocation)</b>
<b class="nc">&nbsp;					.as(this::resourceToPath)</b>
<b class="nc">&nbsp;					.to(properties.in(SslConfigs.SSL_TRUSTSTORE_LOCATION_CONFIG));</b>
<b class="nc">&nbsp;				map.from(this::getTrustStorePassword).to(properties.in(SslConfigs.SSL_TRUSTSTORE_PASSWORD_CONFIG));</b>
<b class="nc">&nbsp;				map.from(this::getTrustStoreType).to(properties.in(SslConfigs.SSL_TRUSTSTORE_TYPE_CONFIG));</b>
<b class="nc">&nbsp;				map.from(this::getProtocol).to(properties.in(SslConfigs.SSL_PROTOCOL_CONFIG));</b>
&nbsp;			}
<b class="nc">&nbsp;			return properties;</b>
&nbsp;		}
&nbsp;
&nbsp;		private void validate() {
<b class="nc">&nbsp;			MutuallyExclusiveConfigurationPropertiesException.throwIfMultipleNonNullValuesIn((entries) -&gt; {</b>
<b class="nc">&nbsp;				entries.put(&quot;spring.kafka.ssl.key-store-key&quot;, getKeyStoreKey());</b>
<b class="nc">&nbsp;				entries.put(&quot;spring.kafka.ssl.key-store-location&quot;, getKeyStoreLocation());</b>
&nbsp;			});
<b class="nc">&nbsp;			MutuallyExclusiveConfigurationPropertiesException.throwIfMultipleNonNullValuesIn((entries) -&gt; {</b>
<b class="nc">&nbsp;				entries.put(&quot;spring.kafka.ssl.trust-store-certificates&quot;, getTrustStoreCertificates());</b>
<b class="nc">&nbsp;				entries.put(&quot;spring.kafka.ssl.trust-store-location&quot;, getTrustStoreLocation());</b>
&nbsp;			});
<b class="nc">&nbsp;			MutuallyExclusiveConfigurationPropertiesException.throwIfMultipleNonNullValuesIn((entries) -&gt; {</b>
<b class="nc">&nbsp;				entries.put(&quot;spring.kafka.ssl.bundle&quot;, getBundle());</b>
<b class="nc">&nbsp;				entries.put(&quot;spring.kafka.ssl.key-store-key&quot;, getKeyStoreKey());</b>
&nbsp;			});
<b class="nc">&nbsp;			MutuallyExclusiveConfigurationPropertiesException.throwIfMultipleNonNullValuesIn((entries) -&gt; {</b>
<b class="nc">&nbsp;				entries.put(&quot;spring.kafka.ssl.bundle&quot;, getBundle());</b>
<b class="nc">&nbsp;				entries.put(&quot;spring.kafka.ssl.key-store-location&quot;, getKeyStoreLocation());</b>
&nbsp;			});
<b class="nc">&nbsp;			MutuallyExclusiveConfigurationPropertiesException.throwIfMultipleNonNullValuesIn((entries) -&gt; {</b>
<b class="nc">&nbsp;				entries.put(&quot;spring.kafka.ssl.bundle&quot;, getBundle());</b>
<b class="nc">&nbsp;				entries.put(&quot;spring.kafka.ssl.trust-store-certificates&quot;, getTrustStoreCertificates());</b>
&nbsp;			});
<b class="nc">&nbsp;			MutuallyExclusiveConfigurationPropertiesException.throwIfMultipleNonNullValuesIn((entries) -&gt; {</b>
<b class="nc">&nbsp;				entries.put(&quot;spring.kafka.ssl.bundle&quot;, getBundle());</b>
<b class="nc">&nbsp;				entries.put(&quot;spring.kafka.ssl.trust-store-location&quot;, getTrustStoreLocation());</b>
&nbsp;			});
&nbsp;		}
&nbsp;
&nbsp;		private String resourceToPath(Resource resource) {
&nbsp;			try {
<b class="nc">&nbsp;				return resource.getFile().getAbsolutePath();</b>
&nbsp;			}
<b class="nc">&nbsp;			catch (IOException ex) {</b>
<b class="nc">&nbsp;				throw new IllegalStateException(&quot;Resource &#39;&quot; + resource + &quot;&#39; must be on a file system&quot;, ex);</b>
&nbsp;			}
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
<b class="nc">&nbsp;	public static class Jaas {</b>
&nbsp;
&nbsp;		/**
&nbsp;		 * Whether to enable JAAS configuration.
&nbsp;		 */
&nbsp;		private boolean enabled;
&nbsp;
&nbsp;		/**
&nbsp;		 * Login module.
&nbsp;		 */
<b class="nc">&nbsp;		private String loginModule = &quot;com.sun.security.auth.module.Krb5LoginModule&quot;;</b>
&nbsp;
&nbsp;		/**
&nbsp;		 * Control flag for login configuration.
&nbsp;		 */
<b class="nc">&nbsp;		private KafkaJaasLoginModuleInitializer.ControlFlag controlFlag = KafkaJaasLoginModuleInitializer.ControlFlag.REQUIRED;</b>
&nbsp;
&nbsp;		/**
&nbsp;		 * Additional JAAS options.
&nbsp;		 */
<b class="nc">&nbsp;		private final Map&lt;String, String&gt; options = new HashMap&lt;&gt;();</b>
&nbsp;
&nbsp;		public boolean isEnabled() {
<b class="nc">&nbsp;			return this.enabled;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setEnabled(boolean enabled) {
<b class="nc">&nbsp;			this.enabled = enabled;</b>
&nbsp;		}
&nbsp;
&nbsp;		public String getLoginModule() {
<b class="nc">&nbsp;			return this.loginModule;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setLoginModule(String loginModule) {
<b class="nc">&nbsp;			this.loginModule = loginModule;</b>
&nbsp;		}
&nbsp;
&nbsp;		public KafkaJaasLoginModuleInitializer.ControlFlag getControlFlag() {
<b class="nc">&nbsp;			return this.controlFlag;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setControlFlag(KafkaJaasLoginModuleInitializer.ControlFlag controlFlag) {
<b class="nc">&nbsp;			this.controlFlag = controlFlag;</b>
&nbsp;		}
&nbsp;
&nbsp;		public Map&lt;String, String&gt; getOptions() {
<b class="nc">&nbsp;			return this.options;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setOptions(Map&lt;String, String&gt; options) {
<b class="nc">&nbsp;			if (options != null) {</b>
<b class="nc">&nbsp;				this.options.putAll(options);</b>
&nbsp;			}
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
<b class="nc">&nbsp;	public static class Security {</b>
&nbsp;
&nbsp;		/**
&nbsp;		 * Security protocol used to communicate with brokers.
&nbsp;		 */
&nbsp;		private String protocol;
&nbsp;
&nbsp;		public String getProtocol() {
<b class="nc">&nbsp;			return this.protocol;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setProtocol(String protocol) {
<b class="nc">&nbsp;			this.protocol = protocol;</b>
&nbsp;		}
&nbsp;
&nbsp;		public Map&lt;String, Object&gt; buildProperties() {
<b class="nc">&nbsp;			Properties properties = new Properties();</b>
<b class="nc">&nbsp;			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();</b>
<b class="nc">&nbsp;			map.from(this::getProtocol).to(properties.in(CommonClientConfigs.SECURITY_PROTOCOL_CONFIG));</b>
<b class="nc">&nbsp;			return properties;</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
<b class="nc">&nbsp;	public static class Retry {</b>
&nbsp;
<b class="nc">&nbsp;		private final Topic topic = new Topic();</b>
&nbsp;
&nbsp;		public Topic getTopic() {
<b class="nc">&nbsp;			return this.topic;</b>
&nbsp;		}
&nbsp;
&nbsp;		/**
&nbsp;		 * Properties for non-blocking, topic-based retries.
&nbsp;		 */
<b class="nc">&nbsp;		public static class Topic {</b>
&nbsp;
&nbsp;			/**
&nbsp;			 * Whether to enable topic-based non-blocking retries.
&nbsp;			 */
&nbsp;			private boolean enabled;
&nbsp;
&nbsp;			/**
&nbsp;			 * Total number of processing attempts made before sending the message to the
&nbsp;			 * DLT.
&nbsp;			 */
<b class="nc">&nbsp;			private int attempts = 3;</b>
&nbsp;
&nbsp;			/**
&nbsp;			 * Canonical backoff period. Used as an initial value in the exponential case,
&nbsp;			 * and as a minimum value in the uniform case.
&nbsp;			 */
<b class="nc">&nbsp;			private Duration delay = Duration.ofSeconds(1);</b>
&nbsp;
&nbsp;			/**
&nbsp;			 * Multiplier to use for generating the next backoff delay.
&nbsp;			 */
<b class="nc">&nbsp;			private double multiplier = 0.0;</b>
&nbsp;
&nbsp;			/**
&nbsp;			 * Maximum wait between retries. If less than the delay then the default of 30
&nbsp;			 * seconds is applied.
&nbsp;			 */
<b class="nc">&nbsp;			private Duration maxDelay = Duration.ZERO;</b>
&nbsp;
&nbsp;			/**
&nbsp;			 * Whether to have the backoff delays.
&nbsp;			 */
<b class="nc">&nbsp;			private boolean randomBackOff = false;</b>
&nbsp;
&nbsp;			public boolean isEnabled() {
<b class="nc">&nbsp;				return this.enabled;</b>
&nbsp;			}
&nbsp;
&nbsp;			public void setEnabled(boolean enabled) {
<b class="nc">&nbsp;				this.enabled = enabled;</b>
&nbsp;			}
&nbsp;
&nbsp;			public int getAttempts() {
<b class="nc">&nbsp;				return this.attempts;</b>
&nbsp;			}
&nbsp;
&nbsp;			public void setAttempts(int attempts) {
<b class="nc">&nbsp;				this.attempts = attempts;</b>
&nbsp;			}
&nbsp;
&nbsp;			public Duration getDelay() {
<b class="nc">&nbsp;				return this.delay;</b>
&nbsp;			}
&nbsp;
&nbsp;			public void setDelay(Duration delay) {
<b class="nc">&nbsp;				this.delay = delay;</b>
&nbsp;			}
&nbsp;
&nbsp;			public double getMultiplier() {
<b class="nc">&nbsp;				return this.multiplier;</b>
&nbsp;			}
&nbsp;
&nbsp;			public void setMultiplier(double multiplier) {
<b class="nc">&nbsp;				this.multiplier = multiplier;</b>
&nbsp;			}
&nbsp;
&nbsp;			public Duration getMaxDelay() {
<b class="nc">&nbsp;				return this.maxDelay;</b>
&nbsp;			}
&nbsp;
&nbsp;			public void setMaxDelay(Duration maxDelay) {
<b class="nc">&nbsp;				this.maxDelay = maxDelay;</b>
&nbsp;			}
&nbsp;
&nbsp;			public boolean isRandomBackOff() {
<b class="nc">&nbsp;				return this.randomBackOff;</b>
&nbsp;			}
&nbsp;
&nbsp;			public void setRandomBackOff(boolean randomBackOff) {
<b class="nc">&nbsp;				this.randomBackOff = randomBackOff;</b>
&nbsp;			}
&nbsp;
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
<b class="nc">&nbsp;	public static class Cleanup {</b>
&nbsp;
&nbsp;		/**
&nbsp;		 * Cleanup the application’s local state directory on startup.
&nbsp;		 */
<b class="nc">&nbsp;		private boolean onStartup = false;</b>
&nbsp;
&nbsp;		/**
&nbsp;		 * Cleanup the application’s local state directory on shutdown.
&nbsp;		 */
<b class="nc">&nbsp;		private boolean onShutdown = false;</b>
&nbsp;
&nbsp;		public boolean isOnStartup() {
<b class="nc">&nbsp;			return this.onStartup;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setOnStartup(boolean onStartup) {
<b class="nc">&nbsp;			this.onStartup = onStartup;</b>
&nbsp;		}
&nbsp;
&nbsp;		public boolean isOnShutdown() {
<b class="nc">&nbsp;			return this.onShutdown;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setOnShutdown(boolean onShutdown) {
<b class="nc">&nbsp;			this.onShutdown = onShutdown;</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
<b class="nc">&nbsp;	public enum IsolationLevel {</b>
&nbsp;
&nbsp;		/**
&nbsp;		 * Read everything including aborted transactions.
&nbsp;		 */
<b class="nc">&nbsp;		READ_UNCOMMITTED((byte) 0),</b>
&nbsp;
&nbsp;		/**
&nbsp;		 * Read records from committed transactions, in addition to records not part of
&nbsp;		 * transactions.
&nbsp;		 */
<b class="nc">&nbsp;		READ_COMMITTED((byte) 1);</b>
&nbsp;
&nbsp;		private final byte id;
&nbsp;
<b class="nc">&nbsp;		IsolationLevel(byte id) {</b>
<b class="nc">&nbsp;			this.id = id;</b>
&nbsp;		}
&nbsp;
&nbsp;		public byte id() {
<b class="nc">&nbsp;			return this.id;</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	@SuppressWarnings(&quot;serial&quot;)
<b class="nc">&nbsp;	private static final class Properties extends HashMap&lt;String, Object&gt; {</b>
&nbsp;
&nbsp;		&lt;V&gt; java.util.function.Consumer&lt;V&gt; in(String key) {
<b class="nc">&nbsp;			return (value) -&gt; put(key, value);</b>
&nbsp;		}
&nbsp;
&nbsp;		Properties with(Ssl ssl, Security security, Map&lt;String, String&gt; properties, SslBundles sslBundles) {
<b class="nc">&nbsp;			putAll(ssl.buildProperties(sslBundles));</b>
<b class="nc">&nbsp;			putAll(security.buildProperties());</b>
<b class="nc">&nbsp;			putAll(properties);</b>
<b class="nc">&nbsp;			return this;</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-04-01 11:12</div>
</div>
</body>
</html>
