


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > BootArchiveSupport</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.springframework.boot.gradle.tasks.bundling</a>
</div>

<h1>Coverage Summary for Class: BootArchiveSupport (org.springframework.boot.gradle.tasks.bundling)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">BootArchiveSupport</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/20)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/76)
  </span>
</td>
</tr>
  <tr>
    <td class="name">BootArchiveSupport$ReproducibleOrderingCopyAction</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/23)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/82)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2012-2023 the original author or authors.
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *      https://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;
&nbsp;package org.springframework.boot.gradle.tasks.bundling;
&nbsp;
&nbsp;import java.io.File;
&nbsp;import java.io.FileInputStream;
&nbsp;import java.io.IOException;
&nbsp;import java.io.InputStream;
&nbsp;import java.util.Collections;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.Map;
&nbsp;import java.util.Set;
&nbsp;import java.util.TreeMap;
&nbsp;import java.util.function.Function;
&nbsp;import java.util.function.Supplier;
&nbsp;
&nbsp;import org.gradle.api.GradleException;
&nbsp;import org.gradle.api.file.CopySpec;
&nbsp;import org.gradle.api.file.FileCopyDetails;
&nbsp;import org.gradle.api.file.FileTreeElement;
&nbsp;import org.gradle.api.file.RelativePath;
&nbsp;import org.gradle.api.internal.file.copy.CopyAction;
&nbsp;import org.gradle.api.internal.file.copy.CopyActionProcessingStream;
&nbsp;import org.gradle.api.internal.file.copy.FileCopyDetailsInternal;
&nbsp;import org.gradle.api.java.archives.Attributes;
&nbsp;import org.gradle.api.java.archives.Manifest;
&nbsp;import org.gradle.api.provider.Property;
&nbsp;import org.gradle.api.specs.Spec;
&nbsp;import org.gradle.api.specs.Specs;
&nbsp;import org.gradle.api.tasks.WorkResult;
&nbsp;import org.gradle.api.tasks.bundling.Jar;
&nbsp;import org.gradle.api.tasks.util.PatternSet;
&nbsp;import org.gradle.util.GradleVersion;
&nbsp;
&nbsp;import org.springframework.boot.loader.tools.LoaderImplementation;
&nbsp;
&nbsp;/**
&nbsp; * Support class for implementations of {@link BootArchive}.
&nbsp; *
&nbsp; * @author Andy Wilkinson
&nbsp; * @author Phillip Webb
&nbsp; * @author Scott Frederick
&nbsp; * @see BootJar
&nbsp; * @see BootWar
&nbsp; */
&nbsp;class BootArchiveSupport {
&nbsp;
<b class="nc">&nbsp;	private static final byte[] ZIP_FILE_HEADER = new byte[] { &#39;P&#39;, &#39;K&#39;, 3, 4 };</b>
&nbsp;
&nbsp;	private static final String UNSPECIFIED_VERSION = &quot;unspecified&quot;;
&nbsp;
&nbsp;	private static final Set&lt;String&gt; DEFAULT_LAUNCHER_CLASSES;
&nbsp;
&nbsp;	static {
<b class="nc">&nbsp;		Set&lt;String&gt; defaultLauncherClasses = new HashSet&lt;&gt;();</b>
<b class="nc">&nbsp;		defaultLauncherClasses.add(&quot;org.springframework.boot.loader.launch.JarLauncher&quot;);</b>
<b class="nc">&nbsp;		defaultLauncherClasses.add(&quot;org.springframework.boot.loader.launch.PropertiesLauncher&quot;);</b>
<b class="nc">&nbsp;		defaultLauncherClasses.add(&quot;org.springframework.boot.loader.launch.WarLauncher&quot;);</b>
<b class="nc">&nbsp;		DEFAULT_LAUNCHER_CLASSES = Collections.unmodifiableSet(defaultLauncherClasses);</b>
&nbsp;	}
&nbsp;
<b class="nc">&nbsp;	private final PatternSet requiresUnpack = new PatternSet();</b>
&nbsp;
<b class="nc">&nbsp;	private final PatternSet exclusions = new PatternSet();</b>
&nbsp;
&nbsp;	private final String loaderMainClass;
&nbsp;
&nbsp;	private final Spec&lt;FileCopyDetails&gt; librarySpec;
&nbsp;
&nbsp;	private final Function&lt;FileCopyDetails, ZipCompression&gt; compressionResolver;
&nbsp;
&nbsp;	private LaunchScriptConfiguration launchScript;
&nbsp;
&nbsp;	BootArchiveSupport(String loaderMainClass, Spec&lt;FileCopyDetails&gt; librarySpec,
<b class="nc">&nbsp;			Function&lt;FileCopyDetails, ZipCompression&gt; compressionResolver) {</b>
<b class="nc">&nbsp;		this.loaderMainClass = loaderMainClass;</b>
<b class="nc">&nbsp;		this.librarySpec = librarySpec;</b>
<b class="nc">&nbsp;		this.compressionResolver = compressionResolver;</b>
<b class="nc">&nbsp;		this.requiresUnpack.include(Specs.satisfyNone());</b>
&nbsp;	}
&nbsp;
&nbsp;	void configureManifest(Manifest manifest, String mainClass, String classes, String lib, String classPathIndex,
&nbsp;			String layersIndex, String jdkVersion, String implementationTitle, Object implementationVersion) {
<b class="nc">&nbsp;		Attributes attributes = manifest.getAttributes();</b>
<b class="nc">&nbsp;		attributes.putIfAbsent(&quot;Main-Class&quot;, this.loaderMainClass);</b>
<b class="nc">&nbsp;		attributes.putIfAbsent(&quot;Start-Class&quot;, mainClass);</b>
<b class="nc">&nbsp;		attributes.computeIfAbsent(&quot;Spring-Boot-Version&quot;, (name) -&gt; determineSpringBootVersion());</b>
<b class="nc">&nbsp;		attributes.putIfAbsent(&quot;Spring-Boot-Classes&quot;, classes);</b>
<b class="nc">&nbsp;		attributes.putIfAbsent(&quot;Spring-Boot-Lib&quot;, lib);</b>
<b class="nc">&nbsp;		if (classPathIndex != null) {</b>
<b class="nc">&nbsp;			attributes.putIfAbsent(&quot;Spring-Boot-Classpath-Index&quot;, classPathIndex);</b>
&nbsp;		}
<b class="nc">&nbsp;		if (layersIndex != null) {</b>
<b class="nc">&nbsp;			attributes.putIfAbsent(&quot;Spring-Boot-Layers-Index&quot;, layersIndex);</b>
&nbsp;		}
<b class="nc">&nbsp;		attributes.putIfAbsent(&quot;Build-Jdk-Spec&quot;, jdkVersion);</b>
<b class="nc">&nbsp;		attributes.putIfAbsent(&quot;Implementation-Title&quot;, implementationTitle);</b>
<b class="nc">&nbsp;		if (implementationVersion != null) {</b>
<b class="nc">&nbsp;			String versionString = implementationVersion.toString();</b>
<b class="nc">&nbsp;			if (!UNSPECIFIED_VERSION.equals(versionString)) {</b>
<b class="nc">&nbsp;				attributes.putIfAbsent(&quot;Implementation-Version&quot;, versionString);</b>
&nbsp;			}
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private String determineSpringBootVersion() {
<b class="nc">&nbsp;		String version = getClass().getPackage().getImplementationVersion();</b>
<b class="nc">&nbsp;		return (version != null) ? version : &quot;unknown&quot;;</b>
&nbsp;	}
&nbsp;
&nbsp;	CopyAction createCopyAction(Jar jar, ResolvedDependencies resolvedDependencies,
&nbsp;			LoaderImplementation loaderImplementation, boolean supportsSignatureFile) {
<b class="nc">&nbsp;		return createCopyAction(jar, resolvedDependencies, loaderImplementation, supportsSignatureFile, null, null);</b>
&nbsp;	}
&nbsp;
&nbsp;	CopyAction createCopyAction(Jar jar, ResolvedDependencies resolvedDependencies,
&nbsp;			LoaderImplementation loaderImplementation, boolean supportsSignatureFile, LayerResolver layerResolver,
&nbsp;			String layerToolsLocation) {
<b class="nc">&nbsp;		File output = jar.getArchiveFile().get().getAsFile();</b>
<b class="nc">&nbsp;		Manifest manifest = jar.getManifest();</b>
<b class="nc">&nbsp;		boolean preserveFileTimestamps = jar.isPreserveFileTimestamps();</b>
<b class="nc">&nbsp;		Integer dirMode = getDirMode(jar);</b>
<b class="nc">&nbsp;		Integer fileMode = getFileMode(jar);</b>
<b class="nc">&nbsp;		boolean includeDefaultLoader = isUsingDefaultLoader(jar);</b>
<b class="nc">&nbsp;		Spec&lt;FileTreeElement&gt; requiresUnpack = this.requiresUnpack.getAsSpec();</b>
<b class="nc">&nbsp;		Spec&lt;FileTreeElement&gt; exclusions = this.exclusions.getAsExcludeSpec();</b>
<b class="nc">&nbsp;		LaunchScriptConfiguration launchScript = this.launchScript;</b>
<b class="nc">&nbsp;		Spec&lt;FileCopyDetails&gt; librarySpec = this.librarySpec;</b>
<b class="nc">&nbsp;		Function&lt;FileCopyDetails, ZipCompression&gt; compressionResolver = this.compressionResolver;</b>
<b class="nc">&nbsp;		String encoding = jar.getMetadataCharset();</b>
<b class="nc">&nbsp;		CopyAction action = new BootZipCopyAction(output, manifest, preserveFileTimestamps, dirMode, fileMode,</b>
&nbsp;				includeDefaultLoader, layerToolsLocation, requiresUnpack, exclusions, launchScript, librarySpec,
&nbsp;				compressionResolver, encoding, resolvedDependencies, supportsSignatureFile, layerResolver,
&nbsp;				loaderImplementation);
<b class="nc">&nbsp;		return jar.isReproducibleFileOrder() ? new ReproducibleOrderingCopyAction(action) : action;</b>
&nbsp;	}
&nbsp;
&nbsp;	private Integer getDirMode(CopySpec copySpec) {
<b class="nc">&nbsp;		return getMode(copySpec, &quot;getDirPermissions&quot;, copySpec::getDirMode);</b>
&nbsp;	}
&nbsp;
&nbsp;	private Integer getFileMode(CopySpec copySpec) {
<b class="nc">&nbsp;		return getMode(copySpec, &quot;getFilePermissions&quot;, copySpec::getFileMode);</b>
&nbsp;	}
&nbsp;
&nbsp;	@SuppressWarnings(&quot;unchecked&quot;)
&nbsp;	private Integer getMode(CopySpec copySpec, String methodName, Supplier&lt;Integer&gt; fallback) {
<b class="nc">&nbsp;		if (GradleVersion.current().compareTo(GradleVersion.version(&quot;8.3&quot;)) &gt;= 0) {</b>
&nbsp;			try {
<b class="nc">&nbsp;				Object filePermissions = ((Property&lt;Object&gt;) copySpec.getClass().getMethod(methodName).invoke(copySpec))</b>
<b class="nc">&nbsp;					.getOrNull();</b>
<b class="nc">&nbsp;				return (filePermissions != null)</b>
<b class="nc">&nbsp;						? (int) filePermissions.getClass().getMethod(&quot;toUnixNumeric&quot;).invoke(filePermissions) : null;</b>
&nbsp;			}
<b class="nc">&nbsp;			catch (Exception ex) {</b>
<b class="nc">&nbsp;				throw new GradleException(&quot;Failed to get permissions&quot;, ex);</b>
&nbsp;			}
&nbsp;		}
<b class="nc">&nbsp;		return fallback.get();</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean isUsingDefaultLoader(Jar jar) {
<b class="nc">&nbsp;		return DEFAULT_LAUNCHER_CLASSES.contains(jar.getManifest().getAttributes().get(&quot;Main-Class&quot;));</b>
&nbsp;	}
&nbsp;
&nbsp;	LaunchScriptConfiguration getLaunchScript() {
<b class="nc">&nbsp;		return this.launchScript;</b>
&nbsp;	}
&nbsp;
&nbsp;	void setLaunchScript(LaunchScriptConfiguration launchScript) {
<b class="nc">&nbsp;		this.launchScript = launchScript;</b>
&nbsp;	}
&nbsp;
&nbsp;	void requiresUnpack(String... patterns) {
<b class="nc">&nbsp;		this.requiresUnpack.include(patterns);</b>
&nbsp;	}
&nbsp;
&nbsp;	void requiresUnpack(Spec&lt;FileTreeElement&gt; spec) {
<b class="nc">&nbsp;		this.requiresUnpack.include(spec);</b>
&nbsp;	}
&nbsp;
&nbsp;	void excludeNonZipLibraryFiles(FileCopyDetails details) {
<b class="nc">&nbsp;		if (this.librarySpec.isSatisfiedBy(details)) {</b>
<b class="nc">&nbsp;			excludeNonZipFiles(details);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	void excludeNonZipFiles(FileCopyDetails details) {
<b class="nc">&nbsp;		if (!isZip(details.getFile())) {</b>
<b class="nc">&nbsp;			details.exclude();</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private boolean isZip(File file) {
&nbsp;		try {
<b class="nc">&nbsp;			try (FileInputStream fileInputStream = new FileInputStream(file)) {</b>
<b class="nc">&nbsp;				return isZip(fileInputStream);</b>
<b class="nc">&nbsp;			}</b>
&nbsp;		}
<b class="nc">&nbsp;		catch (IOException ex) {</b>
<b class="nc">&nbsp;			return false;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private boolean isZip(InputStream inputStream) throws IOException {
<b class="nc">&nbsp;		for (byte headerByte : ZIP_FILE_HEADER) {</b>
<b class="nc">&nbsp;			if (inputStream.read() != headerByte) {</b>
<b class="nc">&nbsp;				return false;</b>
&nbsp;			}
&nbsp;		}
<b class="nc">&nbsp;		return true;</b>
&nbsp;	}
&nbsp;
&nbsp;	void moveModuleInfoToRoot(CopySpec spec) {
<b class="nc">&nbsp;		spec.filesMatching(&quot;module-info.class&quot;, this::moveToRoot);</b>
&nbsp;	}
&nbsp;
&nbsp;	void moveToRoot(FileCopyDetails details) {
<b class="nc">&nbsp;		details.setRelativePath(details.getRelativeSourcePath());</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * {@link CopyAction} variant that sorts entries to ensure reproducible ordering.
&nbsp;	 */
&nbsp;	private static final class ReproducibleOrderingCopyAction implements CopyAction {
&nbsp;
&nbsp;		private final CopyAction delegate;
&nbsp;
<b class="nc">&nbsp;		private ReproducibleOrderingCopyAction(CopyAction delegate) {</b>
<b class="nc">&nbsp;			this.delegate = delegate;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public WorkResult execute(CopyActionProcessingStream stream) {
<b class="nc">&nbsp;			return this.delegate.execute((action) -&gt; {</b>
<b class="nc">&nbsp;				Map&lt;RelativePath, FileCopyDetailsInternal&gt; detailsByPath = new TreeMap&lt;&gt;();</b>
<b class="nc">&nbsp;				stream.process((details) -&gt; detailsByPath.put(details.getRelativePath(), details));</b>
<b class="nc">&nbsp;				detailsByPath.values().forEach(action::processFile);</b>
&nbsp;			});
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-04-01 11:12</div>
</div>
</body>
</html>
