


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > BootWar</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.springframework.boot.gradle.tasks.bundling</a>
</div>

<h1>Coverage Summary for Class: BootWar (org.springframework.boot.gradle.tasks.bundling)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">BootWar</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/23)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/47)
  </span>
</td>
</tr>
  <tr>
    <td class="name">BootWar$LibrarySpec</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BootWar$ZipCompressionResolver</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/27)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/51)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2012-2023 the original author or authors.
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *      https://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;
&nbsp;package org.springframework.boot.gradle.tasks.bundling;
&nbsp;
&nbsp;import java.util.Collections;
&nbsp;import java.util.Set;
&nbsp;import java.util.concurrent.Callable;
&nbsp;import java.util.function.Function;
&nbsp;
&nbsp;import org.gradle.api.Action;
&nbsp;import org.gradle.api.Project;
&nbsp;import org.gradle.api.artifacts.result.ResolvedArtifactResult;
&nbsp;import org.gradle.api.file.CopySpec;
&nbsp;import org.gradle.api.file.FileCollection;
&nbsp;import org.gradle.api.file.FileCopyDetails;
&nbsp;import org.gradle.api.file.FileTreeElement;
&nbsp;import org.gradle.api.internal.file.copy.CopyAction;
&nbsp;import org.gradle.api.provider.Provider;
&nbsp;import org.gradle.api.specs.Spec;
&nbsp;import org.gradle.api.tasks.Classpath;
&nbsp;import org.gradle.api.tasks.Nested;
&nbsp;import org.gradle.api.tasks.Optional;
&nbsp;import org.gradle.api.tasks.bundling.War;
&nbsp;import org.gradle.work.DisableCachingByDefault;
&nbsp;
&nbsp;import org.springframework.boot.loader.tools.LoaderImplementation;
&nbsp;
&nbsp;/**
&nbsp; * A custom {@link War} task that produces a Spring Boot executable war.
&nbsp; *
&nbsp; * @author Andy Wilkinson
&nbsp; * @author Phillip Webb
&nbsp; * @author Scott Frederick
&nbsp; * @since 2.0.0
&nbsp; */
&nbsp;@DisableCachingByDefault(because = &quot;Not worth caching&quot;)
&nbsp;public abstract class BootWar extends War implements BootArchive {
&nbsp;
&nbsp;	private static final String LAUNCHER = &quot;org.springframework.boot.loader.launch.WarLauncher&quot;;
&nbsp;
&nbsp;	private static final String CLASSES_DIRECTORY = &quot;WEB-INF/classes/&quot;;
&nbsp;
&nbsp;	private static final String LIB_PROVIDED_DIRECTORY = &quot;WEB-INF/lib-provided/&quot;;
&nbsp;
&nbsp;	private static final String LIB_DIRECTORY = &quot;WEB-INF/lib/&quot;;
&nbsp;
&nbsp;	private static final String LAYERS_INDEX = &quot;WEB-INF/layers.idx&quot;;
&nbsp;
&nbsp;	private static final String CLASSPATH_INDEX = &quot;WEB-INF/classpath.idx&quot;;
&nbsp;
&nbsp;	private final BootArchiveSupport support;
&nbsp;
&nbsp;	private final LayeredSpec layered;
&nbsp;
&nbsp;	private final Provider&lt;String&gt; projectName;
&nbsp;
&nbsp;	private final Provider&lt;Object&gt; projectVersion;
&nbsp;
&nbsp;	private final ResolvedDependencies resolvedDependencies;
&nbsp;
&nbsp;	private FileCollection providedClasspath;
&nbsp;
&nbsp;	/**
&nbsp;	 * Creates a new {@code BootWar} task.
&nbsp;	 */
<b class="nc">&nbsp;	public BootWar() {</b>
<b class="nc">&nbsp;		this.support = new BootArchiveSupport(LAUNCHER, new LibrarySpec(), new ZipCompressionResolver());</b>
<b class="nc">&nbsp;		Project project = getProject();</b>
<b class="nc">&nbsp;		this.layered = project.getObjects().newInstance(LayeredSpec.class);</b>
<b class="nc">&nbsp;		getWebInf().into(&quot;lib-provided&quot;, fromCallTo(this::getProvidedLibFiles));</b>
<b class="nc">&nbsp;		this.support.moveModuleInfoToRoot(getRootSpec());</b>
<b class="nc">&nbsp;		getRootSpec().eachFile(this.support::excludeNonZipLibraryFiles);</b>
<b class="nc">&nbsp;		this.projectName = project.provider(project::getName);</b>
<b class="nc">&nbsp;		this.projectVersion = project.provider(project::getVersion);</b>
<b class="nc">&nbsp;		this.resolvedDependencies = new ResolvedDependencies(project);</b>
&nbsp;	}
&nbsp;
&nbsp;	private Object getProvidedLibFiles() {
<b class="nc">&nbsp;		return (this.providedClasspath != null) ? this.providedClasspath : Collections.emptyList();</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void resolvedArtifacts(Provider&lt;Set&lt;ResolvedArtifactResult&gt;&gt; resolvedArtifacts) {
<b class="nc">&nbsp;		this.resolvedDependencies.resolvedArtifacts(resolvedArtifacts);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Nested
&nbsp;	ResolvedDependencies getResolvedDependencies() {
<b class="nc">&nbsp;		return this.resolvedDependencies;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void copy() {
<b class="nc">&nbsp;		this.support.configureManifest(getManifest(), getMainClass().get(), CLASSES_DIRECTORY, LIB_DIRECTORY,</b>
<b class="nc">&nbsp;				CLASSPATH_INDEX, (isLayeredDisabled()) ? null : LAYERS_INDEX,</b>
<b class="nc">&nbsp;				this.getTargetJavaVersion().get().getMajorVersion(), this.projectName.get(), this.projectVersion.get());</b>
<b class="nc">&nbsp;		super.copy();</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean isLayeredDisabled() {
<b class="nc">&nbsp;		return !this.layered.getEnabled().get();</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	protected CopyAction createCopyAction() {
<b class="nc">&nbsp;		LoaderImplementation loaderImplementation = getLoaderImplementation().getOrElse(LoaderImplementation.DEFAULT);</b>
<b class="nc">&nbsp;		if (!isLayeredDisabled()) {</b>
<b class="nc">&nbsp;			LayerResolver layerResolver = new LayerResolver(this.resolvedDependencies, this.layered, this::isLibrary);</b>
<b class="nc">&nbsp;			String layerToolsLocation = this.layered.getIncludeLayerTools().get() ? LIB_DIRECTORY : null;</b>
<b class="nc">&nbsp;			return this.support.createCopyAction(this, this.resolvedDependencies, loaderImplementation, false,</b>
&nbsp;					layerResolver, layerToolsLocation);
&nbsp;		}
<b class="nc">&nbsp;		return this.support.createCopyAction(this, this.resolvedDependencies, loaderImplementation, false);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void requiresUnpack(String... patterns) {
<b class="nc">&nbsp;		this.support.requiresUnpack(patterns);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void requiresUnpack(Spec&lt;FileTreeElement&gt; spec) {
<b class="nc">&nbsp;		this.support.requiresUnpack(spec);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public LaunchScriptConfiguration getLaunchScript() {
<b class="nc">&nbsp;		return this.support.getLaunchScript();</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void launchScript() {
<b class="nc">&nbsp;		enableLaunchScriptIfNecessary();</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void launchScript(Action&lt;LaunchScriptConfiguration&gt; action) {
<b class="nc">&nbsp;		action.execute(enableLaunchScriptIfNecessary());</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns the provided classpath, the contents of which will be included in the
&nbsp;	 * {@code WEB-INF/lib-provided} directory of the war.
&nbsp;	 * @return the provided classpath
&nbsp;	 */
&nbsp;	@Optional
&nbsp;	@Classpath
&nbsp;	public FileCollection getProvidedClasspath() {
<b class="nc">&nbsp;		return this.providedClasspath;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Adds files to the provided classpath to include in the {@code WEB-INF/lib-provided}
&nbsp;	 * directory of the war. The given {@code classpath} is evaluated as per
&nbsp;	 * {@link Project#files(Object...)}.
&nbsp;	 * @param classpath the additions to the classpath
&nbsp;	 */
&nbsp;	public void providedClasspath(Object... classpath) {
<b class="nc">&nbsp;		FileCollection existingClasspath = this.providedClasspath;</b>
<b class="nc">&nbsp;		this.providedClasspath = getProject()</b>
<b class="nc">&nbsp;			.files((existingClasspath != null) ? existingClasspath : Collections.emptyList(), classpath);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Sets the provided classpath to include in the {@code WEB-INF/lib-provided}
&nbsp;	 * directory of the war.
&nbsp;	 * @param classpath the classpath
&nbsp;	 * @since 2.0.7
&nbsp;	 */
&nbsp;	public void setProvidedClasspath(FileCollection classpath) {
<b class="nc">&nbsp;		this.providedClasspath = getProject().files(classpath);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Sets the provided classpath to include in the {@code WEB-INF/lib-provided}
&nbsp;	 * directory of the war. The given {@code classpath} is evaluated as per
&nbsp;	 * {@link Project#files(Object...)}.
&nbsp;	 * @param classpath the classpath
&nbsp;	 * @since 2.0.7
&nbsp;	 */
&nbsp;	public void setProvidedClasspath(Object classpath) {
<b class="nc">&nbsp;		this.providedClasspath = getProject().files(classpath);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Return the {@link ZipCompression} that should be used when adding the file
&nbsp;	 * represented by the given {@code details} to the jar. By default, any
&nbsp;	 * {@link #isLibrary(FileCopyDetails) library} is {@link ZipCompression#STORED stored}
&nbsp;	 * and all other files are {@link ZipCompression#DEFLATED deflated}.
&nbsp;	 * @param details the file copy details
&nbsp;	 * @return the compression to use
&nbsp;	 */
&nbsp;	protected ZipCompression resolveZipCompression(FileCopyDetails details) {
<b class="nc">&nbsp;		return isLibrary(details) ? ZipCompression.STORED : ZipCompression.DEFLATED;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns the spec that describes the layers in a layered jar.
&nbsp;	 * @return the spec for the layers
&nbsp;	 * @since 2.5.0
&nbsp;	 */
&nbsp;	@Nested
&nbsp;	public LayeredSpec getLayered() {
<b class="nc">&nbsp;		return this.layered;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Configures the war&#39;s layering using the given {@code action}.
&nbsp;	 * @param action the action to apply
&nbsp;	 * @since 2.5.0
&nbsp;	 */
&nbsp;	public void layered(Action&lt;LayeredSpec&gt; action) {
<b class="nc">&nbsp;		action.execute(this.layered);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Return if the {@link FileCopyDetails} are for a library. By default any file in
&nbsp;	 * {@code WEB-INF/lib} or {@code WEB-INF/lib-provided} is considered to be a library.
&nbsp;	 * @param details the file copy details
&nbsp;	 * @return {@code true} if the details are for a library
&nbsp;	 */
&nbsp;	protected boolean isLibrary(FileCopyDetails details) {
<b class="nc">&nbsp;		String path = details.getRelativePath().getPathString();</b>
<b class="nc">&nbsp;		return path.startsWith(LIB_DIRECTORY) || path.startsWith(LIB_PROVIDED_DIRECTORY);</b>
&nbsp;	}
&nbsp;
&nbsp;	private LaunchScriptConfiguration enableLaunchScriptIfNecessary() {
<b class="nc">&nbsp;		LaunchScriptConfiguration launchScript = this.support.getLaunchScript();</b>
<b class="nc">&nbsp;		if (launchScript == null) {</b>
<b class="nc">&nbsp;			launchScript = new LaunchScriptConfiguration(this);</b>
<b class="nc">&nbsp;			this.support.setLaunchScript(launchScript);</b>
&nbsp;		}
<b class="nc">&nbsp;		return launchScript;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Syntactic sugar that makes {@link CopySpec#into} calls a little easier to read.
&nbsp;	 * @param &lt;T&gt; the result type
&nbsp;	 * @param callable the callable
&nbsp;	 * @return an action to add the callable to the spec
&nbsp;	 */
&nbsp;	private static &lt;T&gt; Action&lt;CopySpec&gt; fromCallTo(Callable&lt;T&gt; callable) {
<b class="nc">&nbsp;		return (spec) -&gt; spec.from(callTo(callable));</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Syntactic sugar that makes {@link CopySpec#from} calls a little easier to read.
&nbsp;	 * @param &lt;T&gt; the result type
&nbsp;	 * @param callable the callable
&nbsp;	 * @return the callable
&nbsp;	 */
&nbsp;	private static &lt;T&gt; Callable&lt;T&gt; callTo(Callable&lt;T&gt; callable) {
<b class="nc">&nbsp;		return callable;</b>
&nbsp;	}
&nbsp;
<b class="nc">&nbsp;	private final class LibrarySpec implements Spec&lt;FileCopyDetails&gt; {</b>
&nbsp;
&nbsp;		@Override
&nbsp;		public boolean isSatisfiedBy(FileCopyDetails details) {
<b class="nc">&nbsp;			return isLibrary(details);</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
<b class="nc">&nbsp;	private final class ZipCompressionResolver implements Function&lt;FileCopyDetails, ZipCompression&gt; {</b>
&nbsp;
&nbsp;		@Override
&nbsp;		public ZipCompression apply(FileCopyDetails details) {
<b class="nc">&nbsp;			return resolveZipCompression(details);</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-04-01 11:12</div>
</div>
</body>
</html>
