


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > AbstractWebFluxEndpointHandlerMapping</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.springframework.boot.actuate.endpoint.web.reactive</a>
</div>

<h1>Coverage Summary for Class: AbstractWebFluxEndpointHandlerMapping (org.springframework.boot.actuate.endpoint.web.reactive)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">AbstractWebFluxEndpointHandlerMapping</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/13)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/56)
  </span>
</td>
</tr>
  <tr>
    <td class="name">AbstractWebFluxEndpointHandlerMapping$AbstractWebFluxEndpointHandlerMappingRuntimeHints</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractWebFluxEndpointHandlerMapping$ElasticSchedulerInvoker</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractWebFluxEndpointHandlerMapping$ExceptionCapturingInvoker</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractWebFluxEndpointHandlerMapping$LinksHandler</td>
  </tr>
  <tr>
    <td class="name">AbstractWebFluxEndpointHandlerMapping$ReactiveSecurityContext</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractWebFluxEndpointHandlerMapping$ReactiveWebOperation</td>
  </tr>
  <tr>
    <td class="name">AbstractWebFluxEndpointHandlerMapping$ReactiveWebOperationAdapter</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/17)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/65)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractWebFluxEndpointHandlerMapping$ReadOperationHandler</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractWebFluxEndpointHandlerMapping$WebFluxEndpointHandlerMethod</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractWebFluxEndpointHandlerMapping$WriteOperationHandler</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/49)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/152)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2012-2024 the original author or authors.
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *      https://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;
&nbsp;package org.springframework.boot.actuate.endpoint.web.reactive;
&nbsp;
&nbsp;import java.lang.reflect.Method;
&nbsp;import java.nio.charset.StandardCharsets;
&nbsp;import java.security.Principal;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Collection;
&nbsp;import java.util.LinkedHashMap;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.function.Supplier;
&nbsp;
&nbsp;import org.reactivestreams.Publisher;
&nbsp;import reactor.core.publisher.Flux;
&nbsp;import reactor.core.publisher.Mono;
&nbsp;import reactor.core.scheduler.Schedulers;
&nbsp;
&nbsp;import org.springframework.aot.hint.RuntimeHints;
&nbsp;import org.springframework.aot.hint.RuntimeHintsRegistrar;
&nbsp;import org.springframework.aot.hint.annotation.Reflective;
&nbsp;import org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrar;
&nbsp;import org.springframework.boot.actuate.endpoint.InvalidEndpointRequestException;
&nbsp;import org.springframework.boot.actuate.endpoint.InvocationContext;
&nbsp;import org.springframework.boot.actuate.endpoint.OperationArgumentResolver;
&nbsp;import org.springframework.boot.actuate.endpoint.OperationType;
&nbsp;import org.springframework.boot.actuate.endpoint.ProducibleOperationArgumentResolver;
&nbsp;import org.springframework.boot.actuate.endpoint.SecurityContext;
&nbsp;import org.springframework.boot.actuate.endpoint.invoke.OperationInvoker;
&nbsp;import org.springframework.boot.actuate.endpoint.web.EndpointMapping;
&nbsp;import org.springframework.boot.actuate.endpoint.web.EndpointMediaTypes;
&nbsp;import org.springframework.boot.actuate.endpoint.web.ExposableWebEndpoint;
&nbsp;import org.springframework.boot.actuate.endpoint.web.WebEndpointResponse;
&nbsp;import org.springframework.boot.actuate.endpoint.web.WebOperation;
&nbsp;import org.springframework.boot.actuate.endpoint.web.WebOperationRequestPredicate;
&nbsp;import org.springframework.boot.actuate.endpoint.web.WebServerNamespace;
&nbsp;import org.springframework.boot.actuate.endpoint.web.reactive.AbstractWebFluxEndpointHandlerMapping.AbstractWebFluxEndpointHandlerMappingRuntimeHints;
&nbsp;import org.springframework.boot.web.context.WebServerApplicationContext;
&nbsp;import org.springframework.context.annotation.ImportRuntimeHints;
&nbsp;import org.springframework.http.HttpMethod;
&nbsp;import org.springframework.http.HttpStatus;
&nbsp;import org.springframework.http.MediaType;
&nbsp;import org.springframework.http.ResponseEntity;
&nbsp;import org.springframework.security.authorization.AuthorityAuthorizationManager;
&nbsp;import org.springframework.security.core.Authentication;
&nbsp;import org.springframework.security.core.context.ReactiveSecurityContextHolder;
&nbsp;import org.springframework.util.AntPathMatcher;
&nbsp;import org.springframework.util.ClassUtils;
&nbsp;import org.springframework.util.ReflectionUtils;
&nbsp;import org.springframework.util.StringUtils;
&nbsp;import org.springframework.web.bind.annotation.RequestBody;
&nbsp;import org.springframework.web.bind.annotation.RequestMethod;
&nbsp;import org.springframework.web.bind.annotation.ResponseBody;
&nbsp;import org.springframework.web.cors.CorsConfiguration;
&nbsp;import org.springframework.web.method.HandlerMethod;
&nbsp;import org.springframework.web.reactive.HandlerMapping;
&nbsp;import org.springframework.web.reactive.result.method.RequestMappingInfo;
&nbsp;import org.springframework.web.reactive.result.method.RequestMappingInfoHandlerMapping;
&nbsp;import org.springframework.web.server.ResponseStatusException;
&nbsp;import org.springframework.web.server.ServerWebExchange;
&nbsp;import org.springframework.web.util.pattern.PathPattern;
&nbsp;
&nbsp;/**
&nbsp; * A custom {@link HandlerMapping} that makes web endpoints available over HTTP using
&nbsp; * Spring WebFlux.
&nbsp; *
&nbsp; * @author Andy Wilkinson
&nbsp; * @author Madhura Bhave
&nbsp; * @author Phillip Webb
&nbsp; * @author Brian Clozel
&nbsp; * @author Scott Frederick
&nbsp; * @since 2.0.0
&nbsp; */
&nbsp;@ImportRuntimeHints(AbstractWebFluxEndpointHandlerMappingRuntimeHints.class)
&nbsp;public abstract class AbstractWebFluxEndpointHandlerMapping extends RequestMappingInfoHandlerMapping {
&nbsp;
&nbsp;	private final EndpointMapping endpointMapping;
&nbsp;
&nbsp;	private final Collection&lt;ExposableWebEndpoint&gt; endpoints;
&nbsp;
&nbsp;	private final EndpointMediaTypes endpointMediaTypes;
&nbsp;
&nbsp;	private final CorsConfiguration corsConfiguration;
&nbsp;
<b class="nc">&nbsp;	private final Method handleWriteMethod = ReflectionUtils.findMethod(WriteOperationHandler.class, &quot;handle&quot;,</b>
&nbsp;			ServerWebExchange.class, Map.class);
&nbsp;
<b class="nc">&nbsp;	private final Method handleReadMethod = ReflectionUtils.findMethod(ReadOperationHandler.class, &quot;handle&quot;,</b>
&nbsp;			ServerWebExchange.class);
&nbsp;
&nbsp;	private final boolean shouldRegisterLinksMapping;
&nbsp;
&nbsp;	/**
&nbsp;	 * Creates a new {@code AbstractWebFluxEndpointHandlerMapping} that provides mappings
&nbsp;	 * for the operations of the given {@code webEndpoints}.
&nbsp;	 * @param endpointMapping the base mapping for all endpoints
&nbsp;	 * @param endpoints the web endpoints
&nbsp;	 * @param endpointMediaTypes media types consumed and produced by the endpoints
&nbsp;	 * @param corsConfiguration the CORS configuration for the endpoints
&nbsp;	 * @param shouldRegisterLinksMapping whether the links endpoint should be registered
&nbsp;	 */
&nbsp;	public AbstractWebFluxEndpointHandlerMapping(EndpointMapping endpointMapping,
&nbsp;			Collection&lt;ExposableWebEndpoint&gt; endpoints, EndpointMediaTypes endpointMediaTypes,
<b class="nc">&nbsp;			CorsConfiguration corsConfiguration, boolean shouldRegisterLinksMapping) {</b>
<b class="nc">&nbsp;		this.endpointMapping = endpointMapping;</b>
<b class="nc">&nbsp;		this.endpoints = endpoints;</b>
<b class="nc">&nbsp;		this.endpointMediaTypes = endpointMediaTypes;</b>
<b class="nc">&nbsp;		this.corsConfiguration = corsConfiguration;</b>
<b class="nc">&nbsp;		this.shouldRegisterLinksMapping = shouldRegisterLinksMapping;</b>
<b class="nc">&nbsp;		setOrder(-100);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	protected void initHandlerMethods() {
<b class="nc">&nbsp;		for (ExposableWebEndpoint endpoint : this.endpoints) {</b>
<b class="nc">&nbsp;			for (WebOperation operation : endpoint.getOperations()) {</b>
<b class="nc">&nbsp;				registerMappingForOperation(endpoint, operation);</b>
<b class="nc">&nbsp;			}</b>
<b class="nc">&nbsp;		}</b>
<b class="nc">&nbsp;		if (this.shouldRegisterLinksMapping) {</b>
<b class="nc">&nbsp;			registerLinksMapping();</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	protected HandlerMethod createHandlerMethod(Object handler, Method method) {
<b class="nc">&nbsp;		HandlerMethod handlerMethod = super.createHandlerMethod(handler, method);</b>
<b class="nc">&nbsp;		return new WebFluxEndpointHandlerMethod(handlerMethod.getBean(), handlerMethod.getMethod());</b>
&nbsp;	}
&nbsp;
&nbsp;	private void registerMappingForOperation(ExposableWebEndpoint endpoint, WebOperation operation) {
<b class="nc">&nbsp;		RequestMappingInfo requestMappingInfo = createRequestMappingInfo(operation);</b>
<b class="nc">&nbsp;		if (operation.getType() == OperationType.WRITE) {</b>
<b class="nc">&nbsp;			ReactiveWebOperation reactiveWebOperation = wrapReactiveWebOperation(endpoint, operation,</b>
&nbsp;					new ReactiveWebOperationAdapter(operation));
<b class="nc">&nbsp;			registerMapping(requestMappingInfo, new WriteOperationHandler((reactiveWebOperation)),</b>
&nbsp;					this.handleWriteMethod);
<b class="nc">&nbsp;		}</b>
&nbsp;		else {
<b class="nc">&nbsp;			registerReadMapping(requestMappingInfo, endpoint, operation);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	protected void registerReadMapping(RequestMappingInfo requestMappingInfo, ExposableWebEndpoint endpoint,
&nbsp;			WebOperation operation) {
<b class="nc">&nbsp;		ReactiveWebOperation reactiveWebOperation = wrapReactiveWebOperation(endpoint, operation,</b>
&nbsp;				new ReactiveWebOperationAdapter(operation));
<b class="nc">&nbsp;		registerMapping(requestMappingInfo, new ReadOperationHandler((reactiveWebOperation)), this.handleReadMethod);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Hook point that allows subclasses to wrap the {@link ReactiveWebOperation} before
&nbsp;	 * it&#39;s called. Allows additional features, such as security, to be added.
&nbsp;	 * @param endpoint the source endpoint
&nbsp;	 * @param operation the source operation
&nbsp;	 * @param reactiveWebOperation the reactive web operation to wrap
&nbsp;	 * @return a wrapped reactive web operation
&nbsp;	 */
&nbsp;	protected ReactiveWebOperation wrapReactiveWebOperation(ExposableWebEndpoint endpoint, WebOperation operation,
&nbsp;			ReactiveWebOperation reactiveWebOperation) {
<b class="nc">&nbsp;		return reactiveWebOperation;</b>
&nbsp;	}
&nbsp;
&nbsp;	private RequestMappingInfo createRequestMappingInfo(WebOperation operation) {
<b class="nc">&nbsp;		WebOperationRequestPredicate predicate = operation.getRequestPredicate();</b>
<b class="nc">&nbsp;		String path = this.endpointMapping.createSubPath(predicate.getPath());</b>
<b class="nc">&nbsp;		List&lt;String&gt; paths = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;		paths.add(path);</b>
<b class="nc">&nbsp;		if (!StringUtils.hasText(path)) {</b>
<b class="nc">&nbsp;			paths.add(&quot;/&quot;);</b>
&nbsp;		}
<b class="nc">&nbsp;		RequestMethod method = RequestMethod.valueOf(predicate.getHttpMethod().name());</b>
<b class="nc">&nbsp;		String[] consumes = StringUtils.toStringArray(predicate.getConsumes());</b>
<b class="nc">&nbsp;		String[] produces = StringUtils.toStringArray(predicate.getProduces());</b>
<b class="nc">&nbsp;		return RequestMappingInfo.paths(paths.toArray(new String[0]))</b>
<b class="nc">&nbsp;			.methods(method)</b>
<b class="nc">&nbsp;			.consumes(consumes)</b>
<b class="nc">&nbsp;			.produces(produces)</b>
<b class="nc">&nbsp;			.build();</b>
&nbsp;	}
&nbsp;
&nbsp;	private void registerLinksMapping() {
<b class="nc">&nbsp;		String path = this.endpointMapping.getPath();</b>
<b class="nc">&nbsp;		String linksPath = StringUtils.hasLength(path) ? path : &quot;/&quot;;</b>
<b class="nc">&nbsp;		String[] produces = StringUtils.toStringArray(this.endpointMediaTypes.getProduced());</b>
<b class="nc">&nbsp;		RequestMappingInfo mapping = RequestMappingInfo.paths(linksPath)</b>
<b class="nc">&nbsp;			.methods(RequestMethod.GET)</b>
<b class="nc">&nbsp;			.produces(produces)</b>
<b class="nc">&nbsp;			.build();</b>
<b class="nc">&nbsp;		LinksHandler linksHandler = getLinksHandler();</b>
<b class="nc">&nbsp;		registerMapping(mapping, linksHandler,</b>
<b class="nc">&nbsp;				ReflectionUtils.findMethod(linksHandler.getClass(), &quot;links&quot;, ServerWebExchange.class));</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	protected boolean hasCorsConfigurationSource(Object handler) {
<b class="nc">&nbsp;		return this.corsConfiguration != null;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	protected CorsConfiguration initCorsConfiguration(Object handler, Method method, RequestMappingInfo mapping) {
<b class="nc">&nbsp;		return this.corsConfiguration;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	protected boolean isHandler(Class&lt;?&gt; beanType) {
<b class="nc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	protected RequestMappingInfo getMappingForMethod(Method method, Class&lt;?&gt; handlerType) {
<b class="nc">&nbsp;		return null;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Return the Handler providing actuator links at the root endpoint.
&nbsp;	 * @return the links handler
&nbsp;	 */
&nbsp;	protected abstract LinksHandler getLinksHandler();
&nbsp;
&nbsp;	/**
&nbsp;	 * Return the web endpoints being mapped.
&nbsp;	 * @return the endpoints
&nbsp;	 */
&nbsp;	public Collection&lt;ExposableWebEndpoint&gt; getEndpoints() {
<b class="nc">&nbsp;		return this.endpoints;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * An {@link OperationInvoker} that performs the invocation of a blocking operation on
&nbsp;	 * a separate thread using Reactor&#39;s {@link Schedulers#boundedElastic() bounded
&nbsp;	 * elastic scheduler}.
&nbsp;	 */
&nbsp;	protected static final class ElasticSchedulerInvoker implements OperationInvoker {
&nbsp;
&nbsp;		private final OperationInvoker invoker;
&nbsp;
<b class="nc">&nbsp;		public ElasticSchedulerInvoker(OperationInvoker invoker) {</b>
<b class="nc">&nbsp;			this.invoker = invoker;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Object invoke(InvocationContext context) {
<b class="nc">&nbsp;			return Mono.fromCallable(() -&gt; this.invoker.invoke(context)).subscribeOn(Schedulers.boundedElastic());</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	protected static final class ExceptionCapturingInvoker implements OperationInvoker {
&nbsp;
&nbsp;		private final OperationInvoker invoker;
&nbsp;
<b class="nc">&nbsp;		public ExceptionCapturingInvoker(OperationInvoker invoker) {</b>
<b class="nc">&nbsp;			this.invoker = invoker;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Object invoke(InvocationContext context) {
&nbsp;			try {
<b class="nc">&nbsp;				return this.invoker.invoke(context);</b>
&nbsp;			}
<b class="nc">&nbsp;			catch (Exception ex) {</b>
<b class="nc">&nbsp;				return Mono.error(ex);</b>
&nbsp;			}
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Reactive handler providing actuator links at the root endpoint.
&nbsp;	 */
&nbsp;	@FunctionalInterface
&nbsp;	protected interface LinksHandler {
&nbsp;
&nbsp;		Object links(ServerWebExchange exchange);
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * A reactive web operation that can be handled by WebFlux.
&nbsp;	 */
&nbsp;	@FunctionalInterface
&nbsp;	protected interface ReactiveWebOperation {
&nbsp;
&nbsp;		Mono&lt;ResponseEntity&lt;Object&gt;&gt; handle(ServerWebExchange exchange, Map&lt;String, String&gt; body);
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Adapter class to convert an {@link OperationInvoker} into a
&nbsp;	 * {@link ReactiveWebOperation}.
&nbsp;	 */
&nbsp;	private static final class ReactiveWebOperationAdapter implements ReactiveWebOperation {
&nbsp;
&nbsp;		private static final String PATH_SEPARATOR = AntPathMatcher.DEFAULT_PATH_SEPARATOR;
&nbsp;
&nbsp;		private final WebOperation operation;
&nbsp;
&nbsp;		private final OperationInvoker invoker;
&nbsp;
&nbsp;		private final Supplier&lt;Mono&lt;? extends SecurityContext&gt;&gt; securityContextSupplier;
&nbsp;
<b class="nc">&nbsp;		private ReactiveWebOperationAdapter(WebOperation operation) {</b>
<b class="nc">&nbsp;			this.operation = operation;</b>
<b class="nc">&nbsp;			this.invoker = getInvoker(operation);</b>
<b class="nc">&nbsp;			this.securityContextSupplier = getSecurityContextSupplier();</b>
&nbsp;		}
&nbsp;
&nbsp;		private OperationInvoker getInvoker(WebOperation operation) {
<b class="nc">&nbsp;			OperationInvoker invoker = operation::invoke;</b>
<b class="nc">&nbsp;			if (operation.isBlocking()) {</b>
<b class="nc">&nbsp;				return new ElasticSchedulerInvoker(invoker);</b>
&nbsp;			}
<b class="nc">&nbsp;			return new ExceptionCapturingInvoker(invoker);</b>
&nbsp;		}
&nbsp;
&nbsp;		private Supplier&lt;Mono&lt;? extends SecurityContext&gt;&gt; getSecurityContextSupplier() {
<b class="nc">&nbsp;			if (ClassUtils.isPresent(&quot;org.springframework.security.core.context.ReactiveSecurityContextHolder&quot;,</b>
<b class="nc">&nbsp;					getClass().getClassLoader())) {</b>
<b class="nc">&nbsp;				return this::springSecurityContext;</b>
&nbsp;			}
<b class="nc">&nbsp;			return this::emptySecurityContext;</b>
&nbsp;		}
&nbsp;
&nbsp;		Mono&lt;? extends SecurityContext&gt; springSecurityContext() {
<b class="nc">&nbsp;			return ReactiveSecurityContextHolder.getContext()</b>
<b class="nc">&nbsp;				.map((securityContext) -&gt; new ReactiveSecurityContext(securityContext.getAuthentication()))</b>
<b class="nc">&nbsp;				.switchIfEmpty(Mono.just(new ReactiveSecurityContext(null)));</b>
&nbsp;		}
&nbsp;
&nbsp;		Mono&lt;SecurityContext&gt; emptySecurityContext() {
<b class="nc">&nbsp;			return Mono.just(SecurityContext.NONE);</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Mono&lt;ResponseEntity&lt;Object&gt;&gt; handle(ServerWebExchange exchange, Map&lt;String, String&gt; body) {
<b class="nc">&nbsp;			Map&lt;String, Object&gt; arguments = getArguments(exchange, body);</b>
<b class="nc">&nbsp;			OperationArgumentResolver serverNamespaceArgumentResolver = OperationArgumentResolver</b>
<b class="nc">&nbsp;				.of(WebServerNamespace.class, () -&gt; WebServerNamespace</b>
<b class="nc">&nbsp;					.from(WebServerApplicationContext.getServerNamespace(exchange.getApplicationContext())));</b>
<b class="nc">&nbsp;			return this.securityContextSupplier.get()</b>
<b class="nc">&nbsp;				.map((securityContext) -&gt; new InvocationContext(securityContext, arguments,</b>
&nbsp;						serverNamespaceArgumentResolver,
&nbsp;						new ProducibleOperationArgumentResolver(
<b class="nc">&nbsp;								() -&gt; exchange.getRequest().getHeaders().get(&quot;Accept&quot;))))</b>
<b class="nc">&nbsp;				.flatMap((invocationContext) -&gt; handleResult((Publisher&lt;?&gt;) this.invoker.invoke(invocationContext),</b>
<b class="nc">&nbsp;						exchange.getRequest().getMethod()));</b>
&nbsp;		}
&nbsp;
&nbsp;		private Map&lt;String, Object&gt; getArguments(ServerWebExchange exchange, Map&lt;String, String&gt; body) {
<b class="nc">&nbsp;			Map&lt;String, Object&gt; arguments = new LinkedHashMap&lt;&gt;(getTemplateVariables(exchange));</b>
<b class="nc">&nbsp;			String matchAllRemainingPathSegmentsVariable = this.operation.getRequestPredicate()</b>
<b class="nc">&nbsp;				.getMatchAllRemainingPathSegmentsVariable();</b>
<b class="nc">&nbsp;			if (matchAllRemainingPathSegmentsVariable != null) {</b>
<b class="nc">&nbsp;				arguments.put(matchAllRemainingPathSegmentsVariable, getRemainingPathSegments(exchange));</b>
&nbsp;			}
<b class="nc">&nbsp;			if (body != null) {</b>
<b class="nc">&nbsp;				arguments.putAll(body);</b>
&nbsp;			}
<b class="nc">&nbsp;			exchange.getRequest()</b>
<b class="nc">&nbsp;				.getQueryParams()</b>
<b class="nc">&nbsp;				.forEach((name, values) -&gt; arguments.put(name, (values.size() != 1) ? values : values.get(0)));</b>
<b class="nc">&nbsp;			return arguments;</b>
&nbsp;		}
&nbsp;
&nbsp;		private Object getRemainingPathSegments(ServerWebExchange exchange) {
<b class="nc">&nbsp;			PathPattern pathPattern = exchange.getAttribute(HandlerMapping.BEST_MATCHING_PATTERN_ATTRIBUTE);</b>
<b class="nc">&nbsp;			if (pathPattern.hasPatternSyntax()) {</b>
<b class="nc">&nbsp;				String remainingSegments = pathPattern</b>
<b class="nc">&nbsp;					.extractPathWithinPattern(exchange.getRequest().getPath().pathWithinApplication())</b>
<b class="nc">&nbsp;					.value();</b>
<b class="nc">&nbsp;				return tokenizePathSegments(remainingSegments);</b>
&nbsp;			}
<b class="nc">&nbsp;			return tokenizePathSegments(pathPattern.toString());</b>
&nbsp;		}
&nbsp;
&nbsp;		private String[] tokenizePathSegments(String value) {
<b class="nc">&nbsp;			String[] segments = StringUtils.tokenizeToStringArray(value, PATH_SEPARATOR, false, true);</b>
<b class="nc">&nbsp;			for (int i = 0; i &lt; segments.length; i++) {</b>
<b class="nc">&nbsp;				if (segments[i].contains(&quot;%&quot;)) {</b>
<b class="nc">&nbsp;					segments[i] = StringUtils.uriDecode(segments[i], StandardCharsets.UTF_8);</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			return segments;</b>
&nbsp;		}
&nbsp;
&nbsp;		private Map&lt;String, String&gt; getTemplateVariables(ServerWebExchange exchange) {
<b class="nc">&nbsp;			return exchange.getAttribute(HandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE);</b>
&nbsp;		}
&nbsp;
&nbsp;		private Mono&lt;ResponseEntity&lt;Object&gt;&gt; handleResult(Publisher&lt;?&gt; result, HttpMethod httpMethod) {
<b class="nc">&nbsp;			if (result instanceof Flux) {</b>
<b class="nc">&nbsp;				result = ((Flux&lt;?&gt;) result).collectList();</b>
&nbsp;			}
<b class="nc">&nbsp;			return Mono.from(result)</b>
<b class="nc">&nbsp;				.map(this::toResponseEntity)</b>
<b class="nc">&nbsp;				.onErrorMap(InvalidEndpointRequestException.class,</b>
<b class="nc">&nbsp;						(ex) -&gt; new ResponseStatusException(HttpStatus.BAD_REQUEST, ex.getReason()))</b>
<b class="nc">&nbsp;				.defaultIfEmpty(new ResponseEntity&lt;&gt;(</b>
<b class="nc">&nbsp;						(httpMethod != HttpMethod.GET) ? HttpStatus.NO_CONTENT : HttpStatus.NOT_FOUND));</b>
&nbsp;		}
&nbsp;
&nbsp;		private ResponseEntity&lt;Object&gt; toResponseEntity(Object response) {
<b class="nc">&nbsp;			if (!(response instanceof WebEndpointResponse&lt;?&gt; webEndpointResponse)) {</b>
<b class="nc">&nbsp;				return new ResponseEntity&lt;&gt;(response, HttpStatus.OK);</b>
&nbsp;			}
<b class="nc">&nbsp;			MediaType contentType = (webEndpointResponse.getContentType() != null)</b>
<b class="nc">&nbsp;					? new MediaType(webEndpointResponse.getContentType()) : null;</b>
<b class="nc">&nbsp;			return ResponseEntity.status(webEndpointResponse.getStatus())</b>
<b class="nc">&nbsp;				.contentType(contentType)</b>
<b class="nc">&nbsp;				.body(webEndpointResponse.getBody());</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public String toString() {
<b class="nc">&nbsp;			return &quot;Actuator web endpoint &#39;&quot; + this.operation.getId() + &quot;&#39;&quot;;</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Handler for a {@link ReactiveWebOperation}.
&nbsp;	 */
&nbsp;	private static final class WriteOperationHandler {
&nbsp;
&nbsp;		private final ReactiveWebOperation operation;
&nbsp;
<b class="nc">&nbsp;		WriteOperationHandler(ReactiveWebOperation operation) {</b>
<b class="nc">&nbsp;			this.operation = operation;</b>
&nbsp;		}
&nbsp;
&nbsp;		@ResponseBody
&nbsp;		@Reflective
&nbsp;		Publisher&lt;ResponseEntity&lt;Object&gt;&gt; handle(ServerWebExchange exchange,
&nbsp;				@RequestBody(required = false) Map&lt;String, String&gt; body) {
<b class="nc">&nbsp;			return this.operation.handle(exchange, body);</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public String toString() {
<b class="nc">&nbsp;			return this.operation.toString();</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Handler for a {@link ReactiveWebOperation}.
&nbsp;	 */
&nbsp;	private static final class ReadOperationHandler {
&nbsp;
&nbsp;		private final ReactiveWebOperation operation;
&nbsp;
<b class="nc">&nbsp;		ReadOperationHandler(ReactiveWebOperation operation) {</b>
<b class="nc">&nbsp;			this.operation = operation;</b>
&nbsp;		}
&nbsp;
&nbsp;		@ResponseBody
&nbsp;		@Reflective
&nbsp;		Publisher&lt;ResponseEntity&lt;Object&gt;&gt; handle(ServerWebExchange exchange) {
<b class="nc">&nbsp;			return this.operation.handle(exchange, null);</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public String toString() {
<b class="nc">&nbsp;			return this.operation.toString();</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	private static class WebFluxEndpointHandlerMethod extends HandlerMethod {
&nbsp;
&nbsp;		WebFluxEndpointHandlerMethod(Object bean, Method method) {
<b class="nc">&nbsp;			super(bean, method);</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public String toString() {
<b class="nc">&nbsp;			return getBean().toString();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public HandlerMethod createWithResolvedBean() {
<b class="nc">&nbsp;			HandlerMethod handlerMethod = super.createWithResolvedBean();</b>
<b class="nc">&nbsp;			return new WebFluxEndpointHandlerMethod(handlerMethod.getBean(), handlerMethod.getMethod());</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	private static final class ReactiveSecurityContext implements SecurityContext {
&nbsp;
&nbsp;		private static final String ROLE_PREFIX = &quot;ROLE_&quot;;
&nbsp;
&nbsp;		private final Authentication authentication;
&nbsp;
<b class="nc">&nbsp;		ReactiveSecurityContext(Authentication authentication) {</b>
<b class="nc">&nbsp;			this.authentication = authentication;</b>
&nbsp;		}
&nbsp;
&nbsp;		private Authentication getAuthentication() {
<b class="nc">&nbsp;			return this.authentication;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Principal getPrincipal() {
<b class="nc">&nbsp;			return this.authentication;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public boolean isUserInRole(String role) {
<b class="nc">&nbsp;			String authority = (!role.startsWith(ROLE_PREFIX)) ? ROLE_PREFIX + role : role;</b>
<b class="nc">&nbsp;			return AuthorityAuthorizationManager.hasAuthority(authority)</b>
<b class="nc">&nbsp;				.check(this::getAuthentication, null)</b>
<b class="nc">&nbsp;				.isGranted();</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
<b class="nc">&nbsp;	static class AbstractWebFluxEndpointHandlerMappingRuntimeHints implements RuntimeHintsRegistrar {</b>
&nbsp;
<b class="nc">&nbsp;		private final ReflectiveRuntimeHintsRegistrar reflectiveRegistrar = new ReflectiveRuntimeHintsRegistrar();</b>
&nbsp;
&nbsp;		@Override
&nbsp;		public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
<b class="nc">&nbsp;			this.reflectiveRegistrar.registerRuntimeHints(hints, WriteOperationHandler.class,</b>
&nbsp;					ReadOperationHandler.class);
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-04-01 11:12</div>
</div>
</body>
</html>
