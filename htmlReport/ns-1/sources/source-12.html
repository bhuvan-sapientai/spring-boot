


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > SpringApplication</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.springframework.boot</a>
</div>

<h1>Coverage Summary for Class: SpringApplication (org.springframework.boot)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">SpringApplication</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/102)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/395)
  </span>
</td>
</tr>
  <tr>
    <td class="name">SpringApplication$AbandonedRunException</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SpringApplication$Augmented</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SpringApplication$Augmented$RunListener</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SpringApplication$CoordinatedRestoreAtCheckpointStartup</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SpringApplication$FactoryAwareOrderSourceProvider</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SpringApplication$KeepAlive</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/18)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SpringApplication$PropertySourceOrderingBeanFactoryPostProcessor</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SpringApplication$Running</td>
  </tr>
  <tr>
    <td class="name">SpringApplication$SingleUseSpringApplicationHook</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SpringApplication$SpringApplicationRuntimeHints</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SpringApplication$StandardStartup</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SpringApplication$Startup</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/11)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/140)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/487)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2012-2024 the original author or authors.
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *      https://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;
&nbsp;package org.springframework.boot;
&nbsp;
&nbsp;import java.lang.StackWalker.StackFrame;
&nbsp;import java.lang.management.ManagementFactory;
&nbsp;import java.lang.reflect.Method;
&nbsp;import java.time.Duration;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collection;
&nbsp;import java.util.Collections;
&nbsp;import java.util.Comparator;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.IdentityHashMap;
&nbsp;import java.util.LinkedHashSet;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Objects;
&nbsp;import java.util.Optional;
&nbsp;import java.util.Properties;
&nbsp;import java.util.Set;
&nbsp;import java.util.concurrent.atomic.AtomicBoolean;
&nbsp;import java.util.concurrent.atomic.AtomicReference;
&nbsp;import java.util.stream.Stream;
&nbsp;
&nbsp;import org.apache.commons.logging.Log;
&nbsp;import org.apache.commons.logging.LogFactory;
&nbsp;import org.crac.management.CRaCMXBean;
&nbsp;
&nbsp;import org.springframework.aot.AotDetector;
&nbsp;import org.springframework.beans.BeansException;
&nbsp;import org.springframework.beans.factory.NoSuchBeanDefinitionException;
&nbsp;import org.springframework.beans.factory.config.BeanDefinition;
&nbsp;import org.springframework.beans.factory.config.BeanFactoryPostProcessor;
&nbsp;import org.springframework.beans.factory.config.ConfigurableBeanFactory;
&nbsp;import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;
&nbsp;import org.springframework.beans.factory.groovy.GroovyBeanDefinitionReader;
&nbsp;import org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory;
&nbsp;import org.springframework.beans.factory.support.BeanDefinitionRegistry;
&nbsp;import org.springframework.beans.factory.support.BeanNameGenerator;
&nbsp;import org.springframework.beans.factory.support.DefaultListableBeanFactory;
&nbsp;import org.springframework.beans.factory.support.RootBeanDefinition;
&nbsp;import org.springframework.beans.factory.xml.XmlBeanDefinitionReader;
&nbsp;import org.springframework.boot.Banner.Mode;
&nbsp;import org.springframework.boot.context.properties.bind.Bindable;
&nbsp;import org.springframework.boot.context.properties.bind.BindableRuntimeHintsRegistrar;
&nbsp;import org.springframework.boot.context.properties.bind.Binder;
&nbsp;import org.springframework.boot.context.properties.source.ConfigurationPropertySources;
&nbsp;import org.springframework.boot.convert.ApplicationConversionService;
&nbsp;import org.springframework.boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext;
&nbsp;import org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext;
&nbsp;import org.springframework.context.ApplicationContext;
&nbsp;import org.springframework.context.ApplicationContextInitializer;
&nbsp;import org.springframework.context.ApplicationListener;
&nbsp;import org.springframework.context.ConfigurableApplicationContext;
&nbsp;import org.springframework.context.annotation.AnnotatedBeanDefinitionReader;
&nbsp;import org.springframework.context.annotation.AnnotationConfigApplicationContext;
&nbsp;import org.springframework.context.annotation.AnnotationConfigUtils;
&nbsp;import org.springframework.context.annotation.ClassPathBeanDefinitionScanner;
&nbsp;import org.springframework.context.annotation.ConfigurationClassPostProcessor;
&nbsp;import org.springframework.context.aot.AotApplicationContextInitializer;
&nbsp;import org.springframework.context.event.ApplicationContextEvent;
&nbsp;import org.springframework.context.event.ContextClosedEvent;
&nbsp;import org.springframework.context.event.ContextRefreshedEvent;
&nbsp;import org.springframework.context.support.AbstractApplicationContext;
&nbsp;import org.springframework.context.support.GenericApplicationContext;
&nbsp;import org.springframework.core.GenericTypeResolver;
&nbsp;import org.springframework.core.OrderComparator;
&nbsp;import org.springframework.core.OrderComparator.OrderSourceProvider;
&nbsp;import org.springframework.core.Ordered;
&nbsp;import org.springframework.core.annotation.AnnotationAwareOrderComparator;
&nbsp;import org.springframework.core.annotation.Order;
&nbsp;import org.springframework.core.env.CommandLinePropertySource;
&nbsp;import org.springframework.core.env.CompositePropertySource;
&nbsp;import org.springframework.core.env.ConfigurableEnvironment;
&nbsp;import org.springframework.core.env.Environment;
&nbsp;import org.springframework.core.env.MutablePropertySources;
&nbsp;import org.springframework.core.env.PropertySource;
&nbsp;import org.springframework.core.env.SimpleCommandLinePropertySource;
&nbsp;import org.springframework.core.io.DefaultResourceLoader;
&nbsp;import org.springframework.core.io.ResourceLoader;
&nbsp;import org.springframework.core.io.support.SpringFactoriesLoader;
&nbsp;import org.springframework.core.io.support.SpringFactoriesLoader.ArgumentResolver;
&nbsp;import org.springframework.core.metrics.ApplicationStartup;
&nbsp;import org.springframework.util.Assert;
&nbsp;import org.springframework.util.ClassUtils;
&nbsp;import org.springframework.util.CollectionUtils;
&nbsp;import org.springframework.util.ObjectUtils;
&nbsp;import org.springframework.util.StringUtils;
&nbsp;import org.springframework.util.function.ThrowingConsumer;
&nbsp;import org.springframework.util.function.ThrowingSupplier;
&nbsp;
&nbsp;/**
&nbsp; * Class that can be used to bootstrap and launch a Spring application from a Java main
&nbsp; * method. By default class will perform the following steps to bootstrap your
&nbsp; * application:
&nbsp; *
&nbsp; * &lt;ul&gt;
&nbsp; * &lt;li&gt;Create an appropriate {@link ApplicationContext} instance (depending on your
&nbsp; * classpath)&lt;/li&gt;
&nbsp; * &lt;li&gt;Register a {@link CommandLinePropertySource} to expose command line arguments as
&nbsp; * Spring properties&lt;/li&gt;
&nbsp; * &lt;li&gt;Refresh the application context, loading all singleton beans&lt;/li&gt;
&nbsp; * &lt;li&gt;Trigger any {@link CommandLineRunner} beans&lt;/li&gt;
&nbsp; * &lt;/ul&gt;
&nbsp; *
&nbsp; * In most circumstances the static {@link #run(Class, String[])} method can be called
&nbsp; * directly from your {@literal main} method to bootstrap your application:
&nbsp; *
&nbsp; * &lt;pre class=&quot;code&quot;&gt;
&nbsp; * &amp;#064;Configuration
&nbsp; * &amp;#064;EnableAutoConfiguration
&nbsp; * public class MyApplication  {
&nbsp; *
&nbsp; *   // ... Bean definitions
&nbsp; *
&nbsp; *   public static void main(String[] args) {
&nbsp; *     SpringApplication.run(MyApplication.class, args);
&nbsp; *   }
&nbsp; * }
&nbsp; * &lt;/pre&gt;
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * For more advanced configuration a {@link SpringApplication} instance can be created and
&nbsp; * customized before being run:
&nbsp; *
&nbsp; * &lt;pre class=&quot;code&quot;&gt;
&nbsp; * public static void main(String[] args) {
&nbsp; *   SpringApplication application = new SpringApplication(MyApplication.class);
&nbsp; *   // ... customize application settings here
&nbsp; *   application.run(args)
&nbsp; * }
&nbsp; * &lt;/pre&gt;
&nbsp; *
&nbsp; * {@link SpringApplication}s can read beans from a variety of different sources. It is
&nbsp; * generally recommended that a single {@code @Configuration} class is used to bootstrap
&nbsp; * your application, however, you may also set {@link #getSources() sources} from:
&nbsp; * &lt;ul&gt;
&nbsp; * &lt;li&gt;The fully qualified class name to be loaded by
&nbsp; * {@link AnnotatedBeanDefinitionReader}&lt;/li&gt;
&nbsp; * &lt;li&gt;The location of an XML resource to be loaded by {@link XmlBeanDefinitionReader}, or
&nbsp; * a groovy script to be loaded by {@link GroovyBeanDefinitionReader}&lt;/li&gt;
&nbsp; * &lt;li&gt;The name of a package to be scanned by {@link ClassPathBeanDefinitionScanner}&lt;/li&gt;
&nbsp; * &lt;/ul&gt;
&nbsp; *
&nbsp; * Configuration properties are also bound to the {@link SpringApplication}. This makes it
&nbsp; * possible to set {@link SpringApplication} properties dynamically, like additional
&nbsp; * sources (&quot;spring.main.sources&quot; - a CSV list) the flag to indicate a web environment
&nbsp; * (&quot;spring.main.web-application-type=none&quot;) or the flag to switch off the banner
&nbsp; * (&quot;spring.main.banner-mode=off&quot;).
&nbsp; *
&nbsp; * @author Phillip Webb
&nbsp; * @author Dave Syer
&nbsp; * @author Andy Wilkinson
&nbsp; * @author Christian Dupuis
&nbsp; * @author Stephane Nicoll
&nbsp; * @author Jeremy Rickard
&nbsp; * @author Craig Burke
&nbsp; * @author Michael Simons
&nbsp; * @author Madhura Bhave
&nbsp; * @author Brian Clozel
&nbsp; * @author Ethan Rubinson
&nbsp; * @author Chris Bono
&nbsp; * @author Moritz Halbritter
&nbsp; * @author Tadaya Tsuyukubo
&nbsp; * @author Lasse Wulff
&nbsp; * @author Yanming Zhou
&nbsp; * @since 1.0.0
&nbsp; * @see #run(Class, String[])
&nbsp; * @see #run(Class[], String[])
&nbsp; * @see #SpringApplication(Class...)
&nbsp; */
&nbsp;public class SpringApplication {
&nbsp;
&nbsp;	/**
&nbsp;	 * Default banner location.
&nbsp;	 */
&nbsp;	public static final String BANNER_LOCATION_PROPERTY_VALUE = SpringApplicationBannerPrinter.DEFAULT_BANNER_LOCATION;
&nbsp;
&nbsp;	/**
&nbsp;	 * Banner location property key.
&nbsp;	 */
&nbsp;	public static final String BANNER_LOCATION_PROPERTY = SpringApplicationBannerPrinter.BANNER_LOCATION_PROPERTY;
&nbsp;
&nbsp;	private static final String SYSTEM_PROPERTY_JAVA_AWT_HEADLESS = &quot;java.awt.headless&quot;;
&nbsp;
<b class="nc">&nbsp;	private static final Log logger = LogFactory.getLog(SpringApplication.class);</b>
&nbsp;
<b class="nc">&nbsp;	static final SpringApplicationShutdownHook shutdownHook = new SpringApplicationShutdownHook();</b>
&nbsp;
<b class="nc">&nbsp;	private static final ThreadLocal&lt;SpringApplicationHook&gt; applicationHook = new ThreadLocal&lt;&gt;();</b>
&nbsp;
&nbsp;	private final Set&lt;Class&lt;?&gt;&gt; primarySources;
&nbsp;
<b class="nc">&nbsp;	private Set&lt;String&gt; sources = new LinkedHashSet&lt;&gt;();</b>
&nbsp;
&nbsp;	private Class&lt;?&gt; mainApplicationClass;
&nbsp;
<b class="nc">&nbsp;	private Banner.Mode bannerMode = Banner.Mode.CONSOLE;</b>
&nbsp;
<b class="nc">&nbsp;	private boolean logStartupInfo = true;</b>
&nbsp;
<b class="nc">&nbsp;	private boolean addCommandLineProperties = true;</b>
&nbsp;
<b class="nc">&nbsp;	private boolean addConversionService = true;</b>
&nbsp;
&nbsp;	private Banner banner;
&nbsp;
&nbsp;	private ResourceLoader resourceLoader;
&nbsp;
&nbsp;	private BeanNameGenerator beanNameGenerator;
&nbsp;
&nbsp;	private ConfigurableEnvironment environment;
&nbsp;
&nbsp;	private WebApplicationType webApplicationType;
&nbsp;
<b class="nc">&nbsp;	private boolean headless = true;</b>
&nbsp;
<b class="nc">&nbsp;	private boolean registerShutdownHook = true;</b>
&nbsp;
&nbsp;	private List&lt;ApplicationContextInitializer&lt;?&gt;&gt; initializers;
&nbsp;
&nbsp;	private List&lt;ApplicationListener&lt;?&gt;&gt; listeners;
&nbsp;
&nbsp;	private Map&lt;String, Object&gt; defaultProperties;
&nbsp;
&nbsp;	private final List&lt;BootstrapRegistryInitializer&gt; bootstrapRegistryInitializers;
&nbsp;
<b class="nc">&nbsp;	private Set&lt;String&gt; additionalProfiles = Collections.emptySet();</b>
&nbsp;
&nbsp;	private boolean allowBeanDefinitionOverriding;
&nbsp;
&nbsp;	private boolean allowCircularReferences;
&nbsp;
<b class="nc">&nbsp;	private boolean isCustomEnvironment = false;</b>
&nbsp;
<b class="nc">&nbsp;	private boolean lazyInitialization = false;</b>
&nbsp;
&nbsp;	private String environmentPrefix;
&nbsp;
<b class="nc">&nbsp;	private ApplicationContextFactory applicationContextFactory = ApplicationContextFactory.DEFAULT;</b>
&nbsp;
<b class="nc">&nbsp;	private ApplicationStartup applicationStartup = ApplicationStartup.DEFAULT;</b>
&nbsp;
&nbsp;	private boolean keepAlive;
&nbsp;
&nbsp;	/**
&nbsp;	 * Create a new {@link SpringApplication} instance. The application context will load
&nbsp;	 * beans from the specified primary sources (see {@link SpringApplication class-level}
&nbsp;	 * documentation for details). The instance can be customized before calling
&nbsp;	 * {@link #run(String...)}.
&nbsp;	 * @param primarySources the primary bean sources
&nbsp;	 * @see #run(Class, String[])
&nbsp;	 * @see #SpringApplication(ResourceLoader, Class...)
&nbsp;	 * @see #setSources(Set)
&nbsp;	 */
&nbsp;	public SpringApplication(Class&lt;?&gt;... primarySources) {
<b class="nc">&nbsp;		this(null, primarySources);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Create a new {@link SpringApplication} instance. The application context will load
&nbsp;	 * beans from the specified primary sources (see {@link SpringApplication class-level}
&nbsp;	 * documentation for details). The instance can be customized before calling
&nbsp;	 * {@link #run(String...)}.
&nbsp;	 * @param resourceLoader the resource loader to use
&nbsp;	 * @param primarySources the primary bean sources
&nbsp;	 * @see #run(Class, String[])
&nbsp;	 * @see #setSources(Set)
&nbsp;	 */
&nbsp;	@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
<b class="nc">&nbsp;	public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) {</b>
<b class="nc">&nbsp;		this.resourceLoader = resourceLoader;</b>
<b class="nc">&nbsp;		Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;);</b>
<b class="nc">&nbsp;		this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));</b>
<b class="nc">&nbsp;		this.webApplicationType = WebApplicationType.deduceFromClasspath();</b>
<b class="nc">&nbsp;		this.bootstrapRegistryInitializers = new ArrayList&lt;&gt;(</b>
<b class="nc">&nbsp;				getSpringFactoriesInstances(BootstrapRegistryInitializer.class));</b>
<b class="nc">&nbsp;		setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</b>
<b class="nc">&nbsp;		setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</b>
<b class="nc">&nbsp;		this.mainApplicationClass = deduceMainApplicationClass();</b>
&nbsp;	}
&nbsp;
&nbsp;	private Class&lt;?&gt; deduceMainApplicationClass() {
<b class="nc">&nbsp;		return StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE)</b>
<b class="nc">&nbsp;			.walk(this::findMainClass)</b>
<b class="nc">&nbsp;			.orElse(null);</b>
&nbsp;	}
&nbsp;
&nbsp;	private Optional&lt;Class&lt;?&gt;&gt; findMainClass(Stream&lt;StackFrame&gt; stack) {
<b class="nc">&nbsp;		return stack.filter((frame) -&gt; Objects.equals(frame.getMethodName(), &quot;main&quot;))</b>
<b class="nc">&nbsp;			.findFirst()</b>
<b class="nc">&nbsp;			.map(StackWalker.StackFrame::getDeclaringClass);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Run the Spring application, creating and refreshing a new
&nbsp;	 * {@link ApplicationContext}.
&nbsp;	 * @param args the application arguments (usually passed from a Java main method)
&nbsp;	 * @return a running {@link ApplicationContext}
&nbsp;	 */
&nbsp;	public ConfigurableApplicationContext run(String... args) {
<b class="nc">&nbsp;		Startup startup = Startup.create();</b>
<b class="nc">&nbsp;		if (this.registerShutdownHook) {</b>
<b class="nc">&nbsp;			SpringApplication.shutdownHook.enableShutdownHookAddition();</b>
&nbsp;		}
<b class="nc">&nbsp;		DefaultBootstrapContext bootstrapContext = createBootstrapContext();</b>
<b class="nc">&nbsp;		ConfigurableApplicationContext context = null;</b>
<b class="nc">&nbsp;		configureHeadlessProperty();</b>
<b class="nc">&nbsp;		SpringApplicationRunListeners listeners = getRunListeners(args);</b>
<b class="nc">&nbsp;		listeners.starting(bootstrapContext, this.mainApplicationClass);</b>
&nbsp;		try {
<b class="nc">&nbsp;			ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);</b>
<b class="nc">&nbsp;			ConfigurableEnvironment environment = prepareEnvironment(listeners, bootstrapContext, applicationArguments);</b>
<b class="nc">&nbsp;			Banner printedBanner = printBanner(environment);</b>
<b class="nc">&nbsp;			context = createApplicationContext();</b>
<b class="nc">&nbsp;			context.setApplicationStartup(this.applicationStartup);</b>
<b class="nc">&nbsp;			prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);</b>
<b class="nc">&nbsp;			refreshContext(context);</b>
<b class="nc">&nbsp;			afterRefresh(context, applicationArguments);</b>
<b class="nc">&nbsp;			startup.started();</b>
<b class="nc">&nbsp;			if (this.logStartupInfo) {</b>
<b class="nc">&nbsp;				new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), startup);</b>
&nbsp;			}
<b class="nc">&nbsp;			listeners.started(context, startup.timeTakenToStarted());</b>
<b class="nc">&nbsp;			callRunners(context, applicationArguments);</b>
&nbsp;		}
<b class="nc">&nbsp;		catch (Throwable ex) {</b>
<b class="nc">&nbsp;			throw handleRunFailure(context, ex, listeners);</b>
<b class="nc">&nbsp;		}</b>
&nbsp;		try {
<b class="nc">&nbsp;			if (context.isRunning()) {</b>
<b class="nc">&nbsp;				listeners.ready(context, startup.ready());</b>
&nbsp;			}
&nbsp;		}
<b class="nc">&nbsp;		catch (Throwable ex) {</b>
<b class="nc">&nbsp;			throw handleRunFailure(context, ex, null);</b>
<b class="nc">&nbsp;		}</b>
<b class="nc">&nbsp;		return context;</b>
&nbsp;	}
&nbsp;
&nbsp;	private DefaultBootstrapContext createBootstrapContext() {
<b class="nc">&nbsp;		DefaultBootstrapContext bootstrapContext = new DefaultBootstrapContext();</b>
<b class="nc">&nbsp;		this.bootstrapRegistryInitializers.forEach((initializer) -&gt; initializer.initialize(bootstrapContext));</b>
<b class="nc">&nbsp;		return bootstrapContext;</b>
&nbsp;	}
&nbsp;
&nbsp;	private ConfigurableEnvironment prepareEnvironment(SpringApplicationRunListeners listeners,
&nbsp;			DefaultBootstrapContext bootstrapContext, ApplicationArguments applicationArguments) {
&nbsp;		// Create and configure the environment
<b class="nc">&nbsp;		ConfigurableEnvironment environment = getOrCreateEnvironment();</b>
<b class="nc">&nbsp;		configureEnvironment(environment, applicationArguments.getSourceArgs());</b>
<b class="nc">&nbsp;		ConfigurationPropertySources.attach(environment);</b>
<b class="nc">&nbsp;		listeners.environmentPrepared(bootstrapContext, environment);</b>
<b class="nc">&nbsp;		DefaultPropertiesPropertySource.moveToEnd(environment);</b>
<b class="nc">&nbsp;		Assert.state(!environment.containsProperty(&quot;spring.main.environment-prefix&quot;),</b>
&nbsp;				&quot;Environment prefix cannot be set via properties.&quot;);
<b class="nc">&nbsp;		bindToSpringApplication(environment);</b>
<b class="nc">&nbsp;		if (!this.isCustomEnvironment) {</b>
<b class="nc">&nbsp;			EnvironmentConverter environmentConverter = new EnvironmentConverter(getClassLoader());</b>
<b class="nc">&nbsp;			environment = environmentConverter.convertEnvironmentIfNecessary(environment, deduceEnvironmentClass());</b>
&nbsp;		}
<b class="nc">&nbsp;		ConfigurationPropertySources.attach(environment);</b>
<b class="nc">&nbsp;		return environment;</b>
&nbsp;	}
&nbsp;
&nbsp;	private Class&lt;? extends ConfigurableEnvironment&gt; deduceEnvironmentClass() {
<b class="nc">&nbsp;		Class&lt;? extends ConfigurableEnvironment&gt; environmentType = this.applicationContextFactory</b>
<b class="nc">&nbsp;			.getEnvironmentType(this.webApplicationType);</b>
<b class="nc">&nbsp;		if (environmentType == null &amp;&amp; this.applicationContextFactory != ApplicationContextFactory.DEFAULT) {</b>
<b class="nc">&nbsp;			environmentType = ApplicationContextFactory.DEFAULT.getEnvironmentType(this.webApplicationType);</b>
&nbsp;		}
<b class="nc">&nbsp;		if (environmentType == null) {</b>
<b class="nc">&nbsp;			return ApplicationEnvironment.class;</b>
&nbsp;		}
<b class="nc">&nbsp;		return environmentType;</b>
&nbsp;	}
&nbsp;
&nbsp;	private void prepareContext(DefaultBootstrapContext bootstrapContext, ConfigurableApplicationContext context,
&nbsp;			ConfigurableEnvironment environment, SpringApplicationRunListeners listeners,
&nbsp;			ApplicationArguments applicationArguments, Banner printedBanner) {
<b class="nc">&nbsp;		context.setEnvironment(environment);</b>
<b class="nc">&nbsp;		postProcessApplicationContext(context);</b>
<b class="nc">&nbsp;		addAotGeneratedInitializerIfNecessary(this.initializers);</b>
<b class="nc">&nbsp;		applyInitializers(context);</b>
<b class="nc">&nbsp;		listeners.contextPrepared(context);</b>
<b class="nc">&nbsp;		bootstrapContext.close(context);</b>
<b class="nc">&nbsp;		if (this.logStartupInfo) {</b>
<b class="nc">&nbsp;			logStartupInfo(context.getParent() == null);</b>
<b class="nc">&nbsp;			logStartupProfileInfo(context);</b>
&nbsp;		}
&nbsp;		// Add boot specific singleton beans
<b class="nc">&nbsp;		ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();</b>
<b class="nc">&nbsp;		beanFactory.registerSingleton(&quot;springApplicationArguments&quot;, applicationArguments);</b>
<b class="nc">&nbsp;		if (printedBanner != null) {</b>
<b class="nc">&nbsp;			beanFactory.registerSingleton(&quot;springBootBanner&quot;, printedBanner);</b>
&nbsp;		}
<b class="nc">&nbsp;		if (beanFactory instanceof AbstractAutowireCapableBeanFactory autowireCapableBeanFactory) {</b>
<b class="nc">&nbsp;			autowireCapableBeanFactory.setAllowCircularReferences(this.allowCircularReferences);</b>
<b class="nc">&nbsp;			if (beanFactory instanceof DefaultListableBeanFactory listableBeanFactory) {</b>
<b class="nc">&nbsp;				listableBeanFactory.setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);</b>
&nbsp;			}
&nbsp;		}
<b class="nc">&nbsp;		if (this.lazyInitialization) {</b>
<b class="nc">&nbsp;			context.addBeanFactoryPostProcessor(new LazyInitializationBeanFactoryPostProcessor());</b>
&nbsp;		}
<b class="nc">&nbsp;		if (this.keepAlive) {</b>
<b class="nc">&nbsp;			context.addApplicationListener(new KeepAlive());</b>
&nbsp;		}
<b class="nc">&nbsp;		context.addBeanFactoryPostProcessor(new PropertySourceOrderingBeanFactoryPostProcessor(context));</b>
<b class="nc">&nbsp;		if (!AotDetector.useGeneratedArtifacts()) {</b>
&nbsp;			// Load the sources
<b class="nc">&nbsp;			Set&lt;Object&gt; sources = getAllSources();</b>
<b class="nc">&nbsp;			Assert.notEmpty(sources, &quot;Sources must not be empty&quot;);</b>
<b class="nc">&nbsp;			load(context, sources.toArray(new Object[0]));</b>
&nbsp;		}
<b class="nc">&nbsp;		listeners.contextLoaded(context);</b>
&nbsp;	}
&nbsp;
&nbsp;	private void addAotGeneratedInitializerIfNecessary(List&lt;ApplicationContextInitializer&lt;?&gt;&gt; initializers) {
<b class="nc">&nbsp;		if (AotDetector.useGeneratedArtifacts()) {</b>
<b class="nc">&nbsp;			List&lt;ApplicationContextInitializer&lt;?&gt;&gt; aotInitializers = new ArrayList&lt;&gt;(</b>
<b class="nc">&nbsp;					initializers.stream().filter(AotApplicationContextInitializer.class::isInstance).toList());</b>
<b class="nc">&nbsp;			if (aotInitializers.isEmpty()) {</b>
<b class="nc">&nbsp;				String initializerClassName = this.mainApplicationClass.getName() + &quot;__ApplicationContextInitializer&quot;;</b>
<b class="nc">&nbsp;				Assert.state(ClassUtils.isPresent(initializerClassName, getClassLoader()),</b>
&nbsp;						&quot;You are starting the application with AOT mode enabled but AOT processing hasn&#39;t happened. &quot;
&nbsp;								+ &quot;Please build your application with enabled AOT processing first, &quot;
&nbsp;								+ &quot;or remove the system property &#39;spring.aot.enabled&#39; to run the application in regular mode&quot;);
<b class="nc">&nbsp;				aotInitializers.add(AotApplicationContextInitializer.forInitializerClasses(initializerClassName));</b>
&nbsp;			}
<b class="nc">&nbsp;			initializers.removeAll(aotInitializers);</b>
<b class="nc">&nbsp;			initializers.addAll(0, aotInitializers);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private void refreshContext(ConfigurableApplicationContext context) {
<b class="nc">&nbsp;		if (this.registerShutdownHook) {</b>
<b class="nc">&nbsp;			shutdownHook.registerApplicationContext(context);</b>
&nbsp;		}
<b class="nc">&nbsp;		refresh(context);</b>
&nbsp;	}
&nbsp;
&nbsp;	private void configureHeadlessProperty() {
<b class="nc">&nbsp;		System.setProperty(SYSTEM_PROPERTY_JAVA_AWT_HEADLESS,</b>
<b class="nc">&nbsp;				System.getProperty(SYSTEM_PROPERTY_JAVA_AWT_HEADLESS, Boolean.toString(this.headless)));</b>
&nbsp;	}
&nbsp;
&nbsp;	private SpringApplicationRunListeners getRunListeners(String[] args) {
<b class="nc">&nbsp;		ArgumentResolver argumentResolver = ArgumentResolver.of(SpringApplication.class, this);</b>
<b class="nc">&nbsp;		argumentResolver = argumentResolver.and(String[].class, args);</b>
<b class="nc">&nbsp;		List&lt;SpringApplicationRunListener&gt; listeners = getSpringFactoriesInstances(SpringApplicationRunListener.class,</b>
&nbsp;				argumentResolver);
<b class="nc">&nbsp;		SpringApplicationHook hook = applicationHook.get();</b>
<b class="nc">&nbsp;		SpringApplicationRunListener hookListener = (hook != null) ? hook.getRunListener(this) : null;</b>
<b class="nc">&nbsp;		if (hookListener != null) {</b>
<b class="nc">&nbsp;			listeners = new ArrayList&lt;&gt;(listeners);</b>
<b class="nc">&nbsp;			listeners.add(hookListener);</b>
&nbsp;		}
<b class="nc">&nbsp;		return new SpringApplicationRunListeners(logger, listeners, this.applicationStartup);</b>
&nbsp;	}
&nbsp;
&nbsp;	private &lt;T&gt; List&lt;T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type) {
<b class="nc">&nbsp;		return getSpringFactoriesInstances(type, null);</b>
&nbsp;	}
&nbsp;
&nbsp;	private &lt;T&gt; List&lt;T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type, ArgumentResolver argumentResolver) {
<b class="nc">&nbsp;		return SpringFactoriesLoader.forDefaultResourceLocation(getClassLoader()).load(type, argumentResolver);</b>
&nbsp;	}
&nbsp;
&nbsp;	private ConfigurableEnvironment getOrCreateEnvironment() {
<b class="nc">&nbsp;		if (this.environment != null) {</b>
<b class="nc">&nbsp;			return this.environment;</b>
&nbsp;		}
<b class="nc">&nbsp;		ConfigurableEnvironment environment = this.applicationContextFactory.createEnvironment(this.webApplicationType);</b>
<b class="nc">&nbsp;		if (environment == null &amp;&amp; this.applicationContextFactory != ApplicationContextFactory.DEFAULT) {</b>
<b class="nc">&nbsp;			environment = ApplicationContextFactory.DEFAULT.createEnvironment(this.webApplicationType);</b>
&nbsp;		}
<b class="nc">&nbsp;		return (environment != null) ? environment : new ApplicationEnvironment();</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Template method delegating to
&nbsp;	 * {@link #configurePropertySources(ConfigurableEnvironment, String[])} and
&nbsp;	 * {@link #configureProfiles(ConfigurableEnvironment, String[])} in that order.
&nbsp;	 * Override this method for complete control over Environment customization, or one of
&nbsp;	 * the above for fine-grained control over property sources or profiles, respectively.
&nbsp;	 * @param environment this application&#39;s environment
&nbsp;	 * @param args arguments passed to the {@code run} method
&nbsp;	 * @see #configureProfiles(ConfigurableEnvironment, String[])
&nbsp;	 * @see #configurePropertySources(ConfigurableEnvironment, String[])
&nbsp;	 */
&nbsp;	protected void configureEnvironment(ConfigurableEnvironment environment, String[] args) {
<b class="nc">&nbsp;		if (this.addConversionService) {</b>
<b class="nc">&nbsp;			environment.setConversionService(new ApplicationConversionService());</b>
&nbsp;		}
<b class="nc">&nbsp;		configurePropertySources(environment, args);</b>
<b class="nc">&nbsp;		configureProfiles(environment, args);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Add, remove or re-order any {@link PropertySource}s in this application&#39;s
&nbsp;	 * environment.
&nbsp;	 * @param environment this application&#39;s environment
&nbsp;	 * @param args arguments passed to the {@code run} method
&nbsp;	 * @see #configureEnvironment(ConfigurableEnvironment, String[])
&nbsp;	 */
&nbsp;	protected void configurePropertySources(ConfigurableEnvironment environment, String[] args) {
<b class="nc">&nbsp;		MutablePropertySources sources = environment.getPropertySources();</b>
<b class="nc">&nbsp;		if (!CollectionUtils.isEmpty(this.defaultProperties)) {</b>
<b class="nc">&nbsp;			DefaultPropertiesPropertySource.addOrMerge(this.defaultProperties, sources);</b>
&nbsp;		}
<b class="nc">&nbsp;		if (this.addCommandLineProperties &amp;&amp; args.length &gt; 0) {</b>
<b class="nc">&nbsp;			String name = CommandLinePropertySource.COMMAND_LINE_PROPERTY_SOURCE_NAME;</b>
<b class="nc">&nbsp;			if (sources.contains(name)) {</b>
<b class="nc">&nbsp;				PropertySource&lt;?&gt; source = sources.get(name);</b>
<b class="nc">&nbsp;				CompositePropertySource composite = new CompositePropertySource(name);</b>
<b class="nc">&nbsp;				composite</b>
<b class="nc">&nbsp;					.addPropertySource(new SimpleCommandLinePropertySource(&quot;springApplicationCommandLineArgs&quot;, args));</b>
<b class="nc">&nbsp;				composite.addPropertySource(source);</b>
<b class="nc">&nbsp;				sources.replace(name, composite);</b>
<b class="nc">&nbsp;			}</b>
&nbsp;			else {
<b class="nc">&nbsp;				sources.addFirst(new SimpleCommandLinePropertySource(args));</b>
&nbsp;			}
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Configure which profiles are active (or active by default) for this application
&nbsp;	 * environment. Additional profiles may be activated during configuration file
&nbsp;	 * processing through the {@code spring.profiles.active} property.
&nbsp;	 * @param environment this application&#39;s environment
&nbsp;	 * @param args arguments passed to the {@code run} method
&nbsp;	 * @see #configureEnvironment(ConfigurableEnvironment, String[])
&nbsp;	 */
&nbsp;	protected void configureProfiles(ConfigurableEnvironment environment, String[] args) {
<b class="nc">&nbsp;	}</b>
&nbsp;
&nbsp;	/**
&nbsp;	 * Bind the environment to the {@link SpringApplication}.
&nbsp;	 * @param environment the environment to bind
&nbsp;	 */
&nbsp;	protected void bindToSpringApplication(ConfigurableEnvironment environment) {
&nbsp;		try {
<b class="nc">&nbsp;			Binder.get(environment).bind(&quot;spring.main&quot;, Bindable.ofInstance(this));</b>
&nbsp;		}
<b class="nc">&nbsp;		catch (Exception ex) {</b>
<b class="nc">&nbsp;			throw new IllegalStateException(&quot;Cannot bind to SpringApplication&quot;, ex);</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	private Banner printBanner(ConfigurableEnvironment environment) {
<b class="nc">&nbsp;		if (this.bannerMode == Banner.Mode.OFF) {</b>
<b class="nc">&nbsp;			return null;</b>
&nbsp;		}
<b class="nc">&nbsp;		ResourceLoader resourceLoader = (this.resourceLoader != null) ? this.resourceLoader</b>
<b class="nc">&nbsp;				: new DefaultResourceLoader(null);</b>
<b class="nc">&nbsp;		SpringApplicationBannerPrinter bannerPrinter = new SpringApplicationBannerPrinter(resourceLoader, this.banner);</b>
<b class="nc">&nbsp;		if (this.bannerMode == Mode.LOG) {</b>
<b class="nc">&nbsp;			return bannerPrinter.print(environment, this.mainApplicationClass, logger);</b>
&nbsp;		}
<b class="nc">&nbsp;		return bannerPrinter.print(environment, this.mainApplicationClass, System.out);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Strategy method used to create the {@link ApplicationContext}. By default this
&nbsp;	 * method will respect any explicitly set application context class or factory before
&nbsp;	 * falling back to a suitable default.
&nbsp;	 * @return the application context (not yet refreshed)
&nbsp;	 * @see #setApplicationContextFactory(ApplicationContextFactory)
&nbsp;	 */
&nbsp;	protected ConfigurableApplicationContext createApplicationContext() {
<b class="nc">&nbsp;		return this.applicationContextFactory.create(this.webApplicationType);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Apply any relevant post-processing to the {@link ApplicationContext}. Subclasses
&nbsp;	 * can apply additional processing as required.
&nbsp;	 * @param context the application context
&nbsp;	 */
&nbsp;	protected void postProcessApplicationContext(ConfigurableApplicationContext context) {
<b class="nc">&nbsp;		if (this.beanNameGenerator != null) {</b>
<b class="nc">&nbsp;			context.getBeanFactory()</b>
<b class="nc">&nbsp;				.registerSingleton(AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR, this.beanNameGenerator);</b>
&nbsp;		}
<b class="nc">&nbsp;		if (this.resourceLoader != null) {</b>
<b class="nc">&nbsp;			if (context instanceof GenericApplicationContext genericApplicationContext) {</b>
<b class="nc">&nbsp;				genericApplicationContext.setResourceLoader(this.resourceLoader);</b>
&nbsp;			}
<b class="nc">&nbsp;			if (context instanceof DefaultResourceLoader defaultResourceLoader) {</b>
<b class="nc">&nbsp;				defaultResourceLoader.setClassLoader(this.resourceLoader.getClassLoader());</b>
&nbsp;			}
&nbsp;		}
<b class="nc">&nbsp;		if (this.addConversionService) {</b>
<b class="nc">&nbsp;			context.getBeanFactory().setConversionService(context.getEnvironment().getConversionService());</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Apply any {@link ApplicationContextInitializer}s to the context before it is
&nbsp;	 * refreshed.
&nbsp;	 * @param context the configured ApplicationContext (not refreshed yet)
&nbsp;	 * @see ConfigurableApplicationContext#refresh()
&nbsp;	 */
&nbsp;	@SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; })
&nbsp;	protected void applyInitializers(ConfigurableApplicationContext context) {
<b class="nc">&nbsp;		for (ApplicationContextInitializer initializer : getInitializers()) {</b>
<b class="nc">&nbsp;			Class&lt;?&gt; requiredType = GenericTypeResolver.resolveTypeArgument(initializer.getClass(),</b>
&nbsp;					ApplicationContextInitializer.class);
<b class="nc">&nbsp;			Assert.isInstanceOf(requiredType, context, &quot;Unable to call initializer.&quot;);</b>
<b class="nc">&nbsp;			initializer.initialize(context);</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Called to log startup information, subclasses may override to add additional
&nbsp;	 * logging.
&nbsp;	 * @param isRoot true if this application is the root of a context hierarchy
&nbsp;	 */
&nbsp;	protected void logStartupInfo(boolean isRoot) {
<b class="nc">&nbsp;		if (isRoot) {</b>
<b class="nc">&nbsp;			new StartupInfoLogger(this.mainApplicationClass).logStarting(getApplicationLog());</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Called to log active profile information.
&nbsp;	 * @param context the application context
&nbsp;	 */
&nbsp;	protected void logStartupProfileInfo(ConfigurableApplicationContext context) {
<b class="nc">&nbsp;		Log log = getApplicationLog();</b>
<b class="nc">&nbsp;		if (log.isInfoEnabled()) {</b>
<b class="nc">&nbsp;			List&lt;String&gt; activeProfiles = quoteProfiles(context.getEnvironment().getActiveProfiles());</b>
<b class="nc">&nbsp;			if (ObjectUtils.isEmpty(activeProfiles)) {</b>
<b class="nc">&nbsp;				List&lt;String&gt; defaultProfiles = quoteProfiles(context.getEnvironment().getDefaultProfiles());</b>
<b class="nc">&nbsp;				String message = String.format(&quot;%s default %s: &quot;, defaultProfiles.size(),</b>
<b class="nc">&nbsp;						(defaultProfiles.size() &lt;= 1) ? &quot;profile&quot; : &quot;profiles&quot;);</b>
<b class="nc">&nbsp;				log.info(&quot;No active profile set, falling back to &quot; + message</b>
<b class="nc">&nbsp;						+ StringUtils.collectionToDelimitedString(defaultProfiles, &quot;, &quot;));</b>
<b class="nc">&nbsp;			}</b>
&nbsp;			else {
<b class="nc">&nbsp;				String message = (activeProfiles.size() == 1) ? &quot;1 profile is active: &quot;</b>
<b class="nc">&nbsp;						: activeProfiles.size() + &quot; profiles are active: &quot;;</b>
<b class="nc">&nbsp;				log.info(&quot;The following &quot; + message + StringUtils.collectionToDelimitedString(activeProfiles, &quot;, &quot;));</b>
&nbsp;			}
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private List&lt;String&gt; quoteProfiles(String[] profiles) {
<b class="nc">&nbsp;		return Arrays.stream(profiles).map((profile) -&gt; &quot;\&quot;&quot; + profile + &quot;\&quot;&quot;).toList();</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns the {@link Log} for the application. By default will be deduced.
&nbsp;	 * @return the application log
&nbsp;	 */
&nbsp;	protected Log getApplicationLog() {
<b class="nc">&nbsp;		if (this.mainApplicationClass == null) {</b>
<b class="nc">&nbsp;			return logger;</b>
&nbsp;		}
<b class="nc">&nbsp;		return LogFactory.getLog(this.mainApplicationClass);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Load beans into the application context.
&nbsp;	 * @param context the context to load beans into
&nbsp;	 * @param sources the sources to load
&nbsp;	 */
&nbsp;	protected void load(ApplicationContext context, Object[] sources) {
<b class="nc">&nbsp;		if (logger.isDebugEnabled()) {</b>
<b class="nc">&nbsp;			logger.debug(&quot;Loading source &quot; + StringUtils.arrayToCommaDelimitedString(sources));</b>
&nbsp;		}
<b class="nc">&nbsp;		BeanDefinitionLoader loader = createBeanDefinitionLoader(getBeanDefinitionRegistry(context), sources);</b>
<b class="nc">&nbsp;		if (this.beanNameGenerator != null) {</b>
<b class="nc">&nbsp;			loader.setBeanNameGenerator(this.beanNameGenerator);</b>
&nbsp;		}
<b class="nc">&nbsp;		if (this.resourceLoader != null) {</b>
<b class="nc">&nbsp;			loader.setResourceLoader(this.resourceLoader);</b>
&nbsp;		}
<b class="nc">&nbsp;		if (this.environment != null) {</b>
<b class="nc">&nbsp;			loader.setEnvironment(this.environment);</b>
&nbsp;		}
<b class="nc">&nbsp;		loader.load();</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * The ResourceLoader that will be used in the ApplicationContext.
&nbsp;	 * @return the resourceLoader the resource loader that will be used in the
&nbsp;	 * ApplicationContext (or null if the default)
&nbsp;	 */
&nbsp;	public ResourceLoader getResourceLoader() {
<b class="nc">&nbsp;		return this.resourceLoader;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Either the ClassLoader that will be used in the ApplicationContext (if
&nbsp;	 * {@link #setResourceLoader(ResourceLoader) resourceLoader} is set), or the context
&nbsp;	 * class loader (if not null), or the loader of the Spring {@link ClassUtils} class.
&nbsp;	 * @return a ClassLoader (never null)
&nbsp;	 */
&nbsp;	public ClassLoader getClassLoader() {
<b class="nc">&nbsp;		if (this.resourceLoader != null) {</b>
<b class="nc">&nbsp;			return this.resourceLoader.getClassLoader();</b>
&nbsp;		}
<b class="nc">&nbsp;		return ClassUtils.getDefaultClassLoader();</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Get the bean definition registry.
&nbsp;	 * @param context the application context
&nbsp;	 * @return the BeanDefinitionRegistry if it can be determined
&nbsp;	 */
&nbsp;	private BeanDefinitionRegistry getBeanDefinitionRegistry(ApplicationContext context) {
<b class="nc">&nbsp;		if (context instanceof BeanDefinitionRegistry registry) {</b>
<b class="nc">&nbsp;			return registry;</b>
&nbsp;		}
<b class="nc">&nbsp;		if (context instanceof AbstractApplicationContext abstractApplicationContext) {</b>
<b class="nc">&nbsp;			return (BeanDefinitionRegistry) abstractApplicationContext.getBeanFactory();</b>
&nbsp;		}
<b class="nc">&nbsp;		throw new IllegalStateException(&quot;Could not locate BeanDefinitionRegistry&quot;);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Factory method used to create the {@link BeanDefinitionLoader}.
&nbsp;	 * @param registry the bean definition registry
&nbsp;	 * @param sources the sources to load
&nbsp;	 * @return the {@link BeanDefinitionLoader} that will be used to load beans
&nbsp;	 */
&nbsp;	protected BeanDefinitionLoader createBeanDefinitionLoader(BeanDefinitionRegistry registry, Object[] sources) {
<b class="nc">&nbsp;		return new BeanDefinitionLoader(registry, sources);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Refresh the underlying {@link ApplicationContext}.
&nbsp;	 * @param applicationContext the application context to refresh
&nbsp;	 */
&nbsp;	protected void refresh(ConfigurableApplicationContext applicationContext) {
<b class="nc">&nbsp;		applicationContext.refresh();</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Called after the context has been refreshed.
&nbsp;	 * @param context the application context
&nbsp;	 * @param args the application arguments
&nbsp;	 */
&nbsp;	protected void afterRefresh(ConfigurableApplicationContext context, ApplicationArguments args) {
<b class="nc">&nbsp;	}</b>
&nbsp;
&nbsp;	private void callRunners(ConfigurableApplicationContext context, ApplicationArguments args) {
<b class="nc">&nbsp;		ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();</b>
<b class="nc">&nbsp;		String[] beanNames = beanFactory.getBeanNamesForType(Runner.class);</b>
<b class="nc">&nbsp;		Map&lt;Runner, String&gt; instancesToBeanNames = new IdentityHashMap&lt;&gt;();</b>
<b class="nc">&nbsp;		for (String beanName : beanNames) {</b>
<b class="nc">&nbsp;			instancesToBeanNames.put(beanFactory.getBean(beanName, Runner.class), beanName);</b>
&nbsp;		}
<b class="nc">&nbsp;		Comparator&lt;Object&gt; comparator = getOrderComparator(beanFactory)</b>
<b class="nc">&nbsp;			.withSourceProvider(new FactoryAwareOrderSourceProvider(beanFactory, instancesToBeanNames));</b>
<b class="nc">&nbsp;		instancesToBeanNames.keySet().stream().sorted(comparator).forEach((runner) -&gt; callRunner(runner, args));</b>
&nbsp;	}
&nbsp;
&nbsp;	private OrderComparator getOrderComparator(ConfigurableListableBeanFactory beanFactory) {
<b class="nc">&nbsp;		Comparator&lt;?&gt; dependencyComparator = (beanFactory instanceof DefaultListableBeanFactory defaultListableBeanFactory)</b>
<b class="nc">&nbsp;				? defaultListableBeanFactory.getDependencyComparator() : null;</b>
<b class="nc">&nbsp;		return (dependencyComparator instanceof OrderComparator orderComparator) ? orderComparator</b>
<b class="nc">&nbsp;				: AnnotationAwareOrderComparator.INSTANCE;</b>
&nbsp;	}
&nbsp;
&nbsp;	private void callRunner(Runner runner, ApplicationArguments args) {
<b class="nc">&nbsp;		if (runner instanceof ApplicationRunner) {</b>
<b class="nc">&nbsp;			callRunner(ApplicationRunner.class, runner, (applicationRunner) -&gt; applicationRunner.run(args));</b>
&nbsp;		}
<b class="nc">&nbsp;		if (runner instanceof CommandLineRunner) {</b>
<b class="nc">&nbsp;			callRunner(CommandLineRunner.class, runner,</b>
<b class="nc">&nbsp;					(commandLineRunner) -&gt; commandLineRunner.run(args.getSourceArgs()));</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	@SuppressWarnings(&quot;unchecked&quot;)
&nbsp;	private &lt;R extends Runner&gt; void callRunner(Class&lt;R&gt; type, Runner runner, ThrowingConsumer&lt;R&gt; call) {
<b class="nc">&nbsp;		call.throwing(</b>
<b class="nc">&nbsp;				(message, ex) -&gt; new IllegalStateException(&quot;Failed to execute &quot; + ClassUtils.getShortName(type), ex))</b>
<b class="nc">&nbsp;			.accept((R) runner);</b>
&nbsp;	}
&nbsp;
&nbsp;	private RuntimeException handleRunFailure(ConfigurableApplicationContext context, Throwable exception,
&nbsp;			SpringApplicationRunListeners listeners) {
<b class="nc">&nbsp;		if (exception instanceof AbandonedRunException abandonedRunException) {</b>
<b class="nc">&nbsp;			return abandonedRunException;</b>
&nbsp;		}
&nbsp;		try {
&nbsp;			try {
<b class="nc">&nbsp;				handleExitCode(context, exception);</b>
<b class="nc">&nbsp;				if (listeners != null) {</b>
<b class="nc">&nbsp;					listeners.failed(context, exception);</b>
&nbsp;				}
&nbsp;			}
&nbsp;			finally {
<b class="nc">&nbsp;				reportFailure(getExceptionReporters(context), exception);</b>
<b class="nc">&nbsp;				if (context != null) {</b>
<b class="nc">&nbsp;					context.close();</b>
<b class="nc">&nbsp;					shutdownHook.deregisterFailedApplicationContext(context);</b>
&nbsp;				}
<b class="nc">&nbsp;			}</b>
&nbsp;		}
<b class="nc">&nbsp;		catch (Exception ex) {</b>
<b class="nc">&nbsp;			logger.warn(&quot;Unable to close ApplicationContext&quot;, ex);</b>
<b class="nc">&nbsp;		}</b>
<b class="nc">&nbsp;		return (exception instanceof RuntimeException runtimeException) ? runtimeException</b>
<b class="nc">&nbsp;				: new IllegalStateException(exception);</b>
&nbsp;	}
&nbsp;
&nbsp;	private Collection&lt;SpringBootExceptionReporter&gt; getExceptionReporters(ConfigurableApplicationContext context) {
&nbsp;		try {
<b class="nc">&nbsp;			ArgumentResolver argumentResolver = ArgumentResolver.of(ConfigurableApplicationContext.class, context);</b>
<b class="nc">&nbsp;			return getSpringFactoriesInstances(SpringBootExceptionReporter.class, argumentResolver);</b>
&nbsp;		}
<b class="nc">&nbsp;		catch (Throwable ex) {</b>
<b class="nc">&nbsp;			return Collections.emptyList();</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private void reportFailure(Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters, Throwable failure) {
&nbsp;		try {
<b class="nc">&nbsp;			for (SpringBootExceptionReporter reporter : exceptionReporters) {</b>
<b class="nc">&nbsp;				if (reporter.reportException(failure)) {</b>
<b class="nc">&nbsp;					registerLoggedException(failure);</b>
&nbsp;					return;
&nbsp;				}
<b class="nc">&nbsp;			}</b>
&nbsp;		}
<b class="nc">&nbsp;		catch (Throwable ex) {</b>
&nbsp;			// Continue with normal handling of the original failure
<b class="nc">&nbsp;		}</b>
<b class="nc">&nbsp;		if (logger.isErrorEnabled()) {</b>
<b class="nc">&nbsp;			logger.error(&quot;Application run failed&quot;, failure);</b>
<b class="nc">&nbsp;			registerLoggedException(failure);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Register that the given exception has been logged. By default, if the running in
&nbsp;	 * the main thread, this method will suppress additional printing of the stacktrace.
&nbsp;	 * @param exception the exception that was logged
&nbsp;	 */
&nbsp;	protected void registerLoggedException(Throwable exception) {
<b class="nc">&nbsp;		SpringBootExceptionHandler handler = getSpringBootExceptionHandler();</b>
<b class="nc">&nbsp;		if (handler != null) {</b>
<b class="nc">&nbsp;			handler.registerLoggedException(exception);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private void handleExitCode(ConfigurableApplicationContext context, Throwable exception) {
<b class="nc">&nbsp;		int exitCode = getExitCodeFromException(context, exception);</b>
<b class="nc">&nbsp;		if (exitCode != 0) {</b>
<b class="nc">&nbsp;			if (context != null) {</b>
<b class="nc">&nbsp;				context.publishEvent(new ExitCodeEvent(context, exitCode));</b>
&nbsp;			}
<b class="nc">&nbsp;			SpringBootExceptionHandler handler = getSpringBootExceptionHandler();</b>
<b class="nc">&nbsp;			if (handler != null) {</b>
<b class="nc">&nbsp;				handler.registerExitCode(exitCode);</b>
&nbsp;			}
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private int getExitCodeFromException(ConfigurableApplicationContext context, Throwable exception) {
<b class="nc">&nbsp;		int exitCode = getExitCodeFromMappedException(context, exception);</b>
<b class="nc">&nbsp;		if (exitCode == 0) {</b>
<b class="nc">&nbsp;			exitCode = getExitCodeFromExitCodeGeneratorException(exception);</b>
&nbsp;		}
<b class="nc">&nbsp;		return exitCode;</b>
&nbsp;	}
&nbsp;
&nbsp;	private int getExitCodeFromMappedException(ConfigurableApplicationContext context, Throwable exception) {
<b class="nc">&nbsp;		if (context == null || !context.isActive()) {</b>
<b class="nc">&nbsp;			return 0;</b>
&nbsp;		}
<b class="nc">&nbsp;		ExitCodeGenerators generators = new ExitCodeGenerators();</b>
<b class="nc">&nbsp;		Collection&lt;ExitCodeExceptionMapper&gt; beans = context.getBeansOfType(ExitCodeExceptionMapper.class).values();</b>
<b class="nc">&nbsp;		generators.addAll(exception, beans);</b>
<b class="nc">&nbsp;		return generators.getExitCode();</b>
&nbsp;	}
&nbsp;
&nbsp;	private int getExitCodeFromExitCodeGeneratorException(Throwable exception) {
<b class="nc">&nbsp;		if (exception == null) {</b>
<b class="nc">&nbsp;			return 0;</b>
&nbsp;		}
<b class="nc">&nbsp;		if (exception instanceof ExitCodeGenerator generator) {</b>
<b class="nc">&nbsp;			return generator.getExitCode();</b>
&nbsp;		}
<b class="nc">&nbsp;		return getExitCodeFromExitCodeGeneratorException(exception.getCause());</b>
&nbsp;	}
&nbsp;
&nbsp;	SpringBootExceptionHandler getSpringBootExceptionHandler() {
<b class="nc">&nbsp;		if (isMainThread(Thread.currentThread())) {</b>
<b class="nc">&nbsp;			return SpringBootExceptionHandler.forCurrentThread();</b>
&nbsp;		}
<b class="nc">&nbsp;		return null;</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean isMainThread(Thread currentThread) {
<b class="nc">&nbsp;		return (&quot;main&quot;.equals(currentThread.getName()) || &quot;restartedMain&quot;.equals(currentThread.getName()))</b>
<b class="nc">&nbsp;				&amp;&amp; &quot;main&quot;.equals(currentThread.getThreadGroup().getName());</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns the main application class that has been deduced or explicitly configured.
&nbsp;	 * @return the main application class or {@code null}
&nbsp;	 */
&nbsp;	public Class&lt;?&gt; getMainApplicationClass() {
<b class="nc">&nbsp;		return this.mainApplicationClass;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Set a specific main application class that will be used as a log source and to
&nbsp;	 * obtain version information. By default the main application class will be deduced.
&nbsp;	 * Can be set to {@code null} if there is no explicit application class.
&nbsp;	 * @param mainApplicationClass the mainApplicationClass to set or {@code null}
&nbsp;	 */
&nbsp;	public void setMainApplicationClass(Class&lt;?&gt; mainApplicationClass) {
<b class="nc">&nbsp;		this.mainApplicationClass = mainApplicationClass;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns the type of web application that is being run.
&nbsp;	 * @return the type of web application
&nbsp;	 * @since 2.0.0
&nbsp;	 */
&nbsp;	public WebApplicationType getWebApplicationType() {
<b class="nc">&nbsp;		return this.webApplicationType;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Sets the type of web application to be run. If not explicitly set the type of web
&nbsp;	 * application will be deduced based on the classpath.
&nbsp;	 * @param webApplicationType the web application type
&nbsp;	 * @since 2.0.0
&nbsp;	 */
&nbsp;	public void setWebApplicationType(WebApplicationType webApplicationType) {
<b class="nc">&nbsp;		Assert.notNull(webApplicationType, &quot;WebApplicationType must not be null&quot;);</b>
<b class="nc">&nbsp;		this.webApplicationType = webApplicationType;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Sets if bean definition overriding, by registering a definition with the same name
&nbsp;	 * as an existing definition, should be allowed. Defaults to {@code false}.
&nbsp;	 * @param allowBeanDefinitionOverriding if overriding is allowed
&nbsp;	 * @since 2.1.0
&nbsp;	 * @see DefaultListableBeanFactory#setAllowBeanDefinitionOverriding(boolean)
&nbsp;	 */
&nbsp;	public void setAllowBeanDefinitionOverriding(boolean allowBeanDefinitionOverriding) {
<b class="nc">&nbsp;		this.allowBeanDefinitionOverriding = allowBeanDefinitionOverriding;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Sets whether to allow circular references between beans and automatically try to
&nbsp;	 * resolve them. Defaults to {@code false}.
&nbsp;	 * @param allowCircularReferences if circular references are allowed
&nbsp;	 * @since 2.6.0
&nbsp;	 * @see AbstractAutowireCapableBeanFactory#setAllowCircularReferences(boolean)
&nbsp;	 */
&nbsp;	public void setAllowCircularReferences(boolean allowCircularReferences) {
<b class="nc">&nbsp;		this.allowCircularReferences = allowCircularReferences;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Sets if beans should be initialized lazily. Defaults to {@code false}.
&nbsp;	 * @param lazyInitialization if initialization should be lazy
&nbsp;	 * @since 2.2
&nbsp;	 * @see BeanDefinition#setLazyInit(boolean)
&nbsp;	 */
&nbsp;	public void setLazyInitialization(boolean lazyInitialization) {
<b class="nc">&nbsp;		this.lazyInitialization = lazyInitialization;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Sets if the application is headless and should not instantiate AWT. Defaults to
&nbsp;	 * {@code true} to prevent java icons appearing.
&nbsp;	 * @param headless if the application is headless
&nbsp;	 */
&nbsp;	public void setHeadless(boolean headless) {
<b class="nc">&nbsp;		this.headless = headless;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Sets if the created {@link ApplicationContext} should have a shutdown hook
&nbsp;	 * registered. Defaults to {@code true} to ensure that JVM shutdowns are handled
&nbsp;	 * gracefully.
&nbsp;	 * @param registerShutdownHook if the shutdown hook should be registered
&nbsp;	 * @see #getShutdownHandlers()
&nbsp;	 */
&nbsp;	public void setRegisterShutdownHook(boolean registerShutdownHook) {
<b class="nc">&nbsp;		this.registerShutdownHook = registerShutdownHook;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Sets the {@link Banner} instance which will be used to print the banner when no
&nbsp;	 * static banner file is provided.
&nbsp;	 * @param banner the Banner instance to use
&nbsp;	 */
&nbsp;	public void setBanner(Banner banner) {
<b class="nc">&nbsp;		this.banner = banner;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Sets the mode used to display the banner when the application runs. Defaults to
&nbsp;	 * {@code Banner.Mode.CONSOLE}.
&nbsp;	 * @param bannerMode the mode used to display the banner
&nbsp;	 */
&nbsp;	public void setBannerMode(Banner.Mode bannerMode) {
<b class="nc">&nbsp;		this.bannerMode = bannerMode;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Sets if the application information should be logged when the application starts.
&nbsp;	 * Defaults to {@code true}.
&nbsp;	 * @param logStartupInfo if startup info should be logged.
&nbsp;	 */
&nbsp;	public void setLogStartupInfo(boolean logStartupInfo) {
<b class="nc">&nbsp;		this.logStartupInfo = logStartupInfo;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Sets if a {@link CommandLinePropertySource} should be added to the application
&nbsp;	 * context in order to expose arguments. Defaults to {@code true}.
&nbsp;	 * @param addCommandLineProperties if command line arguments should be exposed
&nbsp;	 */
&nbsp;	public void setAddCommandLineProperties(boolean addCommandLineProperties) {
<b class="nc">&nbsp;		this.addCommandLineProperties = addCommandLineProperties;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Sets if the {@link ApplicationConversionService} should be added to the application
&nbsp;	 * context&#39;s {@link Environment}.
&nbsp;	 * @param addConversionService if the application conversion service should be added
&nbsp;	 * @since 2.1.0
&nbsp;	 */
&nbsp;	public void setAddConversionService(boolean addConversionService) {
<b class="nc">&nbsp;		this.addConversionService = addConversionService;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Adds {@link BootstrapRegistryInitializer} instances that can be used to initialize
&nbsp;	 * the {@link BootstrapRegistry}.
&nbsp;	 * @param bootstrapRegistryInitializer the bootstrap registry initializer to add
&nbsp;	 * @since 2.4.5
&nbsp;	 */
&nbsp;	public void addBootstrapRegistryInitializer(BootstrapRegistryInitializer bootstrapRegistryInitializer) {
<b class="nc">&nbsp;		Assert.notNull(bootstrapRegistryInitializer, &quot;BootstrapRegistryInitializer must not be null&quot;);</b>
<b class="nc">&nbsp;		this.bootstrapRegistryInitializers.addAll(Arrays.asList(bootstrapRegistryInitializer));</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Set default environment properties which will be used in addition to those in the
&nbsp;	 * existing {@link Environment}.
&nbsp;	 * @param defaultProperties the additional properties to set
&nbsp;	 */
&nbsp;	public void setDefaultProperties(Map&lt;String, Object&gt; defaultProperties) {
<b class="nc">&nbsp;		this.defaultProperties = defaultProperties;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Convenient alternative to {@link #setDefaultProperties(Map)}.
&nbsp;	 * @param defaultProperties some {@link Properties}
&nbsp;	 */
&nbsp;	public void setDefaultProperties(Properties defaultProperties) {
<b class="nc">&nbsp;		this.defaultProperties = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;		for (Object key : Collections.list(defaultProperties.propertyNames())) {</b>
<b class="nc">&nbsp;			this.defaultProperties.put((String) key, defaultProperties.get(key));</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Set additional profile values to use (on top of those set in system or command line
&nbsp;	 * properties).
&nbsp;	 * @param profiles the additional profiles to set
&nbsp;	 */
&nbsp;	public void setAdditionalProfiles(String... profiles) {
<b class="nc">&nbsp;		this.additionalProfiles = Collections.unmodifiableSet(new LinkedHashSet&lt;&gt;(Arrays.asList(profiles)));</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Return an immutable set of any additional profiles in use.
&nbsp;	 * @return the additional profiles
&nbsp;	 */
&nbsp;	public Set&lt;String&gt; getAdditionalProfiles() {
<b class="nc">&nbsp;		return this.additionalProfiles;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Sets the bean name generator that should be used when generating bean names.
&nbsp;	 * @param beanNameGenerator the bean name generator
&nbsp;	 */
&nbsp;	public void setBeanNameGenerator(BeanNameGenerator beanNameGenerator) {
<b class="nc">&nbsp;		this.beanNameGenerator = beanNameGenerator;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Sets the underlying environment that should be used with the created application
&nbsp;	 * context.
&nbsp;	 * @param environment the environment
&nbsp;	 */
&nbsp;	public void setEnvironment(ConfigurableEnvironment environment) {
<b class="nc">&nbsp;		this.isCustomEnvironment = true;</b>
<b class="nc">&nbsp;		this.environment = environment;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Add additional items to the primary sources that will be added to an
&nbsp;	 * ApplicationContext when {@link #run(String...)} is called.
&nbsp;	 * &lt;p&gt;
&nbsp;	 * The sources here are added to those that were set in the constructor. Most users
&nbsp;	 * should consider using {@link #getSources()}/{@link #setSources(Set)} rather than
&nbsp;	 * calling this method.
&nbsp;	 * @param additionalPrimarySources the additional primary sources to add
&nbsp;	 * @see #SpringApplication(Class...)
&nbsp;	 * @see #getSources()
&nbsp;	 * @see #setSources(Set)
&nbsp;	 * @see #getAllSources()
&nbsp;	 */
&nbsp;	public void addPrimarySources(Collection&lt;Class&lt;?&gt;&gt; additionalPrimarySources) {
<b class="nc">&nbsp;		this.primarySources.addAll(additionalPrimarySources);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns a mutable set of the sources that will be added to an ApplicationContext
&nbsp;	 * when {@link #run(String...)} is called.
&nbsp;	 * &lt;p&gt;
&nbsp;	 * Sources set here will be used in addition to any primary sources set in the
&nbsp;	 * constructor.
&nbsp;	 * @return the application sources.
&nbsp;	 * @see #SpringApplication(Class...)
&nbsp;	 * @see #getAllSources()
&nbsp;	 */
&nbsp;	public Set&lt;String&gt; getSources() {
<b class="nc">&nbsp;		return this.sources;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Set additional sources that will be used to create an ApplicationContext. A source
&nbsp;	 * can be: a class name, package name, or an XML resource location.
&nbsp;	 * &lt;p&gt;
&nbsp;	 * Sources set here will be used in addition to any primary sources set in the
&nbsp;	 * constructor.
&nbsp;	 * @param sources the application sources to set
&nbsp;	 * @see #SpringApplication(Class...)
&nbsp;	 * @see #getAllSources()
&nbsp;	 */
&nbsp;	public void setSources(Set&lt;String&gt; sources) {
<b class="nc">&nbsp;		Assert.notNull(sources, &quot;Sources must not be null&quot;);</b>
<b class="nc">&nbsp;		this.sources = new LinkedHashSet&lt;&gt;(sources);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Return an immutable set of all the sources that will be added to an
&nbsp;	 * ApplicationContext when {@link #run(String...)} is called. This method combines any
&nbsp;	 * primary sources specified in the constructor with any additional ones that have
&nbsp;	 * been {@link #setSources(Set) explicitly set}.
&nbsp;	 * @return an immutable set of all sources
&nbsp;	 */
&nbsp;	public Set&lt;Object&gt; getAllSources() {
<b class="nc">&nbsp;		Set&lt;Object&gt; allSources = new LinkedHashSet&lt;&gt;();</b>
<b class="nc">&nbsp;		if (!CollectionUtils.isEmpty(this.primarySources)) {</b>
<b class="nc">&nbsp;			allSources.addAll(this.primarySources);</b>
&nbsp;		}
<b class="nc">&nbsp;		if (!CollectionUtils.isEmpty(this.sources)) {</b>
<b class="nc">&nbsp;			allSources.addAll(this.sources);</b>
&nbsp;		}
<b class="nc">&nbsp;		return Collections.unmodifiableSet(allSources);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Sets the {@link ResourceLoader} that should be used when loading resources.
&nbsp;	 * @param resourceLoader the resource loader
&nbsp;	 */
&nbsp;	public void setResourceLoader(ResourceLoader resourceLoader) {
<b class="nc">&nbsp;		Assert.notNull(resourceLoader, &quot;ResourceLoader must not be null&quot;);</b>
<b class="nc">&nbsp;		this.resourceLoader = resourceLoader;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Return a prefix that should be applied when obtaining configuration properties from
&nbsp;	 * the system environment.
&nbsp;	 * @return the environment property prefix
&nbsp;	 * @since 2.5.0
&nbsp;	 */
&nbsp;	public String getEnvironmentPrefix() {
<b class="nc">&nbsp;		return this.environmentPrefix;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Set the prefix that should be applied when obtaining configuration properties from
&nbsp;	 * the system environment.
&nbsp;	 * @param environmentPrefix the environment property prefix to set
&nbsp;	 * @since 2.5.0
&nbsp;	 */
&nbsp;	public void setEnvironmentPrefix(String environmentPrefix) {
<b class="nc">&nbsp;		this.environmentPrefix = environmentPrefix;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Sets the factory that will be called to create the application context. If not set,
&nbsp;	 * defaults to a factory that will create
&nbsp;	 * {@link AnnotationConfigServletWebServerApplicationContext} for servlet web
&nbsp;	 * applications, {@link AnnotationConfigReactiveWebServerApplicationContext} for
&nbsp;	 * reactive web applications, and {@link AnnotationConfigApplicationContext} for
&nbsp;	 * non-web applications.
&nbsp;	 * @param applicationContextFactory the factory for the context
&nbsp;	 * @since 2.4.0
&nbsp;	 */
&nbsp;	public void setApplicationContextFactory(ApplicationContextFactory applicationContextFactory) {
<b class="nc">&nbsp;		this.applicationContextFactory = (applicationContextFactory != null) ? applicationContextFactory</b>
<b class="nc">&nbsp;				: ApplicationContextFactory.DEFAULT;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Sets the {@link ApplicationContextInitializer} that will be applied to the Spring
&nbsp;	 * {@link ApplicationContext}.
&nbsp;	 * @param initializers the initializers to set
&nbsp;	 */
&nbsp;	public void setInitializers(Collection&lt;? extends ApplicationContextInitializer&lt;?&gt;&gt; initializers) {
<b class="nc">&nbsp;		this.initializers = new ArrayList&lt;&gt;(initializers);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Add {@link ApplicationContextInitializer}s to be applied to the Spring
&nbsp;	 * {@link ApplicationContext}.
&nbsp;	 * @param initializers the initializers to add
&nbsp;	 */
&nbsp;	public void addInitializers(ApplicationContextInitializer&lt;?&gt;... initializers) {
<b class="nc">&nbsp;		this.initializers.addAll(Arrays.asList(initializers));</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns read-only ordered Set of the {@link ApplicationContextInitializer}s that
&nbsp;	 * will be applied to the Spring {@link ApplicationContext}.
&nbsp;	 * @return the initializers
&nbsp;	 */
&nbsp;	public Set&lt;ApplicationContextInitializer&lt;?&gt;&gt; getInitializers() {
<b class="nc">&nbsp;		return asUnmodifiableOrderedSet(this.initializers);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Sets the {@link ApplicationListener}s that will be applied to the SpringApplication
&nbsp;	 * and registered with the {@link ApplicationContext}.
&nbsp;	 * @param listeners the listeners to set
&nbsp;	 */
&nbsp;	public void setListeners(Collection&lt;? extends ApplicationListener&lt;?&gt;&gt; listeners) {
<b class="nc">&nbsp;		this.listeners = new ArrayList&lt;&gt;(listeners);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Add {@link ApplicationListener}s to be applied to the SpringApplication and
&nbsp;	 * registered with the {@link ApplicationContext}.
&nbsp;	 * @param listeners the listeners to add
&nbsp;	 */
&nbsp;	public void addListeners(ApplicationListener&lt;?&gt;... listeners) {
<b class="nc">&nbsp;		this.listeners.addAll(Arrays.asList(listeners));</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns read-only ordered Set of the {@link ApplicationListener}s that will be
&nbsp;	 * applied to the SpringApplication and registered with the {@link ApplicationContext}
&nbsp;	 * .
&nbsp;	 * @return the listeners
&nbsp;	 */
&nbsp;	public Set&lt;ApplicationListener&lt;?&gt;&gt; getListeners() {
<b class="nc">&nbsp;		return asUnmodifiableOrderedSet(this.listeners);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Set the {@link ApplicationStartup} to use for collecting startup metrics.
&nbsp;	 * @param applicationStartup the application startup to use
&nbsp;	 * @since 2.4.0
&nbsp;	 */
&nbsp;	public void setApplicationStartup(ApplicationStartup applicationStartup) {
<b class="nc">&nbsp;		this.applicationStartup = (applicationStartup != null) ? applicationStartup : ApplicationStartup.DEFAULT;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns the {@link ApplicationStartup} used for collecting startup metrics.
&nbsp;	 * @return the application startup
&nbsp;	 * @since 2.4.0
&nbsp;	 */
&nbsp;	public ApplicationStartup getApplicationStartup() {
<b class="nc">&nbsp;		return this.applicationStartup;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Whether to keep the application alive even if there are no more non-daemon threads.
&nbsp;	 * @return whether to keep the application alive even if there are no more non-daemon
&nbsp;	 * threads
&nbsp;	 * @since 3.2.0
&nbsp;	 */
&nbsp;	public boolean isKeepAlive() {
<b class="nc">&nbsp;		return this.keepAlive;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Set whether to keep the application alive even if there are no more non-daemon
&nbsp;	 * threads.
&nbsp;	 * @param keepAlive whether to keep the application alive even if there are no more
&nbsp;	 * non-daemon threads
&nbsp;	 * @since 3.2.0
&nbsp;	 */
&nbsp;	public void setKeepAlive(boolean keepAlive) {
<b class="nc">&nbsp;		this.keepAlive = keepAlive;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Return a {@link SpringApplicationShutdownHandlers} instance that can be used to add
&nbsp;	 * or remove handlers that perform actions before the JVM is shutdown.
&nbsp;	 * @return a {@link SpringApplicationShutdownHandlers} instance
&nbsp;	 * @since 2.5.1
&nbsp;	 */
&nbsp;	public static SpringApplicationShutdownHandlers getShutdownHandlers() {
<b class="nc">&nbsp;		return shutdownHook.getHandlers();</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Static helper that can be used to run a {@link SpringApplication} from the
&nbsp;	 * specified source using default settings.
&nbsp;	 * @param primarySource the primary source to load
&nbsp;	 * @param args the application arguments (usually passed from a Java main method)
&nbsp;	 * @return the running {@link ApplicationContext}
&nbsp;	 */
&nbsp;	public static ConfigurableApplicationContext run(Class&lt;?&gt; primarySource, String... args) {
<b class="nc">&nbsp;		return run(new Class&lt;?&gt;[] { primarySource }, args);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Static helper that can be used to run a {@link SpringApplication} from the
&nbsp;	 * specified sources using default settings and user supplied arguments.
&nbsp;	 * @param primarySources the primary sources to load
&nbsp;	 * @param args the application arguments (usually passed from a Java main method)
&nbsp;	 * @return the running {@link ApplicationContext}
&nbsp;	 */
&nbsp;	public static ConfigurableApplicationContext run(Class&lt;?&gt;[] primarySources, String[] args) {
<b class="nc">&nbsp;		return new SpringApplication(primarySources).run(args);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * A basic main that can be used to launch an application. This method is useful when
&nbsp;	 * application sources are defined through a {@literal --spring.main.sources} command
&nbsp;	 * line argument.
&nbsp;	 * &lt;p&gt;
&nbsp;	 * Most developers will want to define their own main method and call the
&nbsp;	 * {@link #run(Class, String...) run} method instead.
&nbsp;	 * @param args command line arguments
&nbsp;	 * @throws Exception if the application cannot be started
&nbsp;	 * @see SpringApplication#run(Class[], String[])
&nbsp;	 * @see SpringApplication#run(Class, String...)
&nbsp;	 */
&nbsp;	public static void main(String[] args) throws Exception {
<b class="nc">&nbsp;		SpringApplication.run(new Class&lt;?&gt;[0], args);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Static helper that can be used to exit a {@link SpringApplication} and obtain a
&nbsp;	 * code indicating success (0) or otherwise. Does not throw exceptions but should
&nbsp;	 * print stack traces of any encountered. Applies the specified
&nbsp;	 * {@link ExitCodeGenerator ExitCodeGenerators} in addition to any Spring beans that
&nbsp;	 * implement {@link ExitCodeGenerator}. When multiple generators are available, the
&nbsp;	 * first non-zero exit code is used. Generators are ordered based on their
&nbsp;	 * {@link Ordered} implementation and {@link Order @Order} annotation.
&nbsp;	 * @param context the context to close if possible
&nbsp;	 * @param exitCodeGenerators exit code generators
&nbsp;	 * @return the outcome (0 if successful)
&nbsp;	 */
&nbsp;	public static int exit(ApplicationContext context, ExitCodeGenerator... exitCodeGenerators) {
<b class="nc">&nbsp;		Assert.notNull(context, &quot;Context must not be null&quot;);</b>
<b class="nc">&nbsp;		int exitCode = 0;</b>
&nbsp;		try {
&nbsp;			try {
<b class="nc">&nbsp;				ExitCodeGenerators generators = new ExitCodeGenerators();</b>
<b class="nc">&nbsp;				Collection&lt;ExitCodeGenerator&gt; beans = context.getBeansOfType(ExitCodeGenerator.class).values();</b>
<b class="nc">&nbsp;				generators.addAll(exitCodeGenerators);</b>
<b class="nc">&nbsp;				generators.addAll(beans);</b>
<b class="nc">&nbsp;				exitCode = generators.getExitCode();</b>
<b class="nc">&nbsp;				if (exitCode != 0) {</b>
<b class="nc">&nbsp;					context.publishEvent(new ExitCodeEvent(context, exitCode));</b>
&nbsp;				}
&nbsp;			}
&nbsp;			finally {
<b class="nc">&nbsp;				close(context);</b>
<b class="nc">&nbsp;			}</b>
&nbsp;		}
<b class="nc">&nbsp;		catch (Exception ex) {</b>
<b class="nc">&nbsp;			ex.printStackTrace();</b>
<b class="nc">&nbsp;			exitCode = (exitCode != 0) ? exitCode : 1;</b>
<b class="nc">&nbsp;		}</b>
<b class="nc">&nbsp;		return exitCode;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Create an application from an existing {@code main} method that can run with
&nbsp;	 * additional {@code @Configuration} or bean classes. This method can be helpful when
&nbsp;	 * writing a test harness that needs to start an application with additional
&nbsp;	 * configuration.
&nbsp;	 * @param main the main method entry point that runs the {@link SpringApplication}
&nbsp;	 * @return a {@link SpringApplication.Augmented} instance that can be used to add
&nbsp;	 * configuration and run the application
&nbsp;	 * @since 3.1.0
&nbsp;	 * @see #withHook(SpringApplicationHook, Runnable)
&nbsp;	 */
&nbsp;	public static SpringApplication.Augmented from(ThrowingConsumer&lt;String[]&gt; main) {
<b class="nc">&nbsp;		Assert.notNull(main, &quot;Main must not be null&quot;);</b>
<b class="nc">&nbsp;		return new Augmented(main, Collections.emptySet());</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Perform the given action with the given {@link SpringApplicationHook} attached if
&nbsp;	 * the action triggers an {@link SpringApplication#run(String...) application run}.
&nbsp;	 * @param hook the hook to apply
&nbsp;	 * @param action the action to run
&nbsp;	 * @since 3.0.0
&nbsp;	 * @see #withHook(SpringApplicationHook, ThrowingSupplier)
&nbsp;	 */
&nbsp;	public static void withHook(SpringApplicationHook hook, Runnable action) {
<b class="nc">&nbsp;		withHook(hook, () -&gt; {</b>
<b class="nc">&nbsp;			action.run();</b>
<b class="nc">&nbsp;			return null;</b>
&nbsp;		});
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Perform the given action with the given {@link SpringApplicationHook} attached if
&nbsp;	 * the action triggers an {@link SpringApplication#run(String...) application run}.
&nbsp;	 * @param &lt;T&gt; the result type
&nbsp;	 * @param hook the hook to apply
&nbsp;	 * @param action the action to run
&nbsp;	 * @return the result of the action
&nbsp;	 * @since 3.0.0
&nbsp;	 * @see #withHook(SpringApplicationHook, Runnable)
&nbsp;	 */
&nbsp;	public static &lt;T&gt; T withHook(SpringApplicationHook hook, ThrowingSupplier&lt;T&gt; action) {
<b class="nc">&nbsp;		applicationHook.set(hook);</b>
&nbsp;		try {
<b class="nc">&nbsp;			return action.get();</b>
&nbsp;		}
&nbsp;		finally {
<b class="nc">&nbsp;			applicationHook.remove();</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	private static void close(ApplicationContext context) {
<b class="nc">&nbsp;		if (context instanceof ConfigurableApplicationContext closable) {</b>
<b class="nc">&nbsp;			closable.close();</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private static &lt;E&gt; Set&lt;E&gt; asUnmodifiableOrderedSet(Collection&lt;E&gt; elements) {
<b class="nc">&nbsp;		List&lt;E&gt; list = new ArrayList&lt;&gt;(elements);</b>
<b class="nc">&nbsp;		list.sort(AnnotationAwareOrderComparator.INSTANCE);</b>
<b class="nc">&nbsp;		return new LinkedHashSet&lt;&gt;(list);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Used to configure and run an augmented {@link SpringApplication} where additional
&nbsp;	 * configuration should be applied.
&nbsp;	 *
&nbsp;	 * @since 3.1.0
&nbsp;	 */
&nbsp;	public static class Augmented {
&nbsp;
&nbsp;		private final ThrowingConsumer&lt;String[]&gt; main;
&nbsp;
&nbsp;		private final Set&lt;Class&lt;?&gt;&gt; sources;
&nbsp;
<b class="nc">&nbsp;		Augmented(ThrowingConsumer&lt;String[]&gt; main, Set&lt;Class&lt;?&gt;&gt; sources) {</b>
<b class="nc">&nbsp;			this.main = main;</b>
<b class="nc">&nbsp;			this.sources = Set.copyOf(sources);</b>
&nbsp;		}
&nbsp;
&nbsp;		/**
&nbsp;		 * Return a new {@link SpringApplication.Augmented} instance with additional
&nbsp;		 * sources that should be applied when the application runs.
&nbsp;		 * @param sources the sources that should be applied
&nbsp;		 * @return a new {@link SpringApplication.Augmented} instance
&nbsp;		 */
&nbsp;		public Augmented with(Class&lt;?&gt;... sources) {
<b class="nc">&nbsp;			LinkedHashSet&lt;Class&lt;?&gt;&gt; merged = new LinkedHashSet&lt;&gt;(this.sources);</b>
<b class="nc">&nbsp;			merged.addAll(Arrays.asList(sources));</b>
<b class="nc">&nbsp;			return new Augmented(this.main, merged);</b>
&nbsp;		}
&nbsp;
&nbsp;		/**
&nbsp;		 * Run the application using the given args.
&nbsp;		 * @param args the main method args
&nbsp;		 * @return the running {@link ApplicationContext}
&nbsp;		 */
&nbsp;		public SpringApplication.Running run(String... args) {
<b class="nc">&nbsp;			RunListener runListener = new RunListener();</b>
<b class="nc">&nbsp;			SpringApplicationHook hook = new SingleUseSpringApplicationHook((springApplication) -&gt; {</b>
<b class="nc">&nbsp;				springApplication.addPrimarySources(this.sources);</b>
<b class="nc">&nbsp;				return runListener;</b>
&nbsp;			});
<b class="nc">&nbsp;			withHook(hook, () -&gt; this.main.accept(args));</b>
<b class="nc">&nbsp;			return runListener;</b>
&nbsp;		}
&nbsp;
&nbsp;		/**
&nbsp;		 * {@link SpringApplicationRunListener} to capture {@link Running} application
&nbsp;		 * details.
&nbsp;		 */
<b class="nc">&nbsp;		private static final class RunListener implements SpringApplicationRunListener, Running {</b>
&nbsp;
<b class="nc">&nbsp;			private final List&lt;ConfigurableApplicationContext&gt; contexts = Collections</b>
<b class="nc">&nbsp;				.synchronizedList(new ArrayList&lt;&gt;());</b>
&nbsp;
&nbsp;			@Override
&nbsp;			public void contextLoaded(ConfigurableApplicationContext context) {
<b class="nc">&nbsp;				this.contexts.add(context);</b>
&nbsp;			}
&nbsp;
&nbsp;			@Override
&nbsp;			public ConfigurableApplicationContext getApplicationContext() {
<b class="nc">&nbsp;				List&lt;ConfigurableApplicationContext&gt; rootContexts = this.contexts.stream()</b>
<b class="nc">&nbsp;					.filter((context) -&gt; context.getParent() == null)</b>
<b class="nc">&nbsp;					.toList();</b>
<b class="nc">&nbsp;				Assert.state(!rootContexts.isEmpty(), &quot;No root application context located&quot;);</b>
<b class="nc">&nbsp;				Assert.state(rootContexts.size() == 1, &quot;No unique root application context located&quot;);</b>
<b class="nc">&nbsp;				return rootContexts.get(0);</b>
&nbsp;			}
&nbsp;
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Provides access to details of a {@link SpringApplication} run using
&nbsp;	 * {@link Augmented#run(String...)}.
&nbsp;	 *
&nbsp;	 * @since 3.1.0
&nbsp;	 */
&nbsp;	public interface Running {
&nbsp;
&nbsp;		/**
&nbsp;		 * Return the root {@link ConfigurableApplicationContext} of the running
&nbsp;		 * application.
&nbsp;		 * @return the root application context
&nbsp;		 */
&nbsp;		ConfigurableApplicationContext getApplicationContext();
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * {@link BeanFactoryPostProcessor} to re-order our property sources below any
&nbsp;	 * {@code @PropertySource} items added by the {@link ConfigurationClassPostProcessor}.
&nbsp;	 */
&nbsp;	private static class PropertySourceOrderingBeanFactoryPostProcessor implements BeanFactoryPostProcessor, Ordered {
&nbsp;
&nbsp;		private final ConfigurableApplicationContext context;
&nbsp;
<b class="nc">&nbsp;		PropertySourceOrderingBeanFactoryPostProcessor(ConfigurableApplicationContext context) {</b>
<b class="nc">&nbsp;			this.context = context;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public int getOrder() {
<b class="nc">&nbsp;			return Ordered.HIGHEST_PRECEDENCE;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
<b class="nc">&nbsp;			DefaultPropertiesPropertySource.moveToEnd(this.context.getEnvironment());</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	static class SpringApplicationRuntimeHints extends BindableRuntimeHintsRegistrar {
&nbsp;
&nbsp;		SpringApplicationRuntimeHints() {
<b class="nc">&nbsp;			super(SpringApplication.class);</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Exception that can be thrown to silently exit a running {@link SpringApplication}
&nbsp;	 * without handling run failures.
&nbsp;	 *
&nbsp;	 * @since 3.0.0
&nbsp;	 */
&nbsp;	public static class AbandonedRunException extends RuntimeException {
&nbsp;
&nbsp;		private final ConfigurableApplicationContext applicationContext;
&nbsp;
&nbsp;		/**
&nbsp;		 * Create a new {@link AbandonedRunException} instance.
&nbsp;		 */
&nbsp;		public AbandonedRunException() {
<b class="nc">&nbsp;			this(null);</b>
&nbsp;		}
&nbsp;
&nbsp;		/**
&nbsp;		 * Create a new {@link AbandonedRunException} instance with the given application
&nbsp;		 * context.
&nbsp;		 * @param applicationContext the application context that was available when the
&nbsp;		 * run was abandoned
&nbsp;		 */
<b class="nc">&nbsp;		public AbandonedRunException(ConfigurableApplicationContext applicationContext) {</b>
<b class="nc">&nbsp;			this.applicationContext = applicationContext;</b>
&nbsp;		}
&nbsp;
&nbsp;		/**
&nbsp;		 * Return the application context that was available when the run was abandoned or
&nbsp;		 * {@code null} if no context was available.
&nbsp;		 * @return the application context
&nbsp;		 */
&nbsp;		public ConfigurableApplicationContext getApplicationContext() {
<b class="nc">&nbsp;			return this.applicationContext;</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * {@link SpringApplicationHook} decorator that ensures the hook is only used once.
&nbsp;	 */
&nbsp;	private static final class SingleUseSpringApplicationHook implements SpringApplicationHook {
&nbsp;
<b class="nc">&nbsp;		private final AtomicBoolean used = new AtomicBoolean();</b>
&nbsp;
&nbsp;		private final SpringApplicationHook delegate;
&nbsp;
<b class="nc">&nbsp;		private SingleUseSpringApplicationHook(SpringApplicationHook delegate) {</b>
<b class="nc">&nbsp;			this.delegate = delegate;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public SpringApplicationRunListener getRunListener(SpringApplication springApplication) {
<b class="nc">&nbsp;			return this.used.compareAndSet(false, true) ? this.delegate.getRunListener(springApplication) : null;</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Starts a non-daemon thread to keep the JVM alive on {@link ContextRefreshedEvent}.
&nbsp;	 * Stops the thread on {@link ContextClosedEvent}.
&nbsp;	 */
<b class="nc">&nbsp;	private static final class KeepAlive implements ApplicationListener&lt;ApplicationContextEvent&gt; {</b>
&nbsp;
<b class="nc">&nbsp;		private final AtomicReference&lt;Thread&gt; thread = new AtomicReference&lt;&gt;();</b>
&nbsp;
&nbsp;		@Override
&nbsp;		public void onApplicationEvent(ApplicationContextEvent event) {
<b class="nc">&nbsp;			if (event instanceof ContextRefreshedEvent) {</b>
<b class="nc">&nbsp;				startKeepAliveThread();</b>
&nbsp;			}
<b class="nc">&nbsp;			else if (event instanceof ContextClosedEvent) {</b>
<b class="nc">&nbsp;				stopKeepAliveThread();</b>
&nbsp;			}
&nbsp;		}
&nbsp;
&nbsp;		private void startKeepAliveThread() {
<b class="nc">&nbsp;			Thread thread = new Thread(() -&gt; {</b>
&nbsp;				while (true) {
&nbsp;					try {
<b class="nc">&nbsp;						Thread.sleep(Long.MAX_VALUE);</b>
&nbsp;					}
<b class="nc">&nbsp;					catch (InterruptedException ex) {</b>
<b class="nc">&nbsp;						break;</b>
<b class="nc">&nbsp;					}</b>
&nbsp;				}
&nbsp;			});
<b class="nc">&nbsp;			if (this.thread.compareAndSet(null, thread)) {</b>
<b class="nc">&nbsp;				thread.setDaemon(false);</b>
<b class="nc">&nbsp;				thread.setName(&quot;keep-alive&quot;);</b>
<b class="nc">&nbsp;				thread.start();</b>
&nbsp;			}
&nbsp;		}
&nbsp;
&nbsp;		private void stopKeepAliveThread() {
<b class="nc">&nbsp;			Thread thread = this.thread.getAndSet(null);</b>
<b class="nc">&nbsp;			if (thread == null) {</b>
&nbsp;				return;
&nbsp;			}
<b class="nc">&nbsp;			thread.interrupt();</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Strategy used to handle startup concerns.
&nbsp;	 */
<b class="nc">&nbsp;	abstract static class Startup {</b>
&nbsp;
&nbsp;		private Duration timeTakenToStarted;
&nbsp;
&nbsp;		protected abstract long startTime();
&nbsp;
&nbsp;		protected abstract Long processUptime();
&nbsp;
&nbsp;		protected abstract String action();
&nbsp;
&nbsp;		final Duration started() {
<b class="nc">&nbsp;			long now = System.currentTimeMillis();</b>
<b class="nc">&nbsp;			this.timeTakenToStarted = Duration.ofMillis(now - startTime());</b>
<b class="nc">&nbsp;			return this.timeTakenToStarted;</b>
&nbsp;		}
&nbsp;
&nbsp;		Duration timeTakenToStarted() {
<b class="nc">&nbsp;			return this.timeTakenToStarted;</b>
&nbsp;		}
&nbsp;
&nbsp;		private Duration ready() {
<b class="nc">&nbsp;			long now = System.currentTimeMillis();</b>
<b class="nc">&nbsp;			return Duration.ofMillis(now - startTime());</b>
&nbsp;		}
&nbsp;
&nbsp;		static Startup create() {
<b class="nc">&nbsp;			ClassLoader classLoader = Startup.class.getClassLoader();</b>
<b class="nc">&nbsp;			return (ClassUtils.isPresent(&quot;jdk.crac.management.CRaCMXBean&quot;, classLoader)</b>
<b class="nc">&nbsp;					&amp;&amp; ClassUtils.isPresent(&quot;org.crac.management.CRaCMXBean&quot;, classLoader))</b>
<b class="nc">&nbsp;							? new CoordinatedRestoreAtCheckpointStartup() : new StandardStartup();</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Standard {@link Startup} implementation.
&nbsp;	 */
<b class="nc">&nbsp;	private static final class StandardStartup extends Startup {</b>
&nbsp;
<b class="nc">&nbsp;		private final Long startTime = System.currentTimeMillis();</b>
&nbsp;
&nbsp;		@Override
&nbsp;		protected long startTime() {
<b class="nc">&nbsp;			return this.startTime;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		protected Long processUptime() {
&nbsp;			try {
<b class="nc">&nbsp;				return ManagementFactory.getRuntimeMXBean().getUptime();</b>
&nbsp;			}
<b class="nc">&nbsp;			catch (Throwable ex) {</b>
<b class="nc">&nbsp;				return null;</b>
&nbsp;			}
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		protected String action() {
<b class="nc">&nbsp;			return &quot;Started&quot;;</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Coordinated-Restore-At-Checkpoint {@link Startup} implementation.
&nbsp;	 */
<b class="nc">&nbsp;	private static final class CoordinatedRestoreAtCheckpointStartup extends Startup {</b>
&nbsp;
<b class="nc">&nbsp;		private final StandardStartup fallback = new StandardStartup();</b>
&nbsp;
&nbsp;		@Override
&nbsp;		protected Long processUptime() {
<b class="nc">&nbsp;			long uptime = CRaCMXBean.getCRaCMXBean().getUptimeSinceRestore();</b>
<b class="nc">&nbsp;			return (uptime &gt;= 0) ? uptime : this.fallback.processUptime();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		protected String action() {
<b class="nc">&nbsp;			return (restoreTime() &gt;= 0) ? &quot;Restored&quot; : this.fallback.action();</b>
&nbsp;		}
&nbsp;
&nbsp;		private long restoreTime() {
<b class="nc">&nbsp;			return CRaCMXBean.getCRaCMXBean().getRestoreTime();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		protected long startTime() {
<b class="nc">&nbsp;			long restoreTime = restoreTime();</b>
<b class="nc">&nbsp;			return (restoreTime &gt;= 0) ? restoreTime : this.fallback.startTime();</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * {@link OrderSourceProvider} used to obtain factory method and target type order
&nbsp;	 * sources. Based on internal {@link DefaultListableBeanFactory} code.
&nbsp;	 */
&nbsp;	private class FactoryAwareOrderSourceProvider implements OrderSourceProvider {
&nbsp;
&nbsp;		private final ConfigurableBeanFactory beanFactory;
&nbsp;
&nbsp;		private final Map&lt;?, String&gt; instancesToBeanNames;
&nbsp;
<b class="nc">&nbsp;		FactoryAwareOrderSourceProvider(ConfigurableBeanFactory beanFactory, Map&lt;?, String&gt; instancesToBeanNames) {</b>
<b class="nc">&nbsp;			this.beanFactory = beanFactory;</b>
<b class="nc">&nbsp;			this.instancesToBeanNames = instancesToBeanNames;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Object getOrderSource(Object obj) {
<b class="nc">&nbsp;			String beanName = this.instancesToBeanNames.get(obj);</b>
<b class="nc">&nbsp;			return (beanName != null) ? getOrderSource(beanName, obj.getClass()) : null;</b>
&nbsp;		}
&nbsp;
&nbsp;		private Object getOrderSource(String beanName, Class&lt;?&gt; instanceType) {
&nbsp;			try {
<b class="nc">&nbsp;				RootBeanDefinition beanDefinition = (RootBeanDefinition) this.beanFactory</b>
<b class="nc">&nbsp;					.getMergedBeanDefinition(beanName);</b>
<b class="nc">&nbsp;				Method factoryMethod = beanDefinition.getResolvedFactoryMethod();</b>
<b class="nc">&nbsp;				Class&lt;?&gt; targetType = beanDefinition.getTargetType();</b>
<b class="nc">&nbsp;				targetType = (targetType != instanceType) ? targetType : null;</b>
<b class="nc">&nbsp;				return Stream.of(factoryMethod, targetType).filter(Objects::nonNull).toArray();</b>
&nbsp;			}
<b class="nc">&nbsp;			catch (NoSuchBeanDefinitionException ex) {</b>
<b class="nc">&nbsp;				return null;</b>
&nbsp;			}
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-28 21:28</div>
</div>
</body>
</html>
