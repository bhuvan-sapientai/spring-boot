


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > JSONTokener</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.springframework.boot.configurationprocessor.json</a>
</div>

<h1>Coverage Summary for Class: JSONTokener (org.springframework.boot.configurationprocessor.json)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">JSONTokener</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/23)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/177)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright (C) 2010 The Android Open Source Project
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *      https://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;
&nbsp;package org.springframework.boot.configurationprocessor.json;
&nbsp;
&nbsp;// Note: this class was written without inspecting the non-free org.json source code.
&nbsp;
&nbsp;/**
&nbsp; * Parses a JSON (&lt;a href=&quot;https://www.ietf.org/rfc/rfc4627.txt&quot;&gt;RFC 4627&lt;/a&gt;) encoded
&nbsp; * string into the corresponding object. Most clients of this class will use only need the
&nbsp; * {@link #JSONTokener(String) constructor} and {@link #nextValue} method. Example usage:
&nbsp; * &lt;pre&gt;
&nbsp; * String json = &quot;{&quot;
&nbsp; *         + &quot;  \&quot;query\&quot;: \&quot;Pizza\&quot;, &quot;
&nbsp; *         + &quot;  \&quot;locations\&quot;: [ 94043, 90210 ] &quot;
&nbsp; *         + &quot;}&quot;;
&nbsp; *
&nbsp; * JSONObject object = (JSONObject) new JSONTokener(json).nextValue();
&nbsp; * String query = object.getString(&quot;query&quot;);
&nbsp; * JSONArray locations = object.getJSONArray(&quot;locations&quot;);&lt;/pre&gt;
&nbsp; * &lt;p&gt;
&nbsp; * For best interoperability and performance use JSON that complies with RFC 4627, such as
&nbsp; * that generated by {@link JSONStringer}. For legacy reasons this parser is lenient, so a
&nbsp; * successful parse does not indicate that the input string was valid JSON. All the
&nbsp; * following syntax errors will be ignored:
&nbsp; * &lt;ul&gt;
&nbsp; * &lt;li&gt;End of line comments starting with {@code //} or {@code #} and ending with a
&nbsp; * newline character.
&nbsp; * &lt;li&gt;C-style comments starting with {@code /*} and ending with {@code *}{@code /}. Such
&nbsp; * comments may not be nested.
&nbsp; * &lt;li&gt;Strings that are unquoted or {@code &#39;single quoted&#39;}.
&nbsp; * &lt;li&gt;Hexadecimal integers prefixed with {@code 0x} or {@code 0X}.
&nbsp; * &lt;li&gt;Octal integers prefixed with {@code 0}.
&nbsp; * &lt;li&gt;Array elements separated by {@code ;}.
&nbsp; * &lt;li&gt;Unnecessary array separators. These are interpreted as if null was the omitted
&nbsp; * value.
&nbsp; * &lt;li&gt;Key-value pairs separated by {@code =} or {@code =&gt;}.
&nbsp; * &lt;li&gt;Key-value pairs separated by {@code ;}.
&nbsp; * &lt;/ul&gt;
&nbsp; * &lt;p&gt;
&nbsp; * Each tokener may be used to parse a single JSON string. Instances of this class are not
&nbsp; * thread safe. Although this class is nonfinal, it was not designed for inheritance and
&nbsp; * should not be subclassed. In particular, self-use by overrideable methods is not
&nbsp; * specified. See &lt;i&gt;Effective Java&lt;/i&gt; Item 17, &quot;Design and Document or inheritance or
&nbsp; * else prohibit it&quot; for further information.
&nbsp; */
&nbsp;public class JSONTokener {
&nbsp;
&nbsp;	/**
&nbsp;	 * The input JSON.
&nbsp;	 */
&nbsp;	private final String in;
&nbsp;
&nbsp;	/**
&nbsp;	 * The index of the next character to be returned by {@link #next}. When the input is
&nbsp;	 * exhausted, this equals the input&#39;s length.
&nbsp;	 */
&nbsp;	private int pos;
&nbsp;
&nbsp;	/**
&nbsp;	 * @param in JSON encoded string. Null is not permitted and will yield a tokener that
&nbsp;	 * throws {@code NullPointerExceptions} when methods are called.
&nbsp;	 */
<b class="nc">&nbsp;	public JSONTokener(String in) {</b>
&nbsp;		// consume an optional byte order mark (BOM) if it exists
<b class="nc">&nbsp;		if (in != null &amp;&amp; in.startsWith(&quot;\ufeff&quot;)) {</b>
<b class="nc">&nbsp;			in = in.substring(1);</b>
&nbsp;		}
<b class="nc">&nbsp;		this.in = in;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns the next value from the input.
&nbsp;	 * @return a {@link JSONObject}, {@link JSONArray}, String, Boolean, Integer, Long,
&nbsp;	 * Double or {@link JSONObject#NULL}.
&nbsp;	 * @throws JSONException if the input is malformed.
&nbsp;	 */
&nbsp;	public Object nextValue() throws JSONException {
<b class="nc">&nbsp;		int c = nextCleanInternal();</b>
<b class="nc">&nbsp;		switch (c) {</b>
&nbsp;			case -1:
<b class="nc">&nbsp;				throw syntaxError(&quot;End of input&quot;);</b>
&nbsp;
&nbsp;			case &#39;{&#39;:
<b class="nc">&nbsp;				return readObject();</b>
&nbsp;
&nbsp;			case &#39;[&#39;:
<b class="nc">&nbsp;				return readArray();</b>
&nbsp;
&nbsp;			case &#39;\&#39;&#39;, &#39;&quot;&#39;:
<b class="nc">&nbsp;				return nextString((char) c);</b>
&nbsp;
&nbsp;			default:
<b class="nc">&nbsp;				this.pos--;</b>
<b class="nc">&nbsp;				return readLiteral();</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private int nextCleanInternal() throws JSONException {
<b class="nc">&nbsp;		while (this.pos &lt; this.in.length()) {</b>
<b class="nc">&nbsp;			int c = this.in.charAt(this.pos++);</b>
<b class="nc">&nbsp;			switch (c) {</b>
&nbsp;				case &#39;\t&#39;, &#39; &#39;, &#39;\n&#39;, &#39;\r&#39;:
<b class="nc">&nbsp;					continue;</b>
&nbsp;
&nbsp;				case &#39;/&#39;:
<b class="nc">&nbsp;					if (this.pos == this.in.length()) {</b>
<b class="nc">&nbsp;						return c;</b>
&nbsp;					}
&nbsp;
<b class="nc">&nbsp;					char peek = this.in.charAt(this.pos);</b>
<b class="nc">&nbsp;					switch (peek) {</b>
&nbsp;						case &#39;*&#39;:
&nbsp;							// skip a /* c-style comment */
<b class="nc">&nbsp;							this.pos++;</b>
<b class="nc">&nbsp;							int commentEnd = this.in.indexOf(&quot;*/&quot;, this.pos);</b>
<b class="nc">&nbsp;							if (commentEnd == -1) {</b>
<b class="nc">&nbsp;								throw syntaxError(&quot;Unterminated comment&quot;);</b>
&nbsp;							}
<b class="nc">&nbsp;							this.pos = commentEnd + 2;</b>
<b class="nc">&nbsp;							continue;</b>
&nbsp;
&nbsp;						case &#39;/&#39;:
&nbsp;							// skip a // end-of-line comment
<b class="nc">&nbsp;							this.pos++;</b>
<b class="nc">&nbsp;							skipToEndOfLine();</b>
<b class="nc">&nbsp;							continue;</b>
&nbsp;
&nbsp;						default:
<b class="nc">&nbsp;							return c;</b>
&nbsp;					}
&nbsp;
&nbsp;				case &#39;#&#39;:
&nbsp;					/*
&nbsp;					 * Skip a # hash end-of-line comment. The JSON RFC doesn&#39;t specify
&nbsp;					 * this behavior, but it&#39;s required to parse existing documents. See
&nbsp;					 * https://b/2571423.
&nbsp;					 */
<b class="nc">&nbsp;					skipToEndOfLine();</b>
<b class="nc">&nbsp;					continue;</b>
&nbsp;
&nbsp;				default:
<b class="nc">&nbsp;					return c;</b>
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		return -1;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Advances the position until after the next newline character. If the line is
&nbsp;	 * terminated by &quot;\r\n&quot;, the &#39;\n&#39; must be consumed as whitespace by the caller.
&nbsp;	 */
&nbsp;	private void skipToEndOfLine() {
<b class="nc">&nbsp;		for (; this.pos &lt; this.in.length(); this.pos++) {</b>
<b class="nc">&nbsp;			char c = this.in.charAt(this.pos);</b>
<b class="nc">&nbsp;			if (c == &#39;\r&#39; || c == &#39;\n&#39;) {</b>
<b class="nc">&nbsp;				this.pos++;</b>
<b class="nc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns the string up to but not including {@code quote}, unescaping any character
&nbsp;	 * escape sequences encountered along the way. The opening quote should have already
&nbsp;	 * been read. This consumes the closing quote, but does not include it in the returned
&nbsp;	 * string.
&nbsp;	 * @param quote either &#39; or &quot;.
&nbsp;	 * @return the string up to but not including {@code quote}
&nbsp;	 * @throws NumberFormatException if any unicode escape sequences are malformed.
&nbsp;	 * @throws JSONException if processing of json failed
&nbsp;	 */
&nbsp;	public String nextString(char quote) throws JSONException {
&nbsp;		/*
&nbsp;		 * For strings that are free of escape sequences, we can just extract the result
&nbsp;		 * as a substring of the input. But if we encounter an escape sequence, we need to
&nbsp;		 * use a StringBuilder to compose the result.
&nbsp;		 */
<b class="nc">&nbsp;		StringBuilder builder = null;</b>
&nbsp;
&nbsp;		/* the index of the first character not yet appended to the builder. */
<b class="nc">&nbsp;		int start = this.pos;</b>
&nbsp;
<b class="nc">&nbsp;		while (this.pos &lt; this.in.length()) {</b>
<b class="nc">&nbsp;			int c = this.in.charAt(this.pos++);</b>
<b class="nc">&nbsp;			if (c == quote) {</b>
<b class="nc">&nbsp;				if (builder == null) {</b>
&nbsp;					// a new string avoids leaking memory
<b class="nc">&nbsp;					return new String(this.in.substring(start, this.pos - 1));</b>
&nbsp;				}
&nbsp;				else {
<b class="nc">&nbsp;					builder.append(this.in, start, this.pos - 1);</b>
<b class="nc">&nbsp;					return builder.toString();</b>
&nbsp;				}
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			if (c == &#39;\\&#39;) {</b>
<b class="nc">&nbsp;				if (this.pos == this.in.length()) {</b>
<b class="nc">&nbsp;					throw syntaxError(&quot;Unterminated escape sequence&quot;);</b>
&nbsp;				}
<b class="nc">&nbsp;				if (builder == null) {</b>
<b class="nc">&nbsp;					builder = new StringBuilder();</b>
&nbsp;				}
<b class="nc">&nbsp;				builder.append(this.in, start, this.pos - 1);</b>
<b class="nc">&nbsp;				builder.append(readEscapeCharacter());</b>
<b class="nc">&nbsp;				start = this.pos;</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;
<b class="nc">&nbsp;		throw syntaxError(&quot;Unterminated string&quot;);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Unescapes the character identified by the character or characters that immediately
&nbsp;	 * follow a backslash. The backslash &#39;\&#39; should have already been read. This supports
&nbsp;	 * both unicode escapes &quot;u000A&quot; and two-character escapes &quot;\n&quot;.
&nbsp;	 * @return the unescaped char
&nbsp;	 * @throws NumberFormatException if any unicode escape sequences are malformed.
&nbsp;	 * @throws JSONException if processing of json failed
&nbsp;	 */
&nbsp;	private char readEscapeCharacter() throws JSONException {
<b class="nc">&nbsp;		char escaped = this.in.charAt(this.pos++);</b>
<b class="nc">&nbsp;		switch (escaped) {</b>
&nbsp;			case &#39;u&#39;:
<b class="nc">&nbsp;				if (this.pos + 4 &gt; this.in.length()) {</b>
<b class="nc">&nbsp;					throw syntaxError(&quot;Unterminated escape sequence&quot;);</b>
&nbsp;				}
<b class="nc">&nbsp;				String hex = this.in.substring(this.pos, this.pos + 4);</b>
<b class="nc">&nbsp;				this.pos += 4;</b>
<b class="nc">&nbsp;				return (char) Integer.parseInt(hex, 16);</b>
&nbsp;
&nbsp;			case &#39;t&#39;:
<b class="nc">&nbsp;				return &#39;\t&#39;;</b>
&nbsp;
&nbsp;			case &#39;b&#39;:
<b class="nc">&nbsp;				return &#39;\b&#39;;</b>
&nbsp;
&nbsp;			case &#39;n&#39;:
<b class="nc">&nbsp;				return &#39;\n&#39;;</b>
&nbsp;
&nbsp;			case &#39;r&#39;:
<b class="nc">&nbsp;				return &#39;\r&#39;;</b>
&nbsp;
&nbsp;			case &#39;f&#39;:
<b class="nc">&nbsp;				return &#39;\f&#39;;</b>
&nbsp;
&nbsp;			case &#39;\&#39;&#39;, &#39;&quot;&#39;, &#39;\\&#39;:
&nbsp;			default:
<b class="nc">&nbsp;				return escaped;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Reads a null, boolean, numeric or unquoted string literal value. Numeric values
&nbsp;	 * will be returned as an Integer, Long, or Double, in that order of preference.
&nbsp;	 * @return a literal value
&nbsp;	 * @throws JSONException if processing of json failed
&nbsp;	 */
&nbsp;	private Object readLiteral() throws JSONException {
<b class="nc">&nbsp;		String literal = nextToInternal(&quot;{}[]/\\:,=;# \t\f&quot;);</b>
&nbsp;
<b class="nc">&nbsp;		if (literal.isEmpty()) {</b>
<b class="nc">&nbsp;			throw syntaxError(&quot;Expected literal value&quot;);</b>
&nbsp;		}
<b class="nc">&nbsp;		else if (&quot;null&quot;.equalsIgnoreCase(literal)) {</b>
<b class="nc">&nbsp;			return JSONObject.NULL;</b>
&nbsp;		}
<b class="nc">&nbsp;		else if (&quot;true&quot;.equalsIgnoreCase(literal)) {</b>
<b class="nc">&nbsp;			return Boolean.TRUE;</b>
&nbsp;		}
<b class="nc">&nbsp;		else if (&quot;false&quot;.equalsIgnoreCase(literal)) {</b>
<b class="nc">&nbsp;			return Boolean.FALSE;</b>
&nbsp;		}
&nbsp;
&nbsp;		/* try to parse as an integral type... */
<b class="nc">&nbsp;		if (literal.indexOf(&#39;.&#39;) == -1) {</b>
<b class="nc">&nbsp;			int base = 10;</b>
<b class="nc">&nbsp;			String number = literal;</b>
<b class="nc">&nbsp;			if (number.startsWith(&quot;0x&quot;) || number.startsWith(&quot;0X&quot;)) {</b>
<b class="nc">&nbsp;				number = number.substring(2);</b>
<b class="nc">&nbsp;				base = 16;</b>
&nbsp;			}
<b class="nc">&nbsp;			else if (number.startsWith(&quot;0&quot;) &amp;&amp; number.length() &gt; 1) {</b>
<b class="nc">&nbsp;				number = number.substring(1);</b>
<b class="nc">&nbsp;				base = 8;</b>
&nbsp;			}
&nbsp;			try {
<b class="nc">&nbsp;				long longValue = Long.parseLong(number, base);</b>
<b class="nc">&nbsp;				if (longValue &lt;= Integer.MAX_VALUE &amp;&amp; longValue &gt;= Integer.MIN_VALUE) {</b>
<b class="nc">&nbsp;					return (int) longValue;</b>
&nbsp;				}
&nbsp;				else {
<b class="nc">&nbsp;					return longValue;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			catch (NumberFormatException e) {</b>
&nbsp;				/*
&nbsp;				 * This only happens for integral numbers greater than Long.MAX_VALUE,
&nbsp;				 * numbers in exponential form (5e-10) and unquoted strings. Fall through
&nbsp;				 * to try floating point.
&nbsp;				 */
&nbsp;			}
&nbsp;		}
&nbsp;
&nbsp;		/* ...next try to parse as a floating point... */
&nbsp;		try {
<b class="nc">&nbsp;			return Double.valueOf(literal);</b>
&nbsp;		}
<b class="nc">&nbsp;		catch (NumberFormatException ignored) {</b>
&nbsp;		}
&nbsp;
&nbsp;		/* ... finally give up. We have an unquoted string */
<b class="nc">&nbsp;		return new String(literal); // a new string avoids leaking memory</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns the string up to but not including any of the given characters or a newline
&nbsp;	 * character. This does not consume the excluded character.
&nbsp;	 * @return the string up to but not including any of the given characters or a newline
&nbsp;	 * character
&nbsp;	 */
&nbsp;	private String nextToInternal(String excluded) {
<b class="nc">&nbsp;		int start = this.pos;</b>
<b class="nc">&nbsp;		for (; this.pos &lt; this.in.length(); this.pos++) {</b>
<b class="nc">&nbsp;			char c = this.in.charAt(this.pos);</b>
<b class="nc">&nbsp;			if (c == &#39;\r&#39; || c == &#39;\n&#39; || excluded.indexOf(c) != -1) {</b>
<b class="nc">&nbsp;				return this.in.substring(start, this.pos);</b>
&nbsp;			}
&nbsp;		}
<b class="nc">&nbsp;		return this.in.substring(start);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Reads a sequence of key/value pairs and the trailing closing brace &#39;}&#39; of an
&nbsp;	 * object. The opening brace &#39;{&#39; should have already been read.
&nbsp;	 * @return an object
&nbsp;	 * @throws JSONException if processing of json failed
&nbsp;	 */
&nbsp;	private JSONObject readObject() throws JSONException {
<b class="nc">&nbsp;		JSONObject result = new JSONObject();</b>
&nbsp;
&nbsp;		/* Peek to see if this is the empty object. */
<b class="nc">&nbsp;		int first = nextCleanInternal();</b>
<b class="nc">&nbsp;		if (first == &#39;}&#39;) {</b>
<b class="nc">&nbsp;			return result;</b>
&nbsp;		}
<b class="nc">&nbsp;		else if (first != -1) {</b>
<b class="nc">&nbsp;			this.pos--;</b>
&nbsp;		}
&nbsp;
&nbsp;		while (true) {
<b class="nc">&nbsp;			Object name = nextValue();</b>
<b class="nc">&nbsp;			if (!(name instanceof String)) {</b>
<b class="nc">&nbsp;				if (name == null) {</b>
<b class="nc">&nbsp;					throw syntaxError(&quot;Names cannot be null&quot;);</b>
&nbsp;				}
&nbsp;				else {
<b class="nc">&nbsp;					throw syntaxError(</b>
<b class="nc">&nbsp;							&quot;Names must be strings, but &quot; + name + &quot; is of type &quot; + name.getClass().getName());</b>
&nbsp;				}
&nbsp;			}
&nbsp;
&nbsp;			/*
&nbsp;			 * Expect the name/value separator to be either a colon &#39;:&#39;, an equals sign
&nbsp;			 * &#39;=&#39;, or an arrow &quot;=&gt;&quot;. The last two are bogus but we include them because
&nbsp;			 * that&#39;s what the original implementation did.
&nbsp;			 */
<b class="nc">&nbsp;			int separator = nextCleanInternal();</b>
<b class="nc">&nbsp;			if (separator != &#39;:&#39; &amp;&amp; separator != &#39;=&#39;) {</b>
<b class="nc">&nbsp;				throw syntaxError(&quot;Expected &#39;:&#39; after &quot; + name);</b>
&nbsp;			}
<b class="nc">&nbsp;			if (this.pos &lt; this.in.length() &amp;&amp; this.in.charAt(this.pos) == &#39;&gt;&#39;) {</b>
<b class="nc">&nbsp;				this.pos++;</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			result.put((String) name, nextValue());</b>
&nbsp;
<b class="nc">&nbsp;			switch (nextCleanInternal()) {</b>
&nbsp;				case &#39;}&#39;:
<b class="nc">&nbsp;					return result;</b>
&nbsp;				case &#39;;&#39;, &#39;,&#39;:
<b class="nc">&nbsp;					continue;</b>
&nbsp;				default:
<b class="nc">&nbsp;					throw syntaxError(&quot;Unterminated object&quot;);</b>
&nbsp;			}
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Reads a sequence of values and the trailing closing brace &#39;]&#39; of an array. The
&nbsp;	 * opening brace &#39;[&#39; should have already been read. Note that &quot;[]&quot; yields an empty
&nbsp;	 * array, but &quot;[,]&quot; returns a two-element array equivalent to &quot;[null,null]&quot;.
&nbsp;	 * @return an array
&nbsp;	 * @throws JSONException if processing of json failed
&nbsp;	 */
&nbsp;	private JSONArray readArray() throws JSONException {
<b class="nc">&nbsp;		JSONArray result = new JSONArray();</b>
&nbsp;
&nbsp;		/* to cover input that ends with &quot;,]&quot;. */
<b class="nc">&nbsp;		boolean hasTrailingSeparator = false;</b>
&nbsp;
&nbsp;		while (true) {
<b class="nc">&nbsp;			switch (nextCleanInternal()) {</b>
&nbsp;				case -1:
<b class="nc">&nbsp;					throw syntaxError(&quot;Unterminated array&quot;);</b>
&nbsp;				case &#39;]&#39;:
<b class="nc">&nbsp;					if (hasTrailingSeparator) {</b>
<b class="nc">&nbsp;						result.put(null);</b>
&nbsp;					}
<b class="nc">&nbsp;					return result;</b>
&nbsp;				case &#39;,&#39;, &#39;;&#39;:
&nbsp;					/* A separator without a value first means &quot;null&quot;. */
<b class="nc">&nbsp;					result.put(null);</b>
<b class="nc">&nbsp;					hasTrailingSeparator = true;</b>
<b class="nc">&nbsp;					continue;</b>
&nbsp;				default:
<b class="nc">&nbsp;					this.pos--;</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			result.put(nextValue());</b>
&nbsp;
<b class="nc">&nbsp;			switch (nextCleanInternal()) {</b>
&nbsp;				case &#39;]&#39;:
<b class="nc">&nbsp;					return result;</b>
&nbsp;				case &#39;,&#39;, &#39;;&#39;:
<b class="nc">&nbsp;					hasTrailingSeparator = true;</b>
<b class="nc">&nbsp;					continue;</b>
&nbsp;				default:
<b class="nc">&nbsp;					throw syntaxError(&quot;Unterminated array&quot;);</b>
&nbsp;			}
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns an exception containing the given message plus the current position and the
&nbsp;	 * entire input string.
&nbsp;	 * @param message the message
&nbsp;	 * @return an exception
&nbsp;	 */
&nbsp;	public JSONException syntaxError(String message) {
<b class="nc">&nbsp;		return new JSONException(message + this);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns the current position and the entire input string.
&nbsp;	 * @return the current position and the entire input string.
&nbsp;	 */
&nbsp;	@Override
&nbsp;	public String toString() {
&nbsp;		// consistent with the original implementation
<b class="nc">&nbsp;		return &quot; at character &quot; + this.pos + &quot; of &quot; + this.in;</b>
&nbsp;	}
&nbsp;
&nbsp;	/*
&nbsp;	 * Legacy APIs.
&nbsp;	 *
&nbsp;	 * None of the methods below are on the critical path of parsing JSON documents. They
&nbsp;	 * exist only because they were exposed by the original implementation and may be used
&nbsp;	 * by some clients.
&nbsp;	 */
&nbsp;
&nbsp;	public boolean more() {
<b class="nc">&nbsp;		return this.pos &lt; this.in.length();</b>
&nbsp;	}
&nbsp;
&nbsp;	public char next() {
<b class="nc">&nbsp;		return this.pos &lt; this.in.length() ? this.in.charAt(this.pos++) : &#39;\0&#39;;</b>
&nbsp;	}
&nbsp;
&nbsp;	public char next(char c) throws JSONException {
<b class="nc">&nbsp;		char result = next();</b>
<b class="nc">&nbsp;		if (result != c) {</b>
<b class="nc">&nbsp;			throw syntaxError(&quot;Expected &quot; + c + &quot; but was &quot; + result);</b>
&nbsp;		}
<b class="nc">&nbsp;		return result;</b>
&nbsp;	}
&nbsp;
&nbsp;	public char nextClean() throws JSONException {
<b class="nc">&nbsp;		int nextCleanInt = nextCleanInternal();</b>
<b class="nc">&nbsp;		return nextCleanInt == -1 ? &#39;\0&#39; : (char) nextCleanInt;</b>
&nbsp;	}
&nbsp;
&nbsp;	public String next(int length) throws JSONException {
<b class="nc">&nbsp;		if (this.pos + length &gt; this.in.length()) {</b>
<b class="nc">&nbsp;			throw syntaxError(length + &quot; is out of bounds&quot;);</b>
&nbsp;		}
<b class="nc">&nbsp;		String result = this.in.substring(this.pos, this.pos + length);</b>
<b class="nc">&nbsp;		this.pos += length;</b>
<b class="nc">&nbsp;		return result;</b>
&nbsp;	}
&nbsp;
&nbsp;	public String nextTo(String excluded) {
<b class="nc">&nbsp;		if (excluded == null) {</b>
<b class="nc">&nbsp;			throw new NullPointerException(&quot;excluded == null&quot;);</b>
&nbsp;		}
<b class="nc">&nbsp;		return nextToInternal(excluded).trim();</b>
&nbsp;	}
&nbsp;
&nbsp;	public String nextTo(char excluded) {
<b class="nc">&nbsp;		return nextToInternal(String.valueOf(excluded)).trim();</b>
&nbsp;	}
&nbsp;
&nbsp;	public void skipPast(String thru) {
<b class="nc">&nbsp;		int thruStart = this.in.indexOf(thru, this.pos);</b>
<b class="nc">&nbsp;		this.pos = thruStart == -1 ? this.in.length() : (thruStart + thru.length());</b>
&nbsp;	}
&nbsp;
&nbsp;	public char skipTo(char to) {
<b class="nc">&nbsp;		int index = this.in.indexOf(to, this.pos);</b>
<b class="nc">&nbsp;		if (index != -1) {</b>
<b class="nc">&nbsp;			this.pos = index;</b>
<b class="nc">&nbsp;			return to;</b>
&nbsp;		}
&nbsp;		else {
<b class="nc">&nbsp;			return &#39;\0&#39;;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	public void back() {
<b class="nc">&nbsp;		if (--this.pos == -1) {</b>
<b class="nc">&nbsp;			this.pos = 0;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	public static int dehexchar(char hex) {
<b class="nc">&nbsp;		if (hex &gt;= &#39;0&#39; &amp;&amp; hex &lt;= &#39;9&#39;) {</b>
<b class="nc">&nbsp;			return hex - &#39;0&#39;;</b>
&nbsp;		}
<b class="nc">&nbsp;		else if (hex &gt;= &#39;A&#39; &amp;&amp; hex &lt;= &#39;F&#39;) {</b>
<b class="nc">&nbsp;			return hex - &#39;A&#39; + 10;</b>
&nbsp;		}
<b class="nc">&nbsp;		else if (hex &gt;= &#39;a&#39; &amp;&amp; hex &lt;= &#39;f&#39;) {</b>
<b class="nc">&nbsp;			return hex - &#39;a&#39; + 10;</b>
&nbsp;		}
&nbsp;		else {
<b class="nc">&nbsp;			return -1;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-04-01 11:12</div>
</div>
</body>
</html>
