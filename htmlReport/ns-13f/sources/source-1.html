


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > DockerApi</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.springframework.boot.buildpack.platform.docker</a>
</div>

<h1>Coverage Summary for Class: DockerApi (org.springframework.boot.buildpack.platform.docker)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">DockerApi</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/11)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/22)
  </span>
</td>
</tr>
  <tr>
    <td class="name">DockerApi$ContainerApi</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/35)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DockerApi$DigestCaptureUpdateListener</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DockerApi$ErrorCaptureUpdateListener</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DockerApi$ImageApi</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/18)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/95)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DockerApi$StreamCaptureUpdateListener</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DockerApi$VolumeApi</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/47)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/169)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2012-2024 the original author or authors.
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *      https://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;
&nbsp;package org.springframework.boot.buildpack.platform.docker;
&nbsp;
&nbsp;import java.io.BufferedReader;
&nbsp;import java.io.ByteArrayInputStream;
&nbsp;import java.io.FileInputStream;
&nbsp;import java.io.IOException;
&nbsp;import java.io.InputStream;
&nbsp;import java.io.InputStreamReader;
&nbsp;import java.io.OutputStream;
&nbsp;import java.net.URI;
&nbsp;import java.net.URISyntaxException;
&nbsp;import java.nio.charset.StandardCharsets;
&nbsp;import java.nio.file.Files;
&nbsp;import java.nio.file.Path;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collection;
&nbsp;import java.util.Collections;
&nbsp;import java.util.List;
&nbsp;import java.util.Objects;
&nbsp;import java.util.stream.Collectors;
&nbsp;
&nbsp;import org.apache.commons.compress.archivers.tar.TarArchiveEntry;
&nbsp;import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;
&nbsp;import org.apache.hc.core5.net.URIBuilder;
&nbsp;
&nbsp;import org.springframework.boot.buildpack.platform.docker.configuration.DockerConfiguration.DockerHostConfiguration;
&nbsp;import org.springframework.boot.buildpack.platform.docker.transport.HttpTransport;
&nbsp;import org.springframework.boot.buildpack.platform.docker.transport.HttpTransport.Response;
&nbsp;import org.springframework.boot.buildpack.platform.docker.type.ContainerConfig;
&nbsp;import org.springframework.boot.buildpack.platform.docker.type.ContainerContent;
&nbsp;import org.springframework.boot.buildpack.platform.docker.type.ContainerReference;
&nbsp;import org.springframework.boot.buildpack.platform.docker.type.ContainerStatus;
&nbsp;import org.springframework.boot.buildpack.platform.docker.type.Image;
&nbsp;import org.springframework.boot.buildpack.platform.docker.type.ImageArchive;
&nbsp;import org.springframework.boot.buildpack.platform.docker.type.ImageArchiveManifest;
&nbsp;import org.springframework.boot.buildpack.platform.docker.type.ImageReference;
&nbsp;import org.springframework.boot.buildpack.platform.docker.type.VolumeName;
&nbsp;import org.springframework.boot.buildpack.platform.io.IOBiConsumer;
&nbsp;import org.springframework.boot.buildpack.platform.io.TarArchive;
&nbsp;import org.springframework.boot.buildpack.platform.json.JsonStream;
&nbsp;import org.springframework.boot.buildpack.platform.json.SharedObjectMapper;
&nbsp;import org.springframework.util.Assert;
&nbsp;import org.springframework.util.StreamUtils;
&nbsp;import org.springframework.util.StringUtils;
&nbsp;
&nbsp;/**
&nbsp; * Provides access to the limited set of Docker APIs needed by pack.
&nbsp; *
&nbsp; * @author Phillip Webb
&nbsp; * @author Scott Frederick
&nbsp; * @author Rafael Ceccone
&nbsp; * @author Moritz Halbritter
&nbsp; * @since 2.3.0
&nbsp; */
&nbsp;public class DockerApi {
&nbsp;
<b class="nc">&nbsp;	private static final List&lt;String&gt; FORCE_PARAMS = Collections.unmodifiableList(Arrays.asList(&quot;force&quot;, &quot;1&quot;));</b>
&nbsp;
&nbsp;	static final String API_VERSION = &quot;v1.24&quot;;
&nbsp;
&nbsp;	private final HttpTransport http;
&nbsp;
&nbsp;	private final JsonStream jsonStream;
&nbsp;
&nbsp;	private final ImageApi image;
&nbsp;
&nbsp;	private final ContainerApi container;
&nbsp;
&nbsp;	private final VolumeApi volume;
&nbsp;
&nbsp;	/**
&nbsp;	 * Create a new {@link DockerApi} instance.
&nbsp;	 */
&nbsp;	public DockerApi() {
<b class="nc">&nbsp;		this(HttpTransport.create(null));</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Create a new {@link DockerApi} instance.
&nbsp;	 * @param dockerHost the Docker daemon host information
&nbsp;	 * @since 2.4.0
&nbsp;	 */
&nbsp;	public DockerApi(DockerHostConfiguration dockerHost) {
<b class="nc">&nbsp;		this(HttpTransport.create(dockerHost));</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Create a new {@link DockerApi} instance backed by a specific {@link HttpTransport}
&nbsp;	 * implementation.
&nbsp;	 * @param http the http implementation
&nbsp;	 */
<b class="nc">&nbsp;	DockerApi(HttpTransport http) {</b>
<b class="nc">&nbsp;		this.http = http;</b>
<b class="nc">&nbsp;		this.jsonStream = new JsonStream(SharedObjectMapper.get());</b>
<b class="nc">&nbsp;		this.image = new ImageApi();</b>
<b class="nc">&nbsp;		this.container = new ContainerApi();</b>
<b class="nc">&nbsp;		this.volume = new VolumeApi();</b>
&nbsp;	}
&nbsp;
&nbsp;	private HttpTransport http() {
<b class="nc">&nbsp;		return this.http;</b>
&nbsp;	}
&nbsp;
&nbsp;	private JsonStream jsonStream() {
<b class="nc">&nbsp;		return this.jsonStream;</b>
&nbsp;	}
&nbsp;
&nbsp;	private URI buildUrl(String path, Collection&lt;?&gt; params) {
<b class="nc">&nbsp;		return buildUrl(path, (params != null) ? params.toArray() : null);</b>
&nbsp;	}
&nbsp;
&nbsp;	private URI buildUrl(String path, Object... params) {
&nbsp;		try {
<b class="nc">&nbsp;			URIBuilder builder = new URIBuilder(&quot;/&quot; + API_VERSION + path);</b>
<b class="nc">&nbsp;			int param = 0;</b>
<b class="nc">&nbsp;			while (param &lt; params.length) {</b>
<b class="nc">&nbsp;				builder.addParameter(Objects.toString(params[param++]), Objects.toString(params[param++]));</b>
&nbsp;			}
<b class="nc">&nbsp;			return builder.build();</b>
&nbsp;		}
<b class="nc">&nbsp;		catch (URISyntaxException ex) {</b>
<b class="nc">&nbsp;			throw new IllegalStateException(ex);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Return the Docker API for image operations.
&nbsp;	 * @return the image API
&nbsp;	 */
&nbsp;	public ImageApi image() {
<b class="nc">&nbsp;		return this.image;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Return the Docker API for container operations.
&nbsp;	 * @return the container API
&nbsp;	 */
&nbsp;	public ContainerApi container() {
<b class="nc">&nbsp;		return this.container;</b>
&nbsp;	}
&nbsp;
&nbsp;	public VolumeApi volume() {
<b class="nc">&nbsp;		return this.volume;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Docker API for image operations.
&nbsp;	 */
&nbsp;	public class ImageApi {
&nbsp;
<b class="nc">&nbsp;		ImageApi() {</b>
&nbsp;		}
&nbsp;
&nbsp;		/**
&nbsp;		 * Pull an image from a registry.
&nbsp;		 * @param reference the image reference to pull
&nbsp;		 * @param listener a pull listener to receive update events
&nbsp;		 * @return the {@link ImageApi pulled image} instance
&nbsp;		 * @throws IOException on IO error
&nbsp;		 */
&nbsp;		public Image pull(ImageReference reference, UpdateListener&lt;PullImageUpdateEvent&gt; listener) throws IOException {
<b class="nc">&nbsp;			return pull(reference, listener, null);</b>
&nbsp;		}
&nbsp;
&nbsp;		/**
&nbsp;		 * Pull an image from a registry.
&nbsp;		 * @param reference the image reference to pull
&nbsp;		 * @param listener a pull listener to receive update events
&nbsp;		 * @param registryAuth registry authentication credentials
&nbsp;		 * @return the {@link ImageApi pulled image} instance
&nbsp;		 * @throws IOException on IO error
&nbsp;		 */
&nbsp;		public Image pull(ImageReference reference, UpdateListener&lt;PullImageUpdateEvent&gt; listener, String registryAuth)
&nbsp;				throws IOException {
<b class="nc">&nbsp;			Assert.notNull(reference, &quot;Reference must not be null&quot;);</b>
<b class="nc">&nbsp;			Assert.notNull(listener, &quot;Listener must not be null&quot;);</b>
<b class="nc">&nbsp;			URI createUri = buildUrl(&quot;/images/create&quot;, &quot;fromImage&quot;, reference);</b>
<b class="nc">&nbsp;			DigestCaptureUpdateListener digestCapture = new DigestCaptureUpdateListener();</b>
<b class="nc">&nbsp;			listener.onStart();</b>
&nbsp;			try {
<b class="nc">&nbsp;				try (Response response = http().post(createUri, registryAuth)) {</b>
<b class="nc">&nbsp;					jsonStream().get(response.getContent(), PullImageUpdateEvent.class, (event) -&gt; {</b>
<b class="nc">&nbsp;						digestCapture.onUpdate(event);</b>
<b class="nc">&nbsp;						listener.onUpdate(event);</b>
&nbsp;					});
<b class="nc">&nbsp;				}</b>
<b class="nc">&nbsp;				return inspect(reference);</b>
&nbsp;			}
&nbsp;			finally {
<b class="nc">&nbsp;				listener.onFinish();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;		}
&nbsp;
&nbsp;		/**
&nbsp;		 * Push an image to a registry.
&nbsp;		 * @param reference the image reference to push
&nbsp;		 * @param listener a push listener to receive update events
&nbsp;		 * @param registryAuth registry authentication credentials
&nbsp;		 * @throws IOException on IO error
&nbsp;		 */
&nbsp;		public void push(ImageReference reference, UpdateListener&lt;PushImageUpdateEvent&gt; listener, String registryAuth)
&nbsp;				throws IOException {
<b class="nc">&nbsp;			Assert.notNull(reference, &quot;Reference must not be null&quot;);</b>
<b class="nc">&nbsp;			Assert.notNull(listener, &quot;Listener must not be null&quot;);</b>
<b class="nc">&nbsp;			URI pushUri = buildUrl(&quot;/images/&quot; + reference + &quot;/push&quot;);</b>
<b class="nc">&nbsp;			ErrorCaptureUpdateListener errorListener = new ErrorCaptureUpdateListener();</b>
<b class="nc">&nbsp;			listener.onStart();</b>
&nbsp;			try {
<b class="nc">&nbsp;				try (Response response = http().post(pushUri, registryAuth)) {</b>
<b class="nc">&nbsp;					jsonStream().get(response.getContent(), PushImageUpdateEvent.class, (event) -&gt; {</b>
<b class="nc">&nbsp;						errorListener.onUpdate(event);</b>
<b class="nc">&nbsp;						listener.onUpdate(event);</b>
&nbsp;					});
<b class="nc">&nbsp;				}</b>
&nbsp;			}
&nbsp;			finally {
<b class="nc">&nbsp;				listener.onFinish();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;		}
&nbsp;
&nbsp;		/**
&nbsp;		 * Load an {@link ImageArchive} into Docker.
&nbsp;		 * @param archive the archive to load
&nbsp;		 * @param listener a pull listener to receive update events
&nbsp;		 * @throws IOException on IO error
&nbsp;		 */
&nbsp;		public void load(ImageArchive archive, UpdateListener&lt;LoadImageUpdateEvent&gt; listener) throws IOException {
<b class="nc">&nbsp;			Assert.notNull(archive, &quot;Archive must not be null&quot;);</b>
<b class="nc">&nbsp;			Assert.notNull(listener, &quot;Listener must not be null&quot;);</b>
<b class="nc">&nbsp;			URI loadUri = buildUrl(&quot;/images/load&quot;);</b>
<b class="nc">&nbsp;			StreamCaptureUpdateListener streamListener = new StreamCaptureUpdateListener();</b>
<b class="nc">&nbsp;			listener.onStart();</b>
&nbsp;			try {
<b class="nc">&nbsp;				try (Response response = http().post(loadUri, &quot;application/x-tar&quot;, archive::writeTo)) {</b>
<b class="nc">&nbsp;					jsonStream().get(response.getContent(), LoadImageUpdateEvent.class, (event) -&gt; {</b>
<b class="nc">&nbsp;						streamListener.onUpdate(event);</b>
<b class="nc">&nbsp;						listener.onUpdate(event);</b>
&nbsp;					});
<b class="nc">&nbsp;				}</b>
<b class="nc">&nbsp;				Assert.state(StringUtils.hasText(streamListener.getCapturedStream()),</b>
&nbsp;						&quot;Invalid response received when loading image &quot;
<b class="nc">&nbsp;								+ ((archive.getTag() != null) ? &quot;\&quot;&quot; + archive.getTag() + &quot;\&quot;&quot; : &quot;&quot;));</b>
&nbsp;			}
&nbsp;			finally {
<b class="nc">&nbsp;				listener.onFinish();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;		}
&nbsp;
&nbsp;		/**
&nbsp;		 * Export the layers of an image as {@link TarArchive}s.
&nbsp;		 * @param reference the reference to export
&nbsp;		 * @param exports a consumer to receive the layers (contents can only be accessed
&nbsp;		 * during the callback)
&nbsp;		 * @throws IOException on IO error
&nbsp;		 */
&nbsp;		public void exportLayers(ImageReference reference, IOBiConsumer&lt;String, TarArchive&gt; exports)
&nbsp;				throws IOException {
<b class="nc">&nbsp;			exportLayerFiles(reference, (name, path) -&gt; {</b>
<b class="nc">&nbsp;				try (InputStream in = Files.newInputStream(path)) {</b>
<b class="nc">&nbsp;					TarArchive archive = (out) -&gt; StreamUtils.copy(in, out);</b>
<b class="nc">&nbsp;					exports.accept(name, archive);</b>
<b class="nc">&nbsp;				}</b>
&nbsp;			});
&nbsp;		}
&nbsp;
&nbsp;		/**
&nbsp;		 * Export the layers of an image as paths to layer tar files.
&nbsp;		 * @param reference the reference to export
&nbsp;		 * @param exports a consumer to receive the layer tar file paths (file can only be
&nbsp;		 * accessed during the callback)
&nbsp;		 * @throws IOException on IO error
&nbsp;		 * @since 2.7.10
&nbsp;		 */
&nbsp;		public void exportLayerFiles(ImageReference reference, IOBiConsumer&lt;String, Path&gt; exports) throws IOException {
<b class="nc">&nbsp;			Assert.notNull(reference, &quot;Reference must not be null&quot;);</b>
<b class="nc">&nbsp;			Assert.notNull(exports, &quot;Exports must not be null&quot;);</b>
<b class="nc">&nbsp;			URI saveUri = buildUrl(&quot;/images/&quot; + reference + &quot;/get&quot;);</b>
<b class="nc">&nbsp;			Response response = http().get(saveUri);</b>
<b class="nc">&nbsp;			Path exportFile = copyToTemp(response.getContent());</b>
<b class="nc">&nbsp;			ImageArchiveManifest manifest = getManifest(reference, exportFile);</b>
<b class="nc">&nbsp;			try (TarArchiveInputStream tar = new TarArchiveInputStream(new FileInputStream(exportFile.toFile()))) {</b>
<b class="nc">&nbsp;				TarArchiveEntry entry = tar.getNextEntry();</b>
<b class="nc">&nbsp;				while (entry != null) {</b>
<b class="nc">&nbsp;					if (manifestContainsLayerEntry(manifest, entry.getName())) {</b>
<b class="nc">&nbsp;						Path layerFile = copyToTemp(tar);</b>
<b class="nc">&nbsp;						exports.accept(entry.getName(), layerFile);</b>
<b class="nc">&nbsp;						Files.delete(layerFile);</b>
&nbsp;					}
<b class="nc">&nbsp;					entry = tar.getNextEntry();</b>
&nbsp;				}
<b class="nc">&nbsp;			}</b>
<b class="nc">&nbsp;			Files.delete(exportFile);</b>
&nbsp;		}
&nbsp;
&nbsp;		/**
&nbsp;		 * Remove a specific image.
&nbsp;		 * @param reference the reference the remove
&nbsp;		 * @param force if removal should be forced
&nbsp;		 * @throws IOException on IO error
&nbsp;		 */
&nbsp;		public void remove(ImageReference reference, boolean force) throws IOException {
<b class="nc">&nbsp;			Assert.notNull(reference, &quot;Reference must not be null&quot;);</b>
<b class="nc">&nbsp;			Collection&lt;String&gt; params = force ? FORCE_PARAMS : Collections.emptySet();</b>
<b class="nc">&nbsp;			URI uri = buildUrl(&quot;/images/&quot; + reference, params);</b>
<b class="nc">&nbsp;			http().delete(uri).close();</b>
&nbsp;		}
&nbsp;
&nbsp;		/**
&nbsp;		 * Inspect an image.
&nbsp;		 * @param reference the image reference
&nbsp;		 * @return the image from the local repository
&nbsp;		 * @throws IOException on IO error
&nbsp;		 */
&nbsp;		public Image inspect(ImageReference reference) throws IOException {
<b class="nc">&nbsp;			Assert.notNull(reference, &quot;Reference must not be null&quot;);</b>
<b class="nc">&nbsp;			URI imageUri = buildUrl(&quot;/images/&quot; + reference + &quot;/json&quot;);</b>
<b class="nc">&nbsp;			try (Response response = http().get(imageUri)) {</b>
<b class="nc">&nbsp;				return Image.of(response.getContent());</b>
<b class="nc">&nbsp;			}</b>
&nbsp;		}
&nbsp;
&nbsp;		public void tag(ImageReference sourceReference, ImageReference targetReference) throws IOException {
<b class="nc">&nbsp;			Assert.notNull(sourceReference, &quot;SourceReference must not be null&quot;);</b>
<b class="nc">&nbsp;			Assert.notNull(targetReference, &quot;TargetReference must not be null&quot;);</b>
<b class="nc">&nbsp;			String tag = targetReference.getTag();</b>
<b class="nc">&nbsp;			String path = &quot;/images/&quot; + sourceReference + &quot;/tag&quot;;</b>
<b class="nc">&nbsp;			URI uri = (tag != null) ? buildUrl(path, &quot;repo&quot;, targetReference.inTaglessForm(), &quot;tag&quot;, tag)</b>
<b class="nc">&nbsp;					: buildUrl(path, &quot;repo&quot;, targetReference);</b>
<b class="nc">&nbsp;			http().post(uri).close();</b>
&nbsp;		}
&nbsp;
&nbsp;		private ImageArchiveManifest getManifest(ImageReference reference, Path exportFile) throws IOException {
<b class="nc">&nbsp;			try (TarArchiveInputStream tar = new TarArchiveInputStream(new FileInputStream(exportFile.toFile()))) {</b>
<b class="nc">&nbsp;				TarArchiveEntry entry = tar.getNextEntry();</b>
<b class="nc">&nbsp;				while (entry != null) {</b>
<b class="nc">&nbsp;					if (entry.getName().equals(&quot;manifest.json&quot;)) {</b>
<b class="nc">&nbsp;						return readManifest(tar);</b>
&nbsp;					}
<b class="nc">&nbsp;					entry = tar.getNextEntry();</b>
&nbsp;				}
<b class="nc">&nbsp;			}</b>
<b class="nc">&nbsp;			throw new IllegalArgumentException(&quot;Manifest not found in image &quot; + reference);</b>
&nbsp;		}
&nbsp;
&nbsp;		private ImageArchiveManifest readManifest(TarArchiveInputStream tar) throws IOException {
<b class="nc">&nbsp;			String manifestContent = new BufferedReader(new InputStreamReader(tar, StandardCharsets.UTF_8)).lines()</b>
<b class="nc">&nbsp;				.collect(Collectors.joining());</b>
<b class="nc">&nbsp;			return ImageArchiveManifest.of(new ByteArrayInputStream(manifestContent.getBytes(StandardCharsets.UTF_8)));</b>
&nbsp;		}
&nbsp;
&nbsp;		private Path copyToTemp(InputStream in) throws IOException {
<b class="nc">&nbsp;			Path path = Files.createTempFile(&quot;create-builder-scratch-&quot;, null);</b>
<b class="nc">&nbsp;			try (OutputStream out = Files.newOutputStream(path)) {</b>
<b class="nc">&nbsp;				StreamUtils.copy(in, out);</b>
<b class="nc">&nbsp;			}</b>
<b class="nc">&nbsp;			return path;</b>
&nbsp;		}
&nbsp;
&nbsp;		private boolean manifestContainsLayerEntry(ImageArchiveManifest manifest, String layerId) {
<b class="nc">&nbsp;			return manifest.getEntries().stream().anyMatch((content) -&gt; content.getLayers().contains(layerId));</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Docker API for container operations.
&nbsp;	 */
&nbsp;	public class ContainerApi {
&nbsp;
<b class="nc">&nbsp;		ContainerApi() {</b>
&nbsp;		}
&nbsp;
&nbsp;		/**
&nbsp;		 * Create a new container a {@link ContainerConfig}.
&nbsp;		 * @param config the container config
&nbsp;		 * @param contents additional contents to include
&nbsp;		 * @return a {@link ContainerReference} for the newly created container
&nbsp;		 * @throws IOException on IO error
&nbsp;		 */
&nbsp;		public ContainerReference create(ContainerConfig config, ContainerContent... contents) throws IOException {
<b class="nc">&nbsp;			Assert.notNull(config, &quot;Config must not be null&quot;);</b>
<b class="nc">&nbsp;			Assert.noNullElements(contents, &quot;Contents must not contain null elements&quot;);</b>
<b class="nc">&nbsp;			ContainerReference containerReference = createContainer(config);</b>
<b class="nc">&nbsp;			for (ContainerContent content : contents) {</b>
<b class="nc">&nbsp;				uploadContainerContent(containerReference, content);</b>
&nbsp;			}
<b class="nc">&nbsp;			return containerReference;</b>
&nbsp;		}
&nbsp;
&nbsp;		private ContainerReference createContainer(ContainerConfig config) throws IOException {
<b class="nc">&nbsp;			URI createUri = buildUrl(&quot;/containers/create&quot;);</b>
<b class="nc">&nbsp;			try (Response response = http().post(createUri, &quot;application/json&quot;, config::writeTo)) {</b>
<b class="nc">&nbsp;				return ContainerReference</b>
<b class="nc">&nbsp;					.of(SharedObjectMapper.get().readTree(response.getContent()).at(&quot;/Id&quot;).asText());</b>
<b class="nc">&nbsp;			}</b>
&nbsp;		}
&nbsp;
&nbsp;		private void uploadContainerContent(ContainerReference reference, ContainerContent content) throws IOException {
<b class="nc">&nbsp;			URI uri = buildUrl(&quot;/containers/&quot; + reference + &quot;/archive&quot;, &quot;path&quot;, content.getDestinationPath());</b>
<b class="nc">&nbsp;			http().put(uri, &quot;application/x-tar&quot;, content.getArchive()::writeTo).close();</b>
&nbsp;		}
&nbsp;
&nbsp;		/**
&nbsp;		 * Start a specific container.
&nbsp;		 * @param reference the container reference to start
&nbsp;		 * @throws IOException on IO error
&nbsp;		 */
&nbsp;		public void start(ContainerReference reference) throws IOException {
<b class="nc">&nbsp;			Assert.notNull(reference, &quot;Reference must not be null&quot;);</b>
<b class="nc">&nbsp;			URI uri = buildUrl(&quot;/containers/&quot; + reference + &quot;/start&quot;);</b>
<b class="nc">&nbsp;			http().post(uri).close();</b>
&nbsp;		}
&nbsp;
&nbsp;		/**
&nbsp;		 * Return and follow logs for a specific container.
&nbsp;		 * @param reference the container reference
&nbsp;		 * @param listener a listener to receive log update events
&nbsp;		 * @throws IOException on IO error
&nbsp;		 */
&nbsp;		public void logs(ContainerReference reference, UpdateListener&lt;LogUpdateEvent&gt; listener) throws IOException {
<b class="nc">&nbsp;			Assert.notNull(reference, &quot;Reference must not be null&quot;);</b>
<b class="nc">&nbsp;			Assert.notNull(listener, &quot;Listener must not be null&quot;);</b>
<b class="nc">&nbsp;			Object[] params = { &quot;stdout&quot;, &quot;1&quot;, &quot;stderr&quot;, &quot;1&quot;, &quot;follow&quot;, &quot;1&quot; };</b>
<b class="nc">&nbsp;			URI uri = buildUrl(&quot;/containers/&quot; + reference + &quot;/logs&quot;, params);</b>
<b class="nc">&nbsp;			listener.onStart();</b>
&nbsp;			try {
<b class="nc">&nbsp;				try (Response response = http().get(uri)) {</b>
<b class="nc">&nbsp;					LogUpdateEvent.readAll(response.getContent(), listener::onUpdate);</b>
<b class="nc">&nbsp;				}</b>
&nbsp;			}
&nbsp;			finally {
<b class="nc">&nbsp;				listener.onFinish();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;		}
&nbsp;
&nbsp;		/**
&nbsp;		 * Wait for a container to stop and retrieve the status.
&nbsp;		 * @param reference the container reference
&nbsp;		 * @return a {@link ContainerStatus} indicating the exit status of the container
&nbsp;		 * @throws IOException on IO error
&nbsp;		 */
&nbsp;		public ContainerStatus wait(ContainerReference reference) throws IOException {
<b class="nc">&nbsp;			Assert.notNull(reference, &quot;Reference must not be null&quot;);</b>
<b class="nc">&nbsp;			URI uri = buildUrl(&quot;/containers/&quot; + reference + &quot;/wait&quot;);</b>
<b class="nc">&nbsp;			Response response = http().post(uri);</b>
<b class="nc">&nbsp;			return ContainerStatus.of(response.getContent());</b>
&nbsp;		}
&nbsp;
&nbsp;		/**
&nbsp;		 * Remove a specific container.
&nbsp;		 * @param reference the container to remove
&nbsp;		 * @param force if removal should be forced
&nbsp;		 * @throws IOException on IO error
&nbsp;		 */
&nbsp;		public void remove(ContainerReference reference, boolean force) throws IOException {
<b class="nc">&nbsp;			Assert.notNull(reference, &quot;Reference must not be null&quot;);</b>
<b class="nc">&nbsp;			Collection&lt;String&gt; params = force ? FORCE_PARAMS : Collections.emptySet();</b>
<b class="nc">&nbsp;			URI uri = buildUrl(&quot;/containers/&quot; + reference, params);</b>
<b class="nc">&nbsp;			http().delete(uri).close();</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Docker API for volume operations.
&nbsp;	 */
&nbsp;	public class VolumeApi {
&nbsp;
<b class="nc">&nbsp;		VolumeApi() {</b>
&nbsp;		}
&nbsp;
&nbsp;		/**
&nbsp;		 * Delete a volume.
&nbsp;		 * @param name the name of the volume to delete
&nbsp;		 * @param force if the deletion should be forced
&nbsp;		 * @throws IOException on IO error
&nbsp;		 */
&nbsp;		public void delete(VolumeName name, boolean force) throws IOException {
<b class="nc">&nbsp;			Assert.notNull(name, &quot;Name must not be null&quot;);</b>
<b class="nc">&nbsp;			Collection&lt;String&gt; params = force ? FORCE_PARAMS : Collections.emptySet();</b>
<b class="nc">&nbsp;			URI uri = buildUrl(&quot;/volumes/&quot; + name, params);</b>
<b class="nc">&nbsp;			http().delete(uri).close();</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * {@link UpdateListener} used to capture the image digest.
&nbsp;	 */
<b class="nc">&nbsp;	private static final class DigestCaptureUpdateListener implements UpdateListener&lt;ProgressUpdateEvent&gt; {</b>
&nbsp;
&nbsp;		private static final String PREFIX = &quot;Digest:&quot;;
&nbsp;
&nbsp;		private String digest;
&nbsp;
&nbsp;		@Override
&nbsp;		public void onUpdate(ProgressUpdateEvent event) {
<b class="nc">&nbsp;			String status = event.getStatus();</b>
<b class="nc">&nbsp;			if (status != null &amp;&amp; status.startsWith(PREFIX)) {</b>
<b class="nc">&nbsp;				String digest = status.substring(PREFIX.length()).trim();</b>
<b class="nc">&nbsp;				Assert.state(this.digest == null || this.digest.equals(digest), &quot;Different digests IDs provided&quot;);</b>
<b class="nc">&nbsp;				this.digest = digest;</b>
&nbsp;			}
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * {@link UpdateListener} used to ensure an image load response stream.
&nbsp;	 */
<b class="nc">&nbsp;	private static final class StreamCaptureUpdateListener implements UpdateListener&lt;LoadImageUpdateEvent&gt; {</b>
&nbsp;
&nbsp;		private String stream;
&nbsp;
&nbsp;		@Override
&nbsp;		public void onUpdate(LoadImageUpdateEvent event) {
<b class="nc">&nbsp;			this.stream = event.getStream();</b>
&nbsp;		}
&nbsp;
&nbsp;		String getCapturedStream() {
<b class="nc">&nbsp;			return this.stream;</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * {@link UpdateListener} used to capture the details of an error in a response
&nbsp;	 * stream.
&nbsp;	 */
<b class="nc">&nbsp;	private static final class ErrorCaptureUpdateListener implements UpdateListener&lt;PushImageUpdateEvent&gt; {</b>
&nbsp;
&nbsp;		@Override
&nbsp;		public void onUpdate(PushImageUpdateEvent event) {
<b class="nc">&nbsp;			Assert.state(event.getErrorDetail() == null,</b>
<b class="nc">&nbsp;					() -&gt; &quot;Error response received when pushing image: &quot; + event.getErrorDetail().getMessage());</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-04-01 11:12</div>
</div>
</body>
</html>
