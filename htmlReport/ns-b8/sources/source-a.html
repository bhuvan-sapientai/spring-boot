


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > RabbitProperties</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.springframework.boot.autoconfigure.amqp</a>
</div>

<h1>Coverage Summary for Class: RabbitProperties (org.springframework.boot.autoconfigure.amqp)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">RabbitProperties</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/41)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/81)
  </span>
</td>
</tr>
  <tr>
    <td class="name">RabbitProperties$Address</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/38)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">RabbitProperties$AmqpContainer</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/16)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/19)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">RabbitProperties$BaseContainer</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">RabbitProperties$Cache</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">RabbitProperties$Cache$Channel</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">RabbitProperties$Cache$Connection</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">RabbitProperties$ContainerType</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">RabbitProperties$DirectContainer</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">RabbitProperties$Listener</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">RabbitProperties$ListenerRetry</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">RabbitProperties$Retry</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/11)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">RabbitProperties$SimpleContainer</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/11)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">RabbitProperties$Ssl</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/28)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/38)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">RabbitProperties$Stream</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/13)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">RabbitProperties$StreamContainer</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">RabbitProperties$Template</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/16)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/19)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/177)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/283)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2012-2024 the original author or authors.
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *      https://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;
&nbsp;package org.springframework.boot.autoconfigure.amqp;
&nbsp;
&nbsp;import java.time.Duration;
&nbsp;import java.time.temporal.ChronoUnit;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.List;
&nbsp;import java.util.Optional;
&nbsp;
&nbsp;import org.springframework.amqp.core.AcknowledgeMode;
&nbsp;import org.springframework.amqp.rabbit.connection.AbstractConnectionFactory.AddressShuffleMode;
&nbsp;import org.springframework.amqp.rabbit.connection.CachingConnectionFactory.CacheMode;
&nbsp;import org.springframework.amqp.rabbit.connection.CachingConnectionFactory.ConfirmType;
&nbsp;import org.springframework.boot.context.properties.ConfigurationProperties;
&nbsp;import org.springframework.boot.context.properties.source.InvalidConfigurationPropertyValueException;
&nbsp;import org.springframework.boot.convert.DurationUnit;
&nbsp;import org.springframework.util.CollectionUtils;
&nbsp;import org.springframework.util.StringUtils;
&nbsp;import org.springframework.util.unit.DataSize;
&nbsp;
&nbsp;/**
&nbsp; * Configuration properties for Rabbit.
&nbsp; *
&nbsp; * @author Greg Turnquist
&nbsp; * @author Dave Syer
&nbsp; * @author Stephane Nicoll
&nbsp; * @author Andy Wilkinson
&nbsp; * @author Josh Thornhill
&nbsp; * @author Gary Russell
&nbsp; * @author Artsiom Yudovin
&nbsp; * @author Franjo Zilic
&nbsp; * @author Eddú Meléndez
&nbsp; * @author Rafael Carvalho
&nbsp; * @author Scott Frederick
&nbsp; * @author Lasse Wulff
&nbsp; * @since 1.0.0
&nbsp; */
&nbsp;@ConfigurationProperties(prefix = &quot;spring.rabbitmq&quot;)
<b class="nc">&nbsp;public class RabbitProperties {</b>
&nbsp;
&nbsp;	private static final int DEFAULT_PORT = 5672;
&nbsp;
&nbsp;	private static final int DEFAULT_PORT_SECURE = 5671;
&nbsp;
&nbsp;	private static final int DEFAULT_STREAM_PORT = 5552;
&nbsp;
&nbsp;	/**
&nbsp;	 * RabbitMQ host. Ignored if an address is set.
&nbsp;	 */
<b class="nc">&nbsp;	private String host = &quot;localhost&quot;;</b>
&nbsp;
&nbsp;	/**
&nbsp;	 * RabbitMQ port. Ignored if an address is set. Default to 5672, or 5671 if SSL is
&nbsp;	 * enabled.
&nbsp;	 */
&nbsp;	private Integer port;
&nbsp;
&nbsp;	/**
&nbsp;	 * Login user to authenticate to the broker.
&nbsp;	 */
<b class="nc">&nbsp;	private String username = &quot;guest&quot;;</b>
&nbsp;
&nbsp;	/**
&nbsp;	 * Login to authenticate against the broker.
&nbsp;	 */
<b class="nc">&nbsp;	private String password = &quot;guest&quot;;</b>
&nbsp;
&nbsp;	/**
&nbsp;	 * SSL configuration.
&nbsp;	 */
<b class="nc">&nbsp;	private final Ssl ssl = new Ssl();</b>
&nbsp;
&nbsp;	/**
&nbsp;	 * Virtual host to use when connecting to the broker.
&nbsp;	 */
&nbsp;	private String virtualHost;
&nbsp;
&nbsp;	/**
&nbsp;	 * Comma-separated list of addresses to which the client should connect. When set, the
&nbsp;	 * host and port are ignored.
&nbsp;	 */
&nbsp;	private String addresses;
&nbsp;
&nbsp;	/**
&nbsp;	 * Mode used to shuffle configured addresses.
&nbsp;	 */
<b class="nc">&nbsp;	private AddressShuffleMode addressShuffleMode = AddressShuffleMode.NONE;</b>
&nbsp;
&nbsp;	/**
&nbsp;	 * Requested heartbeat timeout; zero for none. If a duration suffix is not specified,
&nbsp;	 * seconds will be used.
&nbsp;	 */
&nbsp;	@DurationUnit(ChronoUnit.SECONDS)
&nbsp;	private Duration requestedHeartbeat;
&nbsp;
&nbsp;	/**
&nbsp;	 * Number of channels per connection requested by the client. Use 0 for unlimited.
&nbsp;	 */
<b class="nc">&nbsp;	private int requestedChannelMax = 2047;</b>
&nbsp;
&nbsp;	/**
&nbsp;	 * Whether to enable publisher returns.
&nbsp;	 */
&nbsp;	private boolean publisherReturns;
&nbsp;
&nbsp;	/**
&nbsp;	 * Type of publisher confirms to use.
&nbsp;	 */
&nbsp;	private ConfirmType publisherConfirmType;
&nbsp;
&nbsp;	/**
&nbsp;	 * Connection timeout. Set it to zero to wait forever.
&nbsp;	 */
&nbsp;	private Duration connectionTimeout;
&nbsp;
&nbsp;	/**
&nbsp;	 * Continuation timeout for RPC calls in channels. Set it to zero to wait forever.
&nbsp;	 */
<b class="nc">&nbsp;	private Duration channelRpcTimeout = Duration.ofMinutes(10);</b>
&nbsp;
&nbsp;	/**
&nbsp;	 * Maximum size of the body of inbound (received) messages.
&nbsp;	 */
<b class="nc">&nbsp;	private DataSize maxInboundMessageBodySize = DataSize.ofMegabytes(64);</b>
&nbsp;
&nbsp;	/**
&nbsp;	 * Cache configuration.
&nbsp;	 */
<b class="nc">&nbsp;	private final Cache cache = new Cache();</b>
&nbsp;
&nbsp;	/**
&nbsp;	 * Listener container configuration.
&nbsp;	 */
<b class="nc">&nbsp;	private final Listener listener = new Listener();</b>
&nbsp;
<b class="nc">&nbsp;	private final Template template = new Template();</b>
&nbsp;
<b class="nc">&nbsp;	private final Stream stream = new Stream();</b>
&nbsp;
&nbsp;	private List&lt;Address&gt; parsedAddresses;
&nbsp;
&nbsp;	public String getHost() {
<b class="nc">&nbsp;		return this.host;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns the host from the first address, or the configured host if no addresses
&nbsp;	 * have been set.
&nbsp;	 * @return the host
&nbsp;	 * @see #setAddresses(String)
&nbsp;	 * @see #getHost()
&nbsp;	 */
&nbsp;	public String determineHost() {
<b class="nc">&nbsp;		if (CollectionUtils.isEmpty(this.parsedAddresses)) {</b>
<b class="nc">&nbsp;			return getHost();</b>
&nbsp;		}
<b class="nc">&nbsp;		return this.parsedAddresses.get(0).host;</b>
&nbsp;	}
&nbsp;
&nbsp;	public void setHost(String host) {
<b class="nc">&nbsp;		this.host = host;</b>
&nbsp;	}
&nbsp;
&nbsp;	public Integer getPort() {
<b class="nc">&nbsp;		return this.port;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns the port from the first address, or the configured port if no addresses
&nbsp;	 * have been set.
&nbsp;	 * @return the port
&nbsp;	 * @see #setAddresses(String)
&nbsp;	 * @see #getPort()
&nbsp;	 */
&nbsp;	public int determinePort() {
<b class="nc">&nbsp;		if (CollectionUtils.isEmpty(this.parsedAddresses)) {</b>
<b class="nc">&nbsp;			Integer port = getPort();</b>
<b class="nc">&nbsp;			if (port != null) {</b>
<b class="nc">&nbsp;				return port;</b>
&nbsp;			}
<b class="nc">&nbsp;			return (Optional.ofNullable(getSsl().getEnabled()).orElse(false)) ? DEFAULT_PORT_SECURE : DEFAULT_PORT;</b>
&nbsp;		}
<b class="nc">&nbsp;		return this.parsedAddresses.get(0).port;</b>
&nbsp;	}
&nbsp;
&nbsp;	public void setPort(Integer port) {
<b class="nc">&nbsp;		this.port = port;</b>
&nbsp;	}
&nbsp;
&nbsp;	public String getAddresses() {
<b class="nc">&nbsp;		return this.addresses;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns the comma-separated addresses or a single address ({@code host:port})
&nbsp;	 * created from the configured host and port if no addresses have been set.
&nbsp;	 * @return the addresses
&nbsp;	 */
&nbsp;	public String determineAddresses() {
<b class="nc">&nbsp;		if (CollectionUtils.isEmpty(this.parsedAddresses)) {</b>
<b class="nc">&nbsp;			if (this.host.contains(&quot;,&quot;)) {</b>
<b class="nc">&nbsp;				throw new InvalidConfigurationPropertyValueException(&quot;spring.rabbitmq.host&quot;, this.host,</b>
&nbsp;						&quot;Invalid character &#39;,&#39;. Value must be a single host. For multiple hosts, use property &#39;spring.rabbitmq.addresses&#39; instead.&quot;);
&nbsp;			}
<b class="nc">&nbsp;			return this.host + &quot;:&quot; + determinePort();</b>
&nbsp;		}
<b class="nc">&nbsp;		List&lt;String&gt; addressStrings = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;		for (Address parsedAddress : this.parsedAddresses) {</b>
<b class="nc">&nbsp;			addressStrings.add(parsedAddress.host + &quot;:&quot; + parsedAddress.port);</b>
<b class="nc">&nbsp;		}</b>
<b class="nc">&nbsp;		return StringUtils.collectionToCommaDelimitedString(addressStrings);</b>
&nbsp;	}
&nbsp;
&nbsp;	public void setAddresses(String addresses) {
<b class="nc">&nbsp;		this.addresses = addresses;</b>
<b class="nc">&nbsp;		this.parsedAddresses = parseAddresses(addresses);</b>
&nbsp;	}
&nbsp;
&nbsp;	private List&lt;Address&gt; parseAddresses(String addresses) {
<b class="nc">&nbsp;		List&lt;Address&gt; parsedAddresses = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;		for (String address : StringUtils.commaDelimitedListToStringArray(addresses)) {</b>
<b class="nc">&nbsp;			parsedAddresses.add(new Address(address, Optional.ofNullable(getSsl().getEnabled()).orElse(false)));</b>
&nbsp;		}
<b class="nc">&nbsp;		return parsedAddresses;</b>
&nbsp;	}
&nbsp;
&nbsp;	public String getUsername() {
<b class="nc">&nbsp;		return this.username;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * If addresses have been set and the first address has a username it is returned.
&nbsp;	 * Otherwise returns the result of calling {@code getUsername()}.
&nbsp;	 * @return the username
&nbsp;	 * @see #setAddresses(String)
&nbsp;	 * @see #getUsername()
&nbsp;	 */
&nbsp;	public String determineUsername() {
<b class="nc">&nbsp;		if (CollectionUtils.isEmpty(this.parsedAddresses)) {</b>
<b class="nc">&nbsp;			return this.username;</b>
&nbsp;		}
<b class="nc">&nbsp;		Address address = this.parsedAddresses.get(0);</b>
<b class="nc">&nbsp;		return (address.username != null) ? address.username : this.username;</b>
&nbsp;	}
&nbsp;
&nbsp;	public void setUsername(String username) {
<b class="nc">&nbsp;		this.username = username;</b>
&nbsp;	}
&nbsp;
&nbsp;	public String getPassword() {
<b class="nc">&nbsp;		return this.password;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * If addresses have been set and the first address has a password it is returned.
&nbsp;	 * Otherwise returns the result of calling {@code getPassword()}.
&nbsp;	 * @return the password or {@code null}
&nbsp;	 * @see #setAddresses(String)
&nbsp;	 * @see #getPassword()
&nbsp;	 */
&nbsp;	public String determinePassword() {
<b class="nc">&nbsp;		if (CollectionUtils.isEmpty(this.parsedAddresses)) {</b>
<b class="nc">&nbsp;			return getPassword();</b>
&nbsp;		}
<b class="nc">&nbsp;		Address address = this.parsedAddresses.get(0);</b>
<b class="nc">&nbsp;		return (address.password != null) ? address.password : getPassword();</b>
&nbsp;	}
&nbsp;
&nbsp;	public void setPassword(String password) {
<b class="nc">&nbsp;		this.password = password;</b>
&nbsp;	}
&nbsp;
&nbsp;	public Ssl getSsl() {
<b class="nc">&nbsp;		return this.ssl;</b>
&nbsp;	}
&nbsp;
&nbsp;	public String getVirtualHost() {
<b class="nc">&nbsp;		return this.virtualHost;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * If addresses have been set and the first address has a virtual host it is returned.
&nbsp;	 * Otherwise returns the result of calling {@code getVirtualHost()}.
&nbsp;	 * @return the virtual host or {@code null}
&nbsp;	 * @see #setAddresses(String)
&nbsp;	 * @see #getVirtualHost()
&nbsp;	 */
&nbsp;	public String determineVirtualHost() {
<b class="nc">&nbsp;		if (CollectionUtils.isEmpty(this.parsedAddresses)) {</b>
<b class="nc">&nbsp;			return getVirtualHost();</b>
&nbsp;		}
<b class="nc">&nbsp;		Address address = this.parsedAddresses.get(0);</b>
<b class="nc">&nbsp;		return (address.virtualHost != null) ? address.virtualHost : getVirtualHost();</b>
&nbsp;	}
&nbsp;
&nbsp;	public void setVirtualHost(String virtualHost) {
<b class="nc">&nbsp;		this.virtualHost = StringUtils.hasText(virtualHost) ? virtualHost : &quot;/&quot;;</b>
&nbsp;	}
&nbsp;
&nbsp;	public AddressShuffleMode getAddressShuffleMode() {
<b class="nc">&nbsp;		return this.addressShuffleMode;</b>
&nbsp;	}
&nbsp;
&nbsp;	public void setAddressShuffleMode(AddressShuffleMode addressShuffleMode) {
<b class="nc">&nbsp;		this.addressShuffleMode = addressShuffleMode;</b>
&nbsp;	}
&nbsp;
&nbsp;	public Duration getRequestedHeartbeat() {
<b class="nc">&nbsp;		return this.requestedHeartbeat;</b>
&nbsp;	}
&nbsp;
&nbsp;	public void setRequestedHeartbeat(Duration requestedHeartbeat) {
<b class="nc">&nbsp;		this.requestedHeartbeat = requestedHeartbeat;</b>
&nbsp;	}
&nbsp;
&nbsp;	public int getRequestedChannelMax() {
<b class="nc">&nbsp;		return this.requestedChannelMax;</b>
&nbsp;	}
&nbsp;
&nbsp;	public void setRequestedChannelMax(int requestedChannelMax) {
<b class="nc">&nbsp;		this.requestedChannelMax = requestedChannelMax;</b>
&nbsp;	}
&nbsp;
&nbsp;	public boolean isPublisherReturns() {
<b class="nc">&nbsp;		return this.publisherReturns;</b>
&nbsp;	}
&nbsp;
&nbsp;	public void setPublisherReturns(boolean publisherReturns) {
<b class="nc">&nbsp;		this.publisherReturns = publisherReturns;</b>
&nbsp;	}
&nbsp;
&nbsp;	public Duration getConnectionTimeout() {
<b class="nc">&nbsp;		return this.connectionTimeout;</b>
&nbsp;	}
&nbsp;
&nbsp;	public void setPublisherConfirmType(ConfirmType publisherConfirmType) {
<b class="nc">&nbsp;		this.publisherConfirmType = publisherConfirmType;</b>
&nbsp;	}
&nbsp;
&nbsp;	public ConfirmType getPublisherConfirmType() {
<b class="nc">&nbsp;		return this.publisherConfirmType;</b>
&nbsp;	}
&nbsp;
&nbsp;	public void setConnectionTimeout(Duration connectionTimeout) {
<b class="nc">&nbsp;		this.connectionTimeout = connectionTimeout;</b>
&nbsp;	}
&nbsp;
&nbsp;	public Duration getChannelRpcTimeout() {
<b class="nc">&nbsp;		return this.channelRpcTimeout;</b>
&nbsp;	}
&nbsp;
&nbsp;	public void setChannelRpcTimeout(Duration channelRpcTimeout) {
<b class="nc">&nbsp;		this.channelRpcTimeout = channelRpcTimeout;</b>
&nbsp;	}
&nbsp;
&nbsp;	public DataSize getMaxInboundMessageBodySize() {
<b class="nc">&nbsp;		return this.maxInboundMessageBodySize;</b>
&nbsp;	}
&nbsp;
&nbsp;	public void setMaxInboundMessageBodySize(DataSize maxInboundMessageBodySize) {
<b class="nc">&nbsp;		this.maxInboundMessageBodySize = maxInboundMessageBodySize;</b>
&nbsp;	}
&nbsp;
&nbsp;	public Cache getCache() {
<b class="nc">&nbsp;		return this.cache;</b>
&nbsp;	}
&nbsp;
&nbsp;	public Listener getListener() {
<b class="nc">&nbsp;		return this.listener;</b>
&nbsp;	}
&nbsp;
&nbsp;	public Template getTemplate() {
<b class="nc">&nbsp;		return this.template;</b>
&nbsp;	}
&nbsp;
&nbsp;	public Stream getStream() {
<b class="nc">&nbsp;		return this.stream;</b>
&nbsp;	}
&nbsp;
<b class="nc">&nbsp;	public class Ssl {</b>
&nbsp;
&nbsp;		private static final String SUN_X509 = &quot;SunX509&quot;;
&nbsp;
&nbsp;		/**
&nbsp;		 * Whether to enable SSL support. Determined automatically if an address is
&nbsp;		 * provided with the protocol (amqp:// vs. amqps://).
&nbsp;		 */
&nbsp;		private Boolean enabled;
&nbsp;
&nbsp;		/**
&nbsp;		 * SSL bundle name.
&nbsp;		 */
&nbsp;		private String bundle;
&nbsp;
&nbsp;		/**
&nbsp;		 * Path to the key store that holds the SSL certificate.
&nbsp;		 */
&nbsp;		private String keyStore;
&nbsp;
&nbsp;		/**
&nbsp;		 * Key store type.
&nbsp;		 */
<b class="nc">&nbsp;		private String keyStoreType = &quot;PKCS12&quot;;</b>
&nbsp;
&nbsp;		/**
&nbsp;		 * Password used to access the key store.
&nbsp;		 */
&nbsp;		private String keyStorePassword;
&nbsp;
&nbsp;		/**
&nbsp;		 * Key store algorithm.
&nbsp;		 */
<b class="nc">&nbsp;		private String keyStoreAlgorithm = SUN_X509;</b>
&nbsp;
&nbsp;		/**
&nbsp;		 * Trust store that holds SSL certificates.
&nbsp;		 */
&nbsp;		private String trustStore;
&nbsp;
&nbsp;		/**
&nbsp;		 * Trust store type.
&nbsp;		 */
<b class="nc">&nbsp;		private String trustStoreType = &quot;JKS&quot;;</b>
&nbsp;
&nbsp;		/**
&nbsp;		 * Password used to access the trust store.
&nbsp;		 */
&nbsp;		private String trustStorePassword;
&nbsp;
&nbsp;		/**
&nbsp;		 * Trust store algorithm.
&nbsp;		 */
<b class="nc">&nbsp;		private String trustStoreAlgorithm = SUN_X509;</b>
&nbsp;
&nbsp;		/**
&nbsp;		 * SSL algorithm to use. By default, configured by the Rabbit client library.
&nbsp;		 */
&nbsp;		private String algorithm;
&nbsp;
&nbsp;		/**
&nbsp;		 * Whether to enable server side certificate validation.
&nbsp;		 */
<b class="nc">&nbsp;		private boolean validateServerCertificate = true;</b>
&nbsp;
&nbsp;		/**
&nbsp;		 * Whether to enable hostname verification.
&nbsp;		 */
<b class="nc">&nbsp;		private boolean verifyHostname = true;</b>
&nbsp;
&nbsp;		public Boolean getEnabled() {
<b class="nc">&nbsp;			return this.enabled;</b>
&nbsp;		}
&nbsp;
&nbsp;		/**
&nbsp;		 * Returns whether SSL is enabled from the first address, or the configured ssl
&nbsp;		 * enabled flag if no addresses have been set.
&nbsp;		 * @return whether ssl is enabled
&nbsp;		 * @see #setAddresses(String)
&nbsp;		 * @see #getEnabled() ()
&nbsp;		 */
&nbsp;		public boolean determineEnabled() {
<b class="nc">&nbsp;			boolean defaultEnabled = Optional.ofNullable(getEnabled()).orElse(false) || this.bundle != null;</b>
<b class="nc">&nbsp;			if (CollectionUtils.isEmpty(RabbitProperties.this.parsedAddresses)) {</b>
<b class="nc">&nbsp;				return defaultEnabled;</b>
&nbsp;			}
<b class="nc">&nbsp;			Address address = RabbitProperties.this.parsedAddresses.get(0);</b>
<b class="nc">&nbsp;			return address.determineSslEnabled(defaultEnabled);</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setEnabled(Boolean enabled) {
<b class="nc">&nbsp;			this.enabled = enabled;</b>
&nbsp;		}
&nbsp;
&nbsp;		public String getBundle() {
<b class="nc">&nbsp;			return this.bundle;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setBundle(String bundle) {
<b class="nc">&nbsp;			this.bundle = bundle;</b>
&nbsp;		}
&nbsp;
&nbsp;		public String getKeyStore() {
<b class="nc">&nbsp;			return this.keyStore;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setKeyStore(String keyStore) {
<b class="nc">&nbsp;			this.keyStore = keyStore;</b>
&nbsp;		}
&nbsp;
&nbsp;		public String getKeyStoreType() {
<b class="nc">&nbsp;			return this.keyStoreType;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setKeyStoreType(String keyStoreType) {
<b class="nc">&nbsp;			this.keyStoreType = keyStoreType;</b>
&nbsp;		}
&nbsp;
&nbsp;		public String getKeyStorePassword() {
<b class="nc">&nbsp;			return this.keyStorePassword;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setKeyStorePassword(String keyStorePassword) {
<b class="nc">&nbsp;			this.keyStorePassword = keyStorePassword;</b>
&nbsp;		}
&nbsp;
&nbsp;		public String getKeyStoreAlgorithm() {
<b class="nc">&nbsp;			return this.keyStoreAlgorithm;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setKeyStoreAlgorithm(String keyStoreAlgorithm) {
<b class="nc">&nbsp;			this.keyStoreAlgorithm = keyStoreAlgorithm;</b>
&nbsp;		}
&nbsp;
&nbsp;		public String getTrustStore() {
<b class="nc">&nbsp;			return this.trustStore;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setTrustStore(String trustStore) {
<b class="nc">&nbsp;			this.trustStore = trustStore;</b>
&nbsp;		}
&nbsp;
&nbsp;		public String getTrustStoreType() {
<b class="nc">&nbsp;			return this.trustStoreType;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setTrustStoreType(String trustStoreType) {
<b class="nc">&nbsp;			this.trustStoreType = trustStoreType;</b>
&nbsp;		}
&nbsp;
&nbsp;		public String getTrustStorePassword() {
<b class="nc">&nbsp;			return this.trustStorePassword;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setTrustStorePassword(String trustStorePassword) {
<b class="nc">&nbsp;			this.trustStorePassword = trustStorePassword;</b>
&nbsp;		}
&nbsp;
&nbsp;		public String getTrustStoreAlgorithm() {
<b class="nc">&nbsp;			return this.trustStoreAlgorithm;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setTrustStoreAlgorithm(String trustStoreAlgorithm) {
<b class="nc">&nbsp;			this.trustStoreAlgorithm = trustStoreAlgorithm;</b>
&nbsp;		}
&nbsp;
&nbsp;		public String getAlgorithm() {
<b class="nc">&nbsp;			return this.algorithm;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setAlgorithm(String sslAlgorithm) {
<b class="nc">&nbsp;			this.algorithm = sslAlgorithm;</b>
&nbsp;		}
&nbsp;
&nbsp;		public boolean isValidateServerCertificate() {
<b class="nc">&nbsp;			return this.validateServerCertificate;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setValidateServerCertificate(boolean validateServerCertificate) {
<b class="nc">&nbsp;			this.validateServerCertificate = validateServerCertificate;</b>
&nbsp;		}
&nbsp;
&nbsp;		public boolean getVerifyHostname() {
<b class="nc">&nbsp;			return this.verifyHostname;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setVerifyHostname(boolean verifyHostname) {
<b class="nc">&nbsp;			this.verifyHostname = verifyHostname;</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
<b class="nc">&nbsp;	public static class Cache {</b>
&nbsp;
<b class="nc">&nbsp;		private final Channel channel = new Channel();</b>
&nbsp;
<b class="nc">&nbsp;		private final Connection connection = new Connection();</b>
&nbsp;
&nbsp;		public Channel getChannel() {
<b class="nc">&nbsp;			return this.channel;</b>
&nbsp;		}
&nbsp;
&nbsp;		public Connection getConnection() {
<b class="nc">&nbsp;			return this.connection;</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		public static class Channel {</b>
&nbsp;
&nbsp;			/**
&nbsp;			 * Number of channels to retain in the cache. When &quot;check-timeout&quot; &gt; 0, max
&nbsp;			 * channels per connection.
&nbsp;			 */
&nbsp;			private Integer size;
&nbsp;
&nbsp;			/**
&nbsp;			 * Duration to wait to obtain a channel if the cache size has been reached. If
&nbsp;			 * 0, always create a new channel.
&nbsp;			 */
&nbsp;			private Duration checkoutTimeout;
&nbsp;
&nbsp;			public Integer getSize() {
<b class="nc">&nbsp;				return this.size;</b>
&nbsp;			}
&nbsp;
&nbsp;			public void setSize(Integer size) {
<b class="nc">&nbsp;				this.size = size;</b>
&nbsp;			}
&nbsp;
&nbsp;			public Duration getCheckoutTimeout() {
<b class="nc">&nbsp;				return this.checkoutTimeout;</b>
&nbsp;			}
&nbsp;
&nbsp;			public void setCheckoutTimeout(Duration checkoutTimeout) {
<b class="nc">&nbsp;				this.checkoutTimeout = checkoutTimeout;</b>
&nbsp;			}
&nbsp;
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		public static class Connection {</b>
&nbsp;
&nbsp;			/**
&nbsp;			 * Connection factory cache mode.
&nbsp;			 */
<b class="nc">&nbsp;			private CacheMode mode = CacheMode.CHANNEL;</b>
&nbsp;
&nbsp;			/**
&nbsp;			 * Number of connections to cache. Only applies when mode is CONNECTION.
&nbsp;			 */
&nbsp;			private Integer size;
&nbsp;
&nbsp;			public CacheMode getMode() {
<b class="nc">&nbsp;				return this.mode;</b>
&nbsp;			}
&nbsp;
&nbsp;			public void setMode(CacheMode mode) {
<b class="nc">&nbsp;				this.mode = mode;</b>
&nbsp;			}
&nbsp;
&nbsp;			public Integer getSize() {
<b class="nc">&nbsp;				return this.size;</b>
&nbsp;			}
&nbsp;
&nbsp;			public void setSize(Integer size) {
<b class="nc">&nbsp;				this.size = size;</b>
&nbsp;			}
&nbsp;
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
<b class="nc">&nbsp;	public enum ContainerType {</b>
&nbsp;
&nbsp;		/**
&nbsp;		 * Container where the RabbitMQ consumer dispatches messages to an invoker thread.
&nbsp;		 */
<b class="nc">&nbsp;		SIMPLE,</b>
&nbsp;
&nbsp;		/**
&nbsp;		 * Container where the listener is invoked directly on the RabbitMQ consumer
&nbsp;		 * thread.
&nbsp;		 */
<b class="nc">&nbsp;		DIRECT,</b>
&nbsp;
&nbsp;		/**
&nbsp;		 * Container that uses the RabbitMQ Stream Client.
&nbsp;		 */
<b class="nc">&nbsp;		STREAM</b>
&nbsp;
&nbsp;	}
&nbsp;
<b class="nc">&nbsp;	public static class Listener {</b>
&nbsp;
&nbsp;		/**
&nbsp;		 * Listener container type.
&nbsp;		 */
<b class="nc">&nbsp;		private ContainerType type = ContainerType.SIMPLE;</b>
&nbsp;
<b class="nc">&nbsp;		private final SimpleContainer simple = new SimpleContainer();</b>
&nbsp;
<b class="nc">&nbsp;		private final DirectContainer direct = new DirectContainer();</b>
&nbsp;
<b class="nc">&nbsp;		private final StreamContainer stream = new StreamContainer();</b>
&nbsp;
&nbsp;		public ContainerType getType() {
<b class="nc">&nbsp;			return this.type;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setType(ContainerType containerType) {
<b class="nc">&nbsp;			this.type = containerType;</b>
&nbsp;		}
&nbsp;
&nbsp;		public SimpleContainer getSimple() {
<b class="nc">&nbsp;			return this.simple;</b>
&nbsp;		}
&nbsp;
&nbsp;		public DirectContainer getDirect() {
<b class="nc">&nbsp;			return this.direct;</b>
&nbsp;		}
&nbsp;
&nbsp;		public StreamContainer getStream() {
<b class="nc">&nbsp;			return this.stream;</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
<b class="nc">&nbsp;	public abstract static class BaseContainer {</b>
&nbsp;
&nbsp;		/**
&nbsp;		 * Whether to enable observation.
&nbsp;		 */
&nbsp;		private boolean observationEnabled;
&nbsp;
&nbsp;		public boolean isObservationEnabled() {
<b class="nc">&nbsp;			return this.observationEnabled;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setObservationEnabled(boolean observationEnabled) {
<b class="nc">&nbsp;			this.observationEnabled = observationEnabled;</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
<b class="nc">&nbsp;	public abstract static class AmqpContainer extends BaseContainer {</b>
&nbsp;
&nbsp;		/**
&nbsp;		 * Whether to start the container automatically on startup.
&nbsp;		 */
<b class="nc">&nbsp;		private boolean autoStartup = true;</b>
&nbsp;
&nbsp;		/**
&nbsp;		 * Acknowledge mode of container.
&nbsp;		 */
&nbsp;		private AcknowledgeMode acknowledgeMode;
&nbsp;
&nbsp;		/**
&nbsp;		 * Maximum number of unacknowledged messages that can be outstanding at each
&nbsp;		 * consumer.
&nbsp;		 */
&nbsp;		private Integer prefetch;
&nbsp;
&nbsp;		/**
&nbsp;		 * Whether rejected deliveries are re-queued by default.
&nbsp;		 */
&nbsp;		private Boolean defaultRequeueRejected;
&nbsp;
&nbsp;		/**
&nbsp;		 * How often idle container events should be published.
&nbsp;		 */
&nbsp;		private Duration idleEventInterval;
&nbsp;
&nbsp;		/**
&nbsp;		 * Whether the container should present batched messages as discrete messages or
&nbsp;		 * call the listener with the batch.
&nbsp;		 */
<b class="nc">&nbsp;		private boolean deBatchingEnabled = true;</b>
&nbsp;
&nbsp;		/**
&nbsp;		 * Whether the container (when stopped) should stop immediately after processing
&nbsp;		 * the current message or stop after processing all pre-fetched messages.
&nbsp;		 */
&nbsp;		private boolean forceStop;
&nbsp;
&nbsp;		/**
&nbsp;		 * Optional properties for a retry interceptor.
&nbsp;		 */
<b class="nc">&nbsp;		private final ListenerRetry retry = new ListenerRetry();</b>
&nbsp;
&nbsp;		public boolean isAutoStartup() {
<b class="nc">&nbsp;			return this.autoStartup;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setAutoStartup(boolean autoStartup) {
<b class="nc">&nbsp;			this.autoStartup = autoStartup;</b>
&nbsp;		}
&nbsp;
&nbsp;		public AcknowledgeMode getAcknowledgeMode() {
<b class="nc">&nbsp;			return this.acknowledgeMode;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setAcknowledgeMode(AcknowledgeMode acknowledgeMode) {
<b class="nc">&nbsp;			this.acknowledgeMode = acknowledgeMode;</b>
&nbsp;		}
&nbsp;
&nbsp;		public Integer getPrefetch() {
<b class="nc">&nbsp;			return this.prefetch;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setPrefetch(Integer prefetch) {
<b class="nc">&nbsp;			this.prefetch = prefetch;</b>
&nbsp;		}
&nbsp;
&nbsp;		public Boolean getDefaultRequeueRejected() {
<b class="nc">&nbsp;			return this.defaultRequeueRejected;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setDefaultRequeueRejected(Boolean defaultRequeueRejected) {
<b class="nc">&nbsp;			this.defaultRequeueRejected = defaultRequeueRejected;</b>
&nbsp;		}
&nbsp;
&nbsp;		public Duration getIdleEventInterval() {
<b class="nc">&nbsp;			return this.idleEventInterval;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setIdleEventInterval(Duration idleEventInterval) {
<b class="nc">&nbsp;			this.idleEventInterval = idleEventInterval;</b>
&nbsp;		}
&nbsp;
&nbsp;		public abstract boolean isMissingQueuesFatal();
&nbsp;
&nbsp;		public boolean isDeBatchingEnabled() {
<b class="nc">&nbsp;			return this.deBatchingEnabled;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setDeBatchingEnabled(boolean deBatchingEnabled) {
<b class="nc">&nbsp;			this.deBatchingEnabled = deBatchingEnabled;</b>
&nbsp;		}
&nbsp;
&nbsp;		public boolean isForceStop() {
<b class="nc">&nbsp;			return this.forceStop;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setForceStop(boolean forceStop) {
<b class="nc">&nbsp;			this.forceStop = forceStop;</b>
&nbsp;		}
&nbsp;
&nbsp;		public ListenerRetry getRetry() {
<b class="nc">&nbsp;			return this.retry;</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Configuration properties for {@code SimpleMessageListenerContainer}.
&nbsp;	 */
<b class="nc">&nbsp;	public static class SimpleContainer extends AmqpContainer {</b>
&nbsp;
&nbsp;		/**
&nbsp;		 * Minimum number of listener invoker threads.
&nbsp;		 */
&nbsp;		private Integer concurrency;
&nbsp;
&nbsp;		/**
&nbsp;		 * Maximum number of listener invoker threads.
&nbsp;		 */
&nbsp;		private Integer maxConcurrency;
&nbsp;
&nbsp;		/**
&nbsp;		 * Batch size, expressed as the number of physical messages, to be used by the
&nbsp;		 * container.
&nbsp;		 */
&nbsp;		private Integer batchSize;
&nbsp;
&nbsp;		/**
&nbsp;		 * Whether to fail if the queues declared by the container are not available on
&nbsp;		 * the broker and/or whether to stop the container if one or more queues are
&nbsp;		 * deleted at runtime.
&nbsp;		 */
<b class="nc">&nbsp;		private boolean missingQueuesFatal = true;</b>
&nbsp;
&nbsp;		/**
&nbsp;		 * Whether the container creates a batch of messages based on the
&nbsp;		 * &#39;receive-timeout&#39; and &#39;batch-size&#39;. Coerces &#39;de-batching-enabled&#39; to true to
&nbsp;		 * include the contents of a producer created batch in the batch as discrete
&nbsp;		 * records.
&nbsp;		 */
&nbsp;		private boolean consumerBatchEnabled;
&nbsp;
&nbsp;		public Integer getConcurrency() {
<b class="nc">&nbsp;			return this.concurrency;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setConcurrency(Integer concurrency) {
<b class="nc">&nbsp;			this.concurrency = concurrency;</b>
&nbsp;		}
&nbsp;
&nbsp;		public Integer getMaxConcurrency() {
<b class="nc">&nbsp;			return this.maxConcurrency;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setMaxConcurrency(Integer maxConcurrency) {
<b class="nc">&nbsp;			this.maxConcurrency = maxConcurrency;</b>
&nbsp;		}
&nbsp;
&nbsp;		public Integer getBatchSize() {
<b class="nc">&nbsp;			return this.batchSize;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setBatchSize(Integer batchSize) {
<b class="nc">&nbsp;			this.batchSize = batchSize;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public boolean isMissingQueuesFatal() {
<b class="nc">&nbsp;			return this.missingQueuesFatal;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setMissingQueuesFatal(boolean missingQueuesFatal) {
<b class="nc">&nbsp;			this.missingQueuesFatal = missingQueuesFatal;</b>
&nbsp;		}
&nbsp;
&nbsp;		public boolean isConsumerBatchEnabled() {
<b class="nc">&nbsp;			return this.consumerBatchEnabled;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setConsumerBatchEnabled(boolean consumerBatchEnabled) {
<b class="nc">&nbsp;			this.consumerBatchEnabled = consumerBatchEnabled;</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Configuration properties for {@code DirectMessageListenerContainer}.
&nbsp;	 */
<b class="nc">&nbsp;	public static class DirectContainer extends AmqpContainer {</b>
&nbsp;
&nbsp;		/**
&nbsp;		 * Number of consumers per queue.
&nbsp;		 */
&nbsp;		private Integer consumersPerQueue;
&nbsp;
&nbsp;		/**
&nbsp;		 * Whether to fail if the queues declared by the container are not available on
&nbsp;		 * the broker.
&nbsp;		 */
<b class="nc">&nbsp;		private boolean missingQueuesFatal = false;</b>
&nbsp;
&nbsp;		public Integer getConsumersPerQueue() {
<b class="nc">&nbsp;			return this.consumersPerQueue;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setConsumersPerQueue(Integer consumersPerQueue) {
<b class="nc">&nbsp;			this.consumersPerQueue = consumersPerQueue;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public boolean isMissingQueuesFatal() {
<b class="nc">&nbsp;			return this.missingQueuesFatal;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setMissingQueuesFatal(boolean missingQueuesFatal) {
<b class="nc">&nbsp;			this.missingQueuesFatal = missingQueuesFatal;</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
<b class="nc">&nbsp;	public static class StreamContainer extends BaseContainer {</b>
&nbsp;
&nbsp;		/**
&nbsp;		 * Whether the container will support listeners that consume native stream
&nbsp;		 * messages instead of Spring AMQP messages.
&nbsp;		 */
&nbsp;		private boolean nativeListener;
&nbsp;
&nbsp;		public boolean isNativeListener() {
<b class="nc">&nbsp;			return this.nativeListener;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setNativeListener(boolean nativeListener) {
<b class="nc">&nbsp;			this.nativeListener = nativeListener;</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
<b class="nc">&nbsp;	public static class Template {</b>
&nbsp;
<b class="nc">&nbsp;		private final Retry retry = new Retry();</b>
&nbsp;
&nbsp;		/**
&nbsp;		 * Whether to enable mandatory messages.
&nbsp;		 */
&nbsp;		private Boolean mandatory;
&nbsp;
&nbsp;		/**
&nbsp;		 * Timeout for receive() operations.
&nbsp;		 */
&nbsp;		private Duration receiveTimeout;
&nbsp;
&nbsp;		/**
&nbsp;		 * Timeout for sendAndReceive() operations.
&nbsp;		 */
&nbsp;		private Duration replyTimeout;
&nbsp;
&nbsp;		/**
&nbsp;		 * Name of the default exchange to use for send operations.
&nbsp;		 */
<b class="nc">&nbsp;		private String exchange = &quot;&quot;;</b>
&nbsp;
&nbsp;		/**
&nbsp;		 * Value of a default routing key to use for send operations.
&nbsp;		 */
<b class="nc">&nbsp;		private String routingKey = &quot;&quot;;</b>
&nbsp;
&nbsp;		/**
&nbsp;		 * Name of the default queue to receive messages from when none is specified
&nbsp;		 * explicitly.
&nbsp;		 */
&nbsp;		private String defaultReceiveQueue;
&nbsp;
&nbsp;		/**
&nbsp;		 * Whether to enable observation.
&nbsp;		 */
&nbsp;		private boolean observationEnabled;
&nbsp;
&nbsp;		public Retry getRetry() {
<b class="nc">&nbsp;			return this.retry;</b>
&nbsp;		}
&nbsp;
&nbsp;		public Boolean getMandatory() {
<b class="nc">&nbsp;			return this.mandatory;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setMandatory(Boolean mandatory) {
<b class="nc">&nbsp;			this.mandatory = mandatory;</b>
&nbsp;		}
&nbsp;
&nbsp;		public Duration getReceiveTimeout() {
<b class="nc">&nbsp;			return this.receiveTimeout;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setReceiveTimeout(Duration receiveTimeout) {
<b class="nc">&nbsp;			this.receiveTimeout = receiveTimeout;</b>
&nbsp;		}
&nbsp;
&nbsp;		public Duration getReplyTimeout() {
<b class="nc">&nbsp;			return this.replyTimeout;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setReplyTimeout(Duration replyTimeout) {
<b class="nc">&nbsp;			this.replyTimeout = replyTimeout;</b>
&nbsp;		}
&nbsp;
&nbsp;		public String getExchange() {
<b class="nc">&nbsp;			return this.exchange;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setExchange(String exchange) {
<b class="nc">&nbsp;			this.exchange = exchange;</b>
&nbsp;		}
&nbsp;
&nbsp;		public String getRoutingKey() {
<b class="nc">&nbsp;			return this.routingKey;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setRoutingKey(String routingKey) {
<b class="nc">&nbsp;			this.routingKey = routingKey;</b>
&nbsp;		}
&nbsp;
&nbsp;		public String getDefaultReceiveQueue() {
<b class="nc">&nbsp;			return this.defaultReceiveQueue;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setDefaultReceiveQueue(String defaultReceiveQueue) {
<b class="nc">&nbsp;			this.defaultReceiveQueue = defaultReceiveQueue;</b>
&nbsp;		}
&nbsp;
&nbsp;		public boolean isObservationEnabled() {
<b class="nc">&nbsp;			return this.observationEnabled;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setObservationEnabled(boolean observationEnabled) {
<b class="nc">&nbsp;			this.observationEnabled = observationEnabled;</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
<b class="nc">&nbsp;	public static class Retry {</b>
&nbsp;
&nbsp;		/**
&nbsp;		 * Whether publishing retries are enabled.
&nbsp;		 */
&nbsp;		private boolean enabled;
&nbsp;
&nbsp;		/**
&nbsp;		 * Maximum number of attempts to deliver a message.
&nbsp;		 */
<b class="nc">&nbsp;		private int maxAttempts = 3;</b>
&nbsp;
&nbsp;		/**
&nbsp;		 * Duration between the first and second attempt to deliver a message.
&nbsp;		 */
<b class="nc">&nbsp;		private Duration initialInterval = Duration.ofMillis(1000);</b>
&nbsp;
&nbsp;		/**
&nbsp;		 * Multiplier to apply to the previous retry interval.
&nbsp;		 */
<b class="nc">&nbsp;		private double multiplier = 1.0;</b>
&nbsp;
&nbsp;		/**
&nbsp;		 * Maximum duration between attempts.
&nbsp;		 */
<b class="nc">&nbsp;		private Duration maxInterval = Duration.ofMillis(10000);</b>
&nbsp;
&nbsp;		public boolean isEnabled() {
<b class="nc">&nbsp;			return this.enabled;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setEnabled(boolean enabled) {
<b class="nc">&nbsp;			this.enabled = enabled;</b>
&nbsp;		}
&nbsp;
&nbsp;		public int getMaxAttempts() {
<b class="nc">&nbsp;			return this.maxAttempts;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setMaxAttempts(int maxAttempts) {
<b class="nc">&nbsp;			this.maxAttempts = maxAttempts;</b>
&nbsp;		}
&nbsp;
&nbsp;		public Duration getInitialInterval() {
<b class="nc">&nbsp;			return this.initialInterval;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setInitialInterval(Duration initialInterval) {
<b class="nc">&nbsp;			this.initialInterval = initialInterval;</b>
&nbsp;		}
&nbsp;
&nbsp;		public double getMultiplier() {
<b class="nc">&nbsp;			return this.multiplier;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setMultiplier(double multiplier) {
<b class="nc">&nbsp;			this.multiplier = multiplier;</b>
&nbsp;		}
&nbsp;
&nbsp;		public Duration getMaxInterval() {
<b class="nc">&nbsp;			return this.maxInterval;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setMaxInterval(Duration maxInterval) {
<b class="nc">&nbsp;			this.maxInterval = maxInterval;</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
<b class="nc">&nbsp;	public static class ListenerRetry extends Retry {</b>
&nbsp;
&nbsp;		/**
&nbsp;		 * Whether retries are stateless or stateful.
&nbsp;		 */
<b class="nc">&nbsp;		private boolean stateless = true;</b>
&nbsp;
&nbsp;		public boolean isStateless() {
<b class="nc">&nbsp;			return this.stateless;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setStateless(boolean stateless) {
<b class="nc">&nbsp;			this.stateless = stateless;</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	private static final class Address {
&nbsp;
&nbsp;		private static final String PREFIX_AMQP = &quot;amqp://&quot;;
&nbsp;
&nbsp;		private static final String PREFIX_AMQP_SECURE = &quot;amqps://&quot;;
&nbsp;
&nbsp;		private String host;
&nbsp;
&nbsp;		private int port;
&nbsp;
&nbsp;		private String username;
&nbsp;
&nbsp;		private String password;
&nbsp;
&nbsp;		private String virtualHost;
&nbsp;
&nbsp;		private Boolean secureConnection;
&nbsp;
<b class="nc">&nbsp;		private Address(String input, boolean sslEnabled) {</b>
<b class="nc">&nbsp;			input = input.trim();</b>
<b class="nc">&nbsp;			input = trimPrefix(input);</b>
<b class="nc">&nbsp;			input = parseUsernameAndPassword(input);</b>
<b class="nc">&nbsp;			input = parseVirtualHost(input);</b>
<b class="nc">&nbsp;			parseHostAndPort(input, sslEnabled);</b>
&nbsp;		}
&nbsp;
&nbsp;		private String trimPrefix(String input) {
<b class="nc">&nbsp;			if (input.startsWith(PREFIX_AMQP_SECURE)) {</b>
<b class="nc">&nbsp;				this.secureConnection = true;</b>
<b class="nc">&nbsp;				return input.substring(PREFIX_AMQP_SECURE.length());</b>
&nbsp;			}
<b class="nc">&nbsp;			if (input.startsWith(PREFIX_AMQP)) {</b>
<b class="nc">&nbsp;				this.secureConnection = false;</b>
<b class="nc">&nbsp;				return input.substring(PREFIX_AMQP.length());</b>
&nbsp;			}
<b class="nc">&nbsp;			return input;</b>
&nbsp;		}
&nbsp;
&nbsp;		private String parseUsernameAndPassword(String input) {
<b class="nc">&nbsp;			String[] splitInput = StringUtils.split(input, &quot;@&quot;);</b>
<b class="nc">&nbsp;			if (splitInput == null) {</b>
<b class="nc">&nbsp;				return input;</b>
&nbsp;			}
<b class="nc">&nbsp;			String credentials = splitInput[0];</b>
<b class="nc">&nbsp;			String[] splitCredentials = StringUtils.split(credentials, &quot;:&quot;);</b>
<b class="nc">&nbsp;			if (splitCredentials == null) {</b>
<b class="nc">&nbsp;				this.username = credentials;</b>
&nbsp;			}
&nbsp;			else {
<b class="nc">&nbsp;				this.username = splitCredentials[0];</b>
<b class="nc">&nbsp;				this.password = splitCredentials[1];</b>
&nbsp;			}
<b class="nc">&nbsp;			return splitInput[1];</b>
&nbsp;		}
&nbsp;
&nbsp;		private String parseVirtualHost(String input) {
<b class="nc">&nbsp;			int hostIndex = input.indexOf(&#39;/&#39;);</b>
<b class="nc">&nbsp;			if (hostIndex &gt;= 0) {</b>
<b class="nc">&nbsp;				this.virtualHost = input.substring(hostIndex + 1);</b>
<b class="nc">&nbsp;				if (this.virtualHost.isEmpty()) {</b>
<b class="nc">&nbsp;					this.virtualHost = &quot;/&quot;;</b>
&nbsp;				}
<b class="nc">&nbsp;				input = input.substring(0, hostIndex);</b>
&nbsp;			}
<b class="nc">&nbsp;			return input;</b>
&nbsp;		}
&nbsp;
&nbsp;		private void parseHostAndPort(String input, boolean sslEnabled) {
<b class="nc">&nbsp;			int bracketIndex = input.lastIndexOf(&#39;]&#39;);</b>
<b class="nc">&nbsp;			int colonIndex = input.lastIndexOf(&#39;:&#39;);</b>
<b class="nc">&nbsp;			if (colonIndex == -1 || colonIndex &lt; bracketIndex) {</b>
<b class="nc">&nbsp;				this.host = input;</b>
<b class="nc">&nbsp;				this.port = (determineSslEnabled(sslEnabled)) ? DEFAULT_PORT_SECURE : DEFAULT_PORT;</b>
&nbsp;			}
&nbsp;			else {
<b class="nc">&nbsp;				this.host = input.substring(0, colonIndex);</b>
<b class="nc">&nbsp;				this.port = Integer.parseInt(input.substring(colonIndex + 1));</b>
&nbsp;			}
&nbsp;		}
&nbsp;
&nbsp;		private boolean determineSslEnabled(boolean sslEnabled) {
<b class="nc">&nbsp;			return (this.secureConnection != null) ? this.secureConnection : sslEnabled;</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
<b class="nc">&nbsp;	public static final class Stream {</b>
&nbsp;
&nbsp;		/**
&nbsp;		 * Host of a RabbitMQ instance with the Stream plugin enabled.
&nbsp;		 */
<b class="nc">&nbsp;		private String host = &quot;localhost&quot;;</b>
&nbsp;
&nbsp;		/**
&nbsp;		 * Stream port of a RabbitMQ instance with the Stream plugin enabled.
&nbsp;		 */
<b class="nc">&nbsp;		private int port = DEFAULT_STREAM_PORT;</b>
&nbsp;
&nbsp;		/**
&nbsp;		 * Virtual host of a RabbitMQ instance with the Stream plugin enabled. When not
&nbsp;		 * set, spring.rabbitmq.virtual-host is used.
&nbsp;		 */
&nbsp;		private String virtualHost;
&nbsp;
&nbsp;		/**
&nbsp;		 * Login user to authenticate to the broker. When not set,
&nbsp;		 * spring.rabbitmq.username is used.
&nbsp;		 */
&nbsp;		private String username;
&nbsp;
&nbsp;		/**
&nbsp;		 * Login password to authenticate to the broker. When not set
&nbsp;		 * spring.rabbitmq.password is used.
&nbsp;		 */
&nbsp;		private String password;
&nbsp;
&nbsp;		/**
&nbsp;		 * Name of the stream.
&nbsp;		 */
&nbsp;		private String name;
&nbsp;
&nbsp;		public String getHost() {
<b class="nc">&nbsp;			return this.host;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setHost(String host) {
<b class="nc">&nbsp;			this.host = host;</b>
&nbsp;		}
&nbsp;
&nbsp;		public int getPort() {
<b class="nc">&nbsp;			return this.port;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setPort(int port) {
<b class="nc">&nbsp;			this.port = port;</b>
&nbsp;		}
&nbsp;
&nbsp;		public String getVirtualHost() {
<b class="nc">&nbsp;			return this.virtualHost;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setVirtualHost(String virtualHost) {
<b class="nc">&nbsp;			this.virtualHost = virtualHost;</b>
&nbsp;		}
&nbsp;
&nbsp;		public String getUsername() {
<b class="nc">&nbsp;			return this.username;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setUsername(String username) {
<b class="nc">&nbsp;			this.username = username;</b>
&nbsp;		}
&nbsp;
&nbsp;		public String getPassword() {
<b class="nc">&nbsp;			return this.password;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setPassword(String password) {
<b class="nc">&nbsp;			this.password = password;</b>
&nbsp;		}
&nbsp;
&nbsp;		public String getName() {
<b class="nc">&nbsp;			return this.name;</b>
&nbsp;		}
&nbsp;
&nbsp;		public void setName(String name) {
<b class="nc">&nbsp;			this.name = name;</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-04-01 11:12</div>
</div>
</body>
</html>
