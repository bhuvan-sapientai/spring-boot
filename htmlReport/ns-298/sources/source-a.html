


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > JarFile</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.springframework.boot.loader.jar</a>
</div>

<h1>Coverage Summary for Class: JarFile (org.springframework.boot.loader.jar)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">JarFile</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/44)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/116)
  </span>
</td>
</tr>
  <tr>
    <td class="name">JarFile$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JarFile$JarEntryEnumeration</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/51)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/126)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2012-2023 the original author or authors.
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *      https://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;
&nbsp;package org.springframework.boot.loader.jar;
&nbsp;
&nbsp;import java.io.File;
&nbsp;import java.io.FilePermission;
&nbsp;import java.io.IOException;
&nbsp;import java.io.InputStream;
&nbsp;import java.lang.ref.SoftReference;
&nbsp;import java.net.MalformedURLException;
&nbsp;import java.net.URL;
&nbsp;import java.net.URLStreamHandler;
&nbsp;import java.net.URLStreamHandlerFactory;
&nbsp;import java.security.Permission;
&nbsp;import java.util.Enumeration;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.Spliterator;
&nbsp;import java.util.Spliterators;
&nbsp;import java.util.function.Supplier;
&nbsp;import java.util.jar.Manifest;
&nbsp;import java.util.stream.Stream;
&nbsp;import java.util.stream.StreamSupport;
&nbsp;import java.util.zip.ZipEntry;
&nbsp;
&nbsp;import org.springframework.boot.loader.data.RandomAccessData;
&nbsp;import org.springframework.boot.loader.data.RandomAccessDataFile;
&nbsp;
&nbsp;/**
&nbsp; * Extended variant of {@link java.util.jar.JarFile} that behaves in the same way but
&nbsp; * offers the following additional functionality.
&nbsp; * &lt;ul&gt;
&nbsp; * &lt;li&gt;A nested {@link JarFile} can be {@link #getNestedJarFile(ZipEntry) obtained} based
&nbsp; * on any directory entry.&lt;/li&gt;
&nbsp; * &lt;li&gt;A nested {@link JarFile} can be {@link #getNestedJarFile(ZipEntry) obtained} for
&nbsp; * embedded JAR files (as long as their entry is not compressed).&lt;/li&gt;
&nbsp; * &lt;/ul&gt;
&nbsp; *
&nbsp; * @author Phillip Webb
&nbsp; * @author Andy Wilkinson
&nbsp; * @since 1.0.0
&nbsp; */
&nbsp;public class JarFile extends AbstractJarFile implements Iterable&lt;java.util.jar.JarEntry&gt; {
&nbsp;
&nbsp;	private static final String MANIFEST_NAME = &quot;META-INF/MANIFEST.MF&quot;;
&nbsp;
&nbsp;	private static final String PROTOCOL_HANDLER = &quot;java.protocol.handler.pkgs&quot;;
&nbsp;
&nbsp;	private static final String HANDLERS_PACKAGE = &quot;org.springframework.boot.loader&quot;;
&nbsp;
<b class="nc">&nbsp;	private static final AsciiBytes META_INF = new AsciiBytes(&quot;META-INF/&quot;);</b>
&nbsp;
<b class="nc">&nbsp;	private static final AsciiBytes SIGNATURE_FILE_EXTENSION = new AsciiBytes(&quot;.SF&quot;);</b>
&nbsp;
&nbsp;	private static final String READ_ACTION = &quot;read&quot;;
&nbsp;
&nbsp;	private final RandomAccessDataFile rootFile;
&nbsp;
&nbsp;	private final String pathFromRoot;
&nbsp;
&nbsp;	private final RandomAccessData data;
&nbsp;
&nbsp;	private final JarFileType type;
&nbsp;
&nbsp;	private URL url;
&nbsp;
&nbsp;	private String urlString;
&nbsp;
&nbsp;	private final JarFileEntries entries;
&nbsp;
&nbsp;	private final Supplier&lt;Manifest&gt; manifestSupplier;
&nbsp;
&nbsp;	private SoftReference&lt;Manifest&gt; manifest;
&nbsp;
&nbsp;	private boolean signed;
&nbsp;
&nbsp;	private String comment;
&nbsp;
&nbsp;	private volatile boolean closed;
&nbsp;
&nbsp;	private volatile JarFileWrapper wrapper;
&nbsp;
&nbsp;	/**
&nbsp;	 * Create a new {@link JarFile} backed by the specified file.
&nbsp;	 * @param file the root jar file
&nbsp;	 * @throws IOException if the file cannot be read
&nbsp;	 */
&nbsp;	public JarFile(File file) throws IOException {
<b class="nc">&nbsp;		this(new RandomAccessDataFile(file));</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Create a new {@link JarFile} backed by the specified file.
&nbsp;	 * @param file the root jar file
&nbsp;	 * @throws IOException if the file cannot be read
&nbsp;	 */
&nbsp;	JarFile(RandomAccessDataFile file) throws IOException {
<b class="nc">&nbsp;		this(file, &quot;&quot;, file, JarFileType.DIRECT);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Private constructor used to create a new {@link JarFile} either directly or from a
&nbsp;	 * nested entry.
&nbsp;	 * @param rootFile the root jar file
&nbsp;	 * @param pathFromRoot the name of this file
&nbsp;	 * @param data the underlying data
&nbsp;	 * @param type the type of the jar file
&nbsp;	 * @throws IOException if the file cannot be read
&nbsp;	 */
&nbsp;	private JarFile(RandomAccessDataFile rootFile, String pathFromRoot, RandomAccessData data, JarFileType type)
&nbsp;			throws IOException {
<b class="nc">&nbsp;		this(rootFile, pathFromRoot, data, null, type, null);</b>
&nbsp;	}
&nbsp;
&nbsp;	private JarFile(RandomAccessDataFile rootFile, String pathFromRoot, RandomAccessData data, JarEntryFilter filter,
&nbsp;			JarFileType type, Supplier&lt;Manifest&gt; manifestSupplier) throws IOException {
<b class="nc">&nbsp;		super(rootFile.getFile());</b>
<b class="nc">&nbsp;		super.close();</b>
<b class="nc">&nbsp;		this.rootFile = rootFile;</b>
<b class="nc">&nbsp;		this.pathFromRoot = pathFromRoot;</b>
<b class="nc">&nbsp;		CentralDirectoryParser parser = new CentralDirectoryParser();</b>
<b class="nc">&nbsp;		this.entries = parser.addVisitor(new JarFileEntries(this, filter));</b>
<b class="nc">&nbsp;		this.type = type;</b>
<b class="nc">&nbsp;		parser.addVisitor(centralDirectoryVisitor());</b>
&nbsp;		try {
<b class="nc">&nbsp;			this.data = parser.parse(data, filter == null);</b>
&nbsp;		}
<b class="nc">&nbsp;		catch (RuntimeException ex) {</b>
&nbsp;			try {
<b class="nc">&nbsp;				this.rootFile.close();</b>
<b class="nc">&nbsp;				super.close();</b>
&nbsp;			}
<b class="nc">&nbsp;			catch (IOException ioex) {</b>
<b class="nc">&nbsp;			}</b>
<b class="nc">&nbsp;			throw ex;</b>
<b class="nc">&nbsp;		}</b>
<b class="nc">&nbsp;		this.manifestSupplier = (manifestSupplier != null) ? manifestSupplier : () -&gt; {</b>
<b class="nc">&nbsp;			try (InputStream inputStream = getInputStream(MANIFEST_NAME)) {</b>
<b class="nc">&nbsp;				if (inputStream == null) {</b>
<b class="nc">&nbsp;					return null;</b>
&nbsp;				}
<b class="nc">&nbsp;				return new Manifest(inputStream);</b>
<b class="nc">&nbsp;			}</b>
<b class="nc">&nbsp;			catch (IOException ex) {</b>
<b class="nc">&nbsp;				throw new RuntimeException(ex);</b>
&nbsp;			}
&nbsp;		};
&nbsp;	}
&nbsp;
&nbsp;	private CentralDirectoryVisitor centralDirectoryVisitor() {
<b class="nc">&nbsp;		return new CentralDirectoryVisitor() {</b>
&nbsp;
&nbsp;			@Override
&nbsp;			public void visitStart(CentralDirectoryEndRecord endRecord, RandomAccessData centralDirectoryData) {
<b class="nc">&nbsp;				JarFile.this.comment = endRecord.getComment();</b>
&nbsp;			}
&nbsp;
&nbsp;			@Override
&nbsp;			public void visitFileHeader(CentralDirectoryFileHeader fileHeader, long dataOffset) {
<b class="nc">&nbsp;				AsciiBytes name = fileHeader.getName();</b>
<b class="nc">&nbsp;				if (name.startsWith(META_INF) &amp;&amp; name.endsWith(SIGNATURE_FILE_EXTENSION)) {</b>
<b class="nc">&nbsp;					JarFile.this.signed = true;</b>
&nbsp;				}
&nbsp;			}
&nbsp;
&nbsp;			@Override
&nbsp;			public void visitEnd() {
<b class="nc">&nbsp;			}</b>
&nbsp;
&nbsp;		};
&nbsp;	}
&nbsp;
&nbsp;	JarFileWrapper getWrapper() throws IOException {
<b class="nc">&nbsp;		JarFileWrapper wrapper = this.wrapper;</b>
<b class="nc">&nbsp;		if (wrapper == null) {</b>
<b class="nc">&nbsp;			wrapper = new JarFileWrapper(this);</b>
<b class="nc">&nbsp;			this.wrapper = wrapper;</b>
&nbsp;		}
<b class="nc">&nbsp;		return wrapper;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	Permission getPermission() {
<b class="nc">&nbsp;		return new FilePermission(this.rootFile.getFile().getPath(), READ_ACTION);</b>
&nbsp;	}
&nbsp;
&nbsp;	protected final RandomAccessDataFile getRootJarFile() {
<b class="nc">&nbsp;		return this.rootFile;</b>
&nbsp;	}
&nbsp;
&nbsp;	RandomAccessData getData() {
<b class="nc">&nbsp;		return this.data;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public Manifest getManifest() throws IOException {
<b class="nc">&nbsp;		Manifest manifest = (this.manifest != null) ? this.manifest.get() : null;</b>
<b class="nc">&nbsp;		if (manifest == null) {</b>
&nbsp;			try {
<b class="nc">&nbsp;				manifest = this.manifestSupplier.get();</b>
&nbsp;			}
<b class="nc">&nbsp;			catch (RuntimeException ex) {</b>
<b class="nc">&nbsp;				throw new IOException(ex);</b>
<b class="nc">&nbsp;			}</b>
<b class="nc">&nbsp;			this.manifest = new SoftReference&lt;&gt;(manifest);</b>
&nbsp;		}
<b class="nc">&nbsp;		return manifest;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public Enumeration&lt;java.util.jar.JarEntry&gt; entries() {
<b class="nc">&nbsp;		return new JarEntryEnumeration(this.entries.iterator());</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public Stream&lt;java.util.jar.JarEntry&gt; stream() {
<b class="nc">&nbsp;		Spliterator&lt;java.util.jar.JarEntry&gt; spliterator = Spliterators.spliterator(iterator(), size(),</b>
&nbsp;				Spliterator.ORDERED | Spliterator.DISTINCT | Spliterator.IMMUTABLE | Spliterator.NONNULL);
<b class="nc">&nbsp;		return StreamSupport.stream(spliterator, false);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Return an iterator for the contained entries.
&nbsp;	 * @since 2.3.0
&nbsp;	 * @see java.lang.Iterable#iterator()
&nbsp;	 */
&nbsp;	@Override
&nbsp;	@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
&nbsp;	public Iterator&lt;java.util.jar.JarEntry&gt; iterator() {
<b class="nc">&nbsp;		return (Iterator) this.entries.iterator(this::ensureOpen);</b>
&nbsp;	}
&nbsp;
&nbsp;	public JarEntry getJarEntry(CharSequence name) {
<b class="nc">&nbsp;		return this.entries.getEntry(name);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public JarEntry getJarEntry(String name) {
<b class="nc">&nbsp;		return (JarEntry) getEntry(name);</b>
&nbsp;	}
&nbsp;
&nbsp;	public boolean containsEntry(String name) {
<b class="nc">&nbsp;		return this.entries.containsEntry(name);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public ZipEntry getEntry(String name) {
<b class="nc">&nbsp;		ensureOpen();</b>
<b class="nc">&nbsp;		return this.entries.getEntry(name);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	InputStream getInputStream() throws IOException {
<b class="nc">&nbsp;		return this.data.getInputStream();</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public synchronized InputStream getInputStream(ZipEntry entry) throws IOException {
<b class="nc">&nbsp;		ensureOpen();</b>
<b class="nc">&nbsp;		if (entry instanceof JarEntry jarEntry) {</b>
<b class="nc">&nbsp;			return this.entries.getInputStream(jarEntry);</b>
&nbsp;		}
<b class="nc">&nbsp;		return getInputStream((entry != null) ? entry.getName() : null);</b>
&nbsp;	}
&nbsp;
&nbsp;	InputStream getInputStream(String name) throws IOException {
<b class="nc">&nbsp;		return this.entries.getInputStream(name);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Return a nested {@link JarFile} loaded from the specified entry.
&nbsp;	 * @param entry the zip entry
&nbsp;	 * @return a {@link JarFile} for the entry
&nbsp;	 * @throws IOException if the nested jar file cannot be read
&nbsp;	 */
&nbsp;	public synchronized JarFile getNestedJarFile(ZipEntry entry) throws IOException {
<b class="nc">&nbsp;		return getNestedJarFile((JarEntry) entry);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Return a nested {@link JarFile} loaded from the specified entry.
&nbsp;	 * @param entry the zip entry
&nbsp;	 * @return a {@link JarFile} for the entry
&nbsp;	 * @throws IOException if the nested jar file cannot be read
&nbsp;	 */
&nbsp;	public synchronized JarFile getNestedJarFile(JarEntry entry) throws IOException {
&nbsp;		try {
<b class="nc">&nbsp;			return createJarFileFromEntry(entry);</b>
&nbsp;		}
<b class="nc">&nbsp;		catch (Exception ex) {</b>
<b class="nc">&nbsp;			throw new IOException(&quot;Unable to open nested jar file &#39;&quot; + entry.getName() + &quot;&#39;&quot;, ex);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private JarFile createJarFileFromEntry(JarEntry entry) throws IOException {
<b class="nc">&nbsp;		if (entry.isDirectory()) {</b>
<b class="nc">&nbsp;			return createJarFileFromDirectoryEntry(entry);</b>
&nbsp;		}
<b class="nc">&nbsp;		return createJarFileFromFileEntry(entry);</b>
&nbsp;	}
&nbsp;
&nbsp;	private JarFile createJarFileFromDirectoryEntry(JarEntry entry) throws IOException {
<b class="nc">&nbsp;		AsciiBytes name = entry.getAsciiBytesName();</b>
<b class="nc">&nbsp;		JarEntryFilter filter = (candidate) -&gt; {</b>
<b class="nc">&nbsp;			if (candidate.startsWith(name) &amp;&amp; !candidate.equals(name)) {</b>
<b class="nc">&nbsp;				return candidate.substring(name.length());</b>
&nbsp;			}
<b class="nc">&nbsp;			return null;</b>
&nbsp;		};
<b class="nc">&nbsp;		return new JarFile(this.rootFile, this.pathFromRoot + &quot;!/&quot; + entry.getName().substring(0, name.length() - 1),</b>
&nbsp;				this.data, filter, JarFileType.NESTED_DIRECTORY, this.manifestSupplier);
&nbsp;	}
&nbsp;
&nbsp;	private JarFile createJarFileFromFileEntry(JarEntry entry) throws IOException {
<b class="nc">&nbsp;		if (entry.getMethod() != ZipEntry.STORED) {</b>
<b class="nc">&nbsp;			throw new IllegalStateException(</b>
<b class="nc">&nbsp;					&quot;Unable to open nested entry &#39;&quot; + entry.getName() + &quot;&#39;. It has been compressed and nested &quot;</b>
&nbsp;							+ &quot;jar files must be stored without compression. Please check the &quot;
&nbsp;							+ &quot;mechanism used to create your executable jar file&quot;);
&nbsp;		}
<b class="nc">&nbsp;		RandomAccessData entryData = this.entries.getEntryData(entry.getName());</b>
<b class="nc">&nbsp;		return new JarFile(this.rootFile, this.pathFromRoot + &quot;!/&quot; + entry.getName(), entryData,</b>
&nbsp;				JarFileType.NESTED_JAR);
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public String getComment() {
<b class="nc">&nbsp;		ensureOpen();</b>
<b class="nc">&nbsp;		return this.comment;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public int size() {
<b class="nc">&nbsp;		ensureOpen();</b>
<b class="nc">&nbsp;		return this.entries.getSize();</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void close() throws IOException {
<b class="nc">&nbsp;		if (this.closed) {</b>
&nbsp;			return;
&nbsp;		}
<b class="nc">&nbsp;		super.close();</b>
<b class="nc">&nbsp;		if (this.type == JarFileType.DIRECT) {</b>
<b class="nc">&nbsp;			this.rootFile.close();</b>
&nbsp;		}
<b class="nc">&nbsp;		this.closed = true;</b>
&nbsp;	}
&nbsp;
&nbsp;	private void ensureOpen() {
<b class="nc">&nbsp;		if (this.closed) {</b>
<b class="nc">&nbsp;			throw new IllegalStateException(&quot;zip file closed&quot;);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	boolean isClosed() {
<b class="nc">&nbsp;		return this.closed;</b>
&nbsp;	}
&nbsp;
&nbsp;	String getUrlString() throws MalformedURLException {
<b class="nc">&nbsp;		if (this.urlString == null) {</b>
<b class="nc">&nbsp;			this.urlString = getUrl().toString();</b>
&nbsp;		}
<b class="nc">&nbsp;		return this.urlString;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public URL getUrl() throws MalformedURLException {
<b class="nc">&nbsp;		if (this.url == null) {</b>
<b class="nc">&nbsp;			String file = this.rootFile.getFile().toURI() + this.pathFromRoot + &quot;!/&quot;;</b>
<b class="nc">&nbsp;			file = file.replace(&quot;file:////&quot;, &quot;file://&quot;); // Fix UNC paths</b>
<b class="nc">&nbsp;			this.url = new URL(&quot;jar&quot;, &quot;&quot;, -1, file, new Handler(this));</b>
&nbsp;		}
<b class="nc">&nbsp;		return this.url;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public String toString() {
<b class="nc">&nbsp;		return getName();</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public String getName() {
<b class="nc">&nbsp;		return this.rootFile.getFile() + this.pathFromRoot;</b>
&nbsp;	}
&nbsp;
&nbsp;	boolean isSigned() {
<b class="nc">&nbsp;		return this.signed;</b>
&nbsp;	}
&nbsp;
&nbsp;	JarEntryCertification getCertification(JarEntry entry) {
&nbsp;		try {
<b class="nc">&nbsp;			return this.entries.getCertification(entry);</b>
&nbsp;		}
<b class="nc">&nbsp;		catch (IOException ex) {</b>
<b class="nc">&nbsp;			throw new IllegalStateException(ex);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	public void clearCache() {
<b class="nc">&nbsp;		this.entries.clearCache();</b>
&nbsp;	}
&nbsp;
&nbsp;	protected String getPathFromRoot() {
<b class="nc">&nbsp;		return this.pathFromRoot;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	JarFileType getType() {
<b class="nc">&nbsp;		return this.type;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Register a {@literal &#39;java.protocol.handler.pkgs&#39;} property so that a
&nbsp;	 * {@link URLStreamHandler} will be located to deal with jar URLs.
&nbsp;	 */
&nbsp;	public static void registerUrlProtocolHandler() {
<b class="nc">&nbsp;		Handler.captureJarContextUrl();</b>
<b class="nc">&nbsp;		String handlers = System.getProperty(PROTOCOL_HANDLER, &quot;&quot;);</b>
<b class="nc">&nbsp;		System.setProperty(PROTOCOL_HANDLER,</b>
<b class="nc">&nbsp;				((handlers == null || handlers.isEmpty()) ? HANDLERS_PACKAGE : handlers + &quot;|&quot; + HANDLERS_PACKAGE));</b>
<b class="nc">&nbsp;		resetCachedUrlHandlers();</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Reset any cached handlers just in case a jar protocol has already been used. We
&nbsp;	 * reset the handler by trying to set a null {@link URLStreamHandlerFactory} which
&nbsp;	 * should have no effect other than clearing the handlers cache.
&nbsp;	 */
&nbsp;	private static void resetCachedUrlHandlers() {
&nbsp;		try {
<b class="nc">&nbsp;			URL.setURLStreamHandlerFactory(null);</b>
&nbsp;		}
<b class="nc">&nbsp;		catch (Error ex) {</b>
&nbsp;			// Ignore
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * An {@link Enumeration} on {@linkplain java.util.jar.JarEntry jar entries}.
&nbsp;	 */
&nbsp;	private static class JarEntryEnumeration implements Enumeration&lt;java.util.jar.JarEntry&gt; {
&nbsp;
&nbsp;		private final Iterator&lt;JarEntry&gt; iterator;
&nbsp;
<b class="nc">&nbsp;		JarEntryEnumeration(Iterator&lt;JarEntry&gt; iterator) {</b>
<b class="nc">&nbsp;			this.iterator = iterator;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public boolean hasMoreElements() {
<b class="nc">&nbsp;			return this.iterator.hasNext();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public java.util.jar.JarEntry nextElement() {
<b class="nc">&nbsp;			return this.iterator.next();</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-04-01 11:12</div>
</div>
</body>
</html>
