


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > NestedJarFile</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.springframework.boot.loader.jar</a>
</div>

<h1>Coverage Summary for Class: NestedJarFile (org.springframework.boot.loader.jar)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">NestedJarFile</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/29)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/164)
  </span>
</td>
</tr>
  <tr>
    <td class="name">NestedJarFile$JarEntriesEnumeration</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">NestedJarFile$JarEntryInflaterInputStream</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">NestedJarFile$JarEntryInputStream</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/36)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">NestedJarFile$NestedJarEntry</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/34)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/58)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">NestedJarFile$RawZipDataInputStream</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">NestedJarFile$ZipContentEntriesSpliterator</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/83)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/292)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2012-2024 the original author or authors.
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *      https://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;
&nbsp;package org.springframework.boot.loader.jar;
&nbsp;
&nbsp;import java.io.File;
&nbsp;import java.io.FilterInputStream;
&nbsp;import java.io.IOException;
&nbsp;import java.io.InputStream;
&nbsp;import java.io.UncheckedIOException;
&nbsp;import java.lang.ref.Cleaner.Cleanable;
&nbsp;import java.nio.ByteBuffer;
&nbsp;import java.nio.file.attribute.FileTime;
&nbsp;import java.security.CodeSigner;
&nbsp;import java.security.cert.Certificate;
&nbsp;import java.time.LocalDateTime;
&nbsp;import java.util.Enumeration;
&nbsp;import java.util.NoSuchElementException;
&nbsp;import java.util.Objects;
&nbsp;import java.util.Spliterator;
&nbsp;import java.util.Spliterators.AbstractSpliterator;
&nbsp;import java.util.function.Consumer;
&nbsp;import java.util.jar.Attributes;
&nbsp;import java.util.jar.JarEntry;
&nbsp;import java.util.jar.JarFile;
&nbsp;import java.util.jar.Manifest;
&nbsp;import java.util.stream.Stream;
&nbsp;import java.util.stream.StreamSupport;
&nbsp;import java.util.zip.Inflater;
&nbsp;import java.util.zip.ZipEntry;
&nbsp;import java.util.zip.ZipException;
&nbsp;
&nbsp;import org.springframework.boot.loader.log.DebugLogger;
&nbsp;import org.springframework.boot.loader.ref.Cleaner;
&nbsp;import org.springframework.boot.loader.zip.CloseableDataBlock;
&nbsp;import org.springframework.boot.loader.zip.ZipContent;
&nbsp;import org.springframework.boot.loader.zip.ZipContent.Entry;
&nbsp;
&nbsp;/**
&nbsp; * Extended variant of {@link JarFile} that behaves in the same way but can open nested
&nbsp; * jars.
&nbsp; *
&nbsp; * @author Phillip Webb
&nbsp; * @author Andy Wilkinson
&nbsp; * @since 3.2.0
&nbsp; */
&nbsp;public class NestedJarFile extends JarFile {
&nbsp;
&nbsp;	private static final int DECIMAL = 10;
&nbsp;
&nbsp;	private static final String META_INF = &quot;META-INF/&quot;;
&nbsp;
&nbsp;	static final String META_INF_VERSIONS = META_INF + &quot;versions/&quot;;
&nbsp;
<b class="nc">&nbsp;	static final int BASE_VERSION = baseVersion().feature();</b>
&nbsp;
<b class="nc">&nbsp;	private static final DebugLogger debug = DebugLogger.get(NestedJarFile.class);</b>
&nbsp;
&nbsp;	private final Cleaner cleaner;
&nbsp;
&nbsp;	private final NestedJarFileResources resources;
&nbsp;
&nbsp;	private final Cleanable cleanup;
&nbsp;
&nbsp;	private final String name;
&nbsp;
&nbsp;	private final int version;
&nbsp;
&nbsp;	private volatile NestedJarEntry lastEntry;
&nbsp;
&nbsp;	private volatile boolean closed;
&nbsp;
&nbsp;	private volatile ManifestInfo manifestInfo;
&nbsp;
&nbsp;	private volatile MetaInfVersionsInfo metaInfVersionsInfo;
&nbsp;
&nbsp;	/**
&nbsp;	 * Creates a new {@link NestedJarFile} instance to read from the specific
&nbsp;	 * {@code File}.
&nbsp;	 * @param file the jar file to be opened for reading
&nbsp;	 * @throws IOException on I/O error
&nbsp;	 */
&nbsp;	NestedJarFile(File file) throws IOException {
<b class="nc">&nbsp;		this(file, null, null, false, Cleaner.instance);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Creates a new {@link NestedJarFile} instance to read from the specific
&nbsp;	 * {@code File}.
&nbsp;	 * @param file the jar file to be opened for reading
&nbsp;	 * @param nestedEntryName the nested entry name to open
&nbsp;	 * @throws IOException on I/O error
&nbsp;	 * @throws IllegalArgumentException if {@code nestedEntryName} is {@code null} or
&nbsp;	 * empty
&nbsp;	 */
&nbsp;	public NestedJarFile(File file, String nestedEntryName) throws IOException {
<b class="nc">&nbsp;		this(file, nestedEntryName, null, true, Cleaner.instance);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Creates a new {@link NestedJarFile} instance to read from the specific
&nbsp;	 * {@code File}.
&nbsp;	 * @param file the jar file to be opened for reading
&nbsp;	 * @param nestedEntryName the nested entry name to open
&nbsp;	 * @param version the release version to use when opening a multi-release jar
&nbsp;	 * @throws IOException on I/O error
&nbsp;	 * @throws IllegalArgumentException if {@code nestedEntryName} is {@code null} or
&nbsp;	 * empty
&nbsp;	 */
&nbsp;	public NestedJarFile(File file, String nestedEntryName, Runtime.Version version) throws IOException {
<b class="nc">&nbsp;		this(file, nestedEntryName, version, true, Cleaner.instance);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Creates a new {@link NestedJarFile} instance to read from the specific
&nbsp;	 * {@code File}.
&nbsp;	 * @param file the jar file to be opened for reading
&nbsp;	 * @param nestedEntryName the nested entry name to open
&nbsp;	 * @param version the release version to use when opening a multi-release jar
&nbsp;	 * @param onlyNestedJars if &lt;em&gt;only&lt;/em&gt; nested jars should be opened
&nbsp;	 * @param cleaner the cleaner used to release resources
&nbsp;	 * @throws IOException on I/O error
&nbsp;	 * @throws IllegalArgumentException if {@code nestedEntryName} is {@code null} or
&nbsp;	 * empty
&nbsp;	 */
&nbsp;	NestedJarFile(File file, String nestedEntryName, Runtime.Version version, boolean onlyNestedJars, Cleaner cleaner)
&nbsp;			throws IOException {
<b class="nc">&nbsp;		super(file);</b>
<b class="nc">&nbsp;		if (onlyNestedJars &amp;&amp; (nestedEntryName == null || nestedEntryName.isEmpty())) {</b>
<b class="nc">&nbsp;			throw new IllegalArgumentException(&quot;nestedEntryName must not be empty&quot;);</b>
&nbsp;		}
<b class="nc">&nbsp;		debug.log(&quot;Created nested jar file (%s, %s, %s)&quot;, file, nestedEntryName, version);</b>
<b class="nc">&nbsp;		this.cleaner = cleaner;</b>
<b class="nc">&nbsp;		this.resources = new NestedJarFileResources(file, nestedEntryName);</b>
<b class="nc">&nbsp;		this.cleanup = cleaner.register(this, this.resources);</b>
<b class="nc">&nbsp;		this.name = file.getPath() + ((nestedEntryName != null) ? &quot;!/&quot; + nestedEntryName : &quot;&quot;);</b>
<b class="nc">&nbsp;		this.version = (version != null) ? version.feature() : baseVersion().feature();</b>
&nbsp;	}
&nbsp;
&nbsp;	public InputStream getRawZipDataInputStream() throws IOException {
<b class="nc">&nbsp;		RawZipDataInputStream inputStream = new RawZipDataInputStream(</b>
<b class="nc">&nbsp;				this.resources.zipContent().openRawZipData().asInputStream());</b>
<b class="nc">&nbsp;		this.resources.addInputStream(inputStream);</b>
<b class="nc">&nbsp;		return inputStream;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public Manifest getManifest() throws IOException {
&nbsp;		try {
<b class="nc">&nbsp;			return this.resources.zipContentForManifest()</b>
<b class="nc">&nbsp;				.getInfo(ManifestInfo.class, this::getManifestInfo)</b>
<b class="nc">&nbsp;				.getManifest();</b>
&nbsp;		}
<b class="nc">&nbsp;		catch (UncheckedIOException ex) {</b>
<b class="nc">&nbsp;			throw ex.getCause();</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public Enumeration&lt;JarEntry&gt; entries() {
<b class="nc">&nbsp;		synchronized (this) {</b>
<b class="nc">&nbsp;			ensureOpen();</b>
<b class="nc">&nbsp;			return new JarEntriesEnumeration(this.resources.zipContent());</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public Stream&lt;JarEntry&gt; stream() {
<b class="nc">&nbsp;		synchronized (this) {</b>
<b class="nc">&nbsp;			ensureOpen();</b>
<b class="nc">&nbsp;			return streamContentEntries().map(NestedJarEntry::new);</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public Stream&lt;JarEntry&gt; versionedStream() {
<b class="nc">&nbsp;		synchronized (this) {</b>
<b class="nc">&nbsp;			ensureOpen();</b>
<b class="nc">&nbsp;			return streamContentEntries().map(this::getBaseName)</b>
<b class="nc">&nbsp;				.filter(Objects::nonNull)</b>
<b class="nc">&nbsp;				.distinct()</b>
<b class="nc">&nbsp;				.map(this::getJarEntry)</b>
<b class="nc">&nbsp;				.filter(Objects::nonNull);</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	private Stream&lt;ZipContent.Entry&gt; streamContentEntries() {
<b class="nc">&nbsp;		ZipContentEntriesSpliterator spliterator = new ZipContentEntriesSpliterator(this.resources.zipContent());</b>
<b class="nc">&nbsp;		return StreamSupport.stream(spliterator, false);</b>
&nbsp;	}
&nbsp;
&nbsp;	private String getBaseName(ZipContent.Entry contentEntry) {
<b class="nc">&nbsp;		String name = contentEntry.getName();</b>
<b class="nc">&nbsp;		if (!name.startsWith(META_INF_VERSIONS)) {</b>
<b class="nc">&nbsp;			return name;</b>
&nbsp;		}
<b class="nc">&nbsp;		int versionNumberStartIndex = META_INF_VERSIONS.length();</b>
<b class="nc">&nbsp;		int versionNumberEndIndex = (versionNumberStartIndex != -1) ? name.indexOf(&#39;/&#39;, versionNumberStartIndex) : -1;</b>
<b class="nc">&nbsp;		if (versionNumberEndIndex == -1 || versionNumberEndIndex == (name.length() - 1)) {</b>
<b class="nc">&nbsp;			return null;</b>
&nbsp;		}
&nbsp;		try {
<b class="nc">&nbsp;			int versionNumber = Integer.parseInt(name, versionNumberStartIndex, versionNumberEndIndex, DECIMAL);</b>
<b class="nc">&nbsp;			if (versionNumber &gt; this.version) {</b>
<b class="nc">&nbsp;				return null;</b>
&nbsp;			}
&nbsp;		}
<b class="nc">&nbsp;		catch (NumberFormatException ex) {</b>
<b class="nc">&nbsp;			return null;</b>
<b class="nc">&nbsp;		}</b>
<b class="nc">&nbsp;		return name.substring(versionNumberEndIndex + 1);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public JarEntry getJarEntry(String name) {
<b class="nc">&nbsp;		return getNestedJarEntry(name);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public JarEntry getEntry(String name) {
<b class="nc">&nbsp;		return getNestedJarEntry(name);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Return if an entry with the given name exists.
&nbsp;	 * @param name the name to check
&nbsp;	 * @return if the entry exists
&nbsp;	 */
&nbsp;	public boolean hasEntry(String name) {
<b class="nc">&nbsp;		NestedJarEntry lastEntry = this.lastEntry;</b>
<b class="nc">&nbsp;		if (lastEntry != null &amp;&amp; name.equals(lastEntry.getName())) {</b>
<b class="nc">&nbsp;			return true;</b>
&nbsp;		}
<b class="nc">&nbsp;		ZipContent.Entry entry = getVersionedContentEntry(name);</b>
<b class="nc">&nbsp;		if (entry != null) {</b>
<b class="nc">&nbsp;			return true;</b>
&nbsp;		}
<b class="nc">&nbsp;		synchronized (this) {</b>
<b class="nc">&nbsp;			ensureOpen();</b>
<b class="nc">&nbsp;			return this.resources.zipContent().hasEntry(null, name);</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	private NestedJarEntry getNestedJarEntry(String name) {
<b class="nc">&nbsp;		Objects.requireNonNull(name, &quot;name&quot;);</b>
<b class="nc">&nbsp;		NestedJarEntry lastEntry = this.lastEntry;</b>
<b class="nc">&nbsp;		if (lastEntry != null &amp;&amp; name.equals(lastEntry.getName())) {</b>
<b class="nc">&nbsp;			return lastEntry;</b>
&nbsp;		}
<b class="nc">&nbsp;		ZipContent.Entry entry = getVersionedContentEntry(name);</b>
<b class="nc">&nbsp;		entry = (entry != null) ? entry : getContentEntry(null, name);</b>
<b class="nc">&nbsp;		if (entry == null) {</b>
<b class="nc">&nbsp;			return null;</b>
&nbsp;		}
<b class="nc">&nbsp;		NestedJarEntry nestedJarEntry = new NestedJarEntry(entry, name);</b>
<b class="nc">&nbsp;		this.lastEntry = nestedJarEntry;</b>
<b class="nc">&nbsp;		return nestedJarEntry;</b>
&nbsp;	}
&nbsp;
&nbsp;	private ZipContent.Entry getVersionedContentEntry(String name) {
&nbsp;		// NOTE: we can&#39;t call isMultiRelease() directly because it&#39;s a final method and
&nbsp;		// it inspects the container jar. We use ManifestInfo instead.
<b class="nc">&nbsp;		if (BASE_VERSION &gt;= this.version || name.startsWith(META_INF) || !getManifestInfo().isMultiRelease()) {</b>
<b class="nc">&nbsp;			return null;</b>
&nbsp;		}
<b class="nc">&nbsp;		MetaInfVersionsInfo metaInfVersionsInfo = getMetaInfVersionsInfo();</b>
<b class="nc">&nbsp;		int[] versions = metaInfVersionsInfo.versions();</b>
<b class="nc">&nbsp;		String[] directories = metaInfVersionsInfo.directories();</b>
<b class="nc">&nbsp;		for (int i = versions.length - 1; i &gt;= 0; i--) {</b>
<b class="nc">&nbsp;			if (versions[i] &lt;= this.version) {</b>
<b class="nc">&nbsp;				ZipContent.Entry entry = getContentEntry(directories[i], name);</b>
<b class="nc">&nbsp;				if (entry != null) {</b>
<b class="nc">&nbsp;					return entry;</b>
&nbsp;				}
&nbsp;			}
&nbsp;		}
<b class="nc">&nbsp;		return null;</b>
&nbsp;	}
&nbsp;
&nbsp;	private ZipContent.Entry getContentEntry(String namePrefix, String name) {
<b class="nc">&nbsp;		synchronized (this) {</b>
<b class="nc">&nbsp;			ensureOpen();</b>
<b class="nc">&nbsp;			return this.resources.zipContent().getEntry(namePrefix, name);</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	private ManifestInfo getManifestInfo() {
<b class="nc">&nbsp;		ManifestInfo manifestInfo = this.manifestInfo;</b>
<b class="nc">&nbsp;		if (manifestInfo != null) {</b>
<b class="nc">&nbsp;			return manifestInfo;</b>
&nbsp;		}
<b class="nc">&nbsp;		synchronized (this) {</b>
<b class="nc">&nbsp;			ensureOpen();</b>
<b class="nc">&nbsp;			manifestInfo = this.resources.zipContent().getInfo(ManifestInfo.class, this::getManifestInfo);</b>
<b class="nc">&nbsp;		}</b>
<b class="nc">&nbsp;		this.manifestInfo = manifestInfo;</b>
<b class="nc">&nbsp;		return manifestInfo;</b>
&nbsp;	}
&nbsp;
&nbsp;	private ManifestInfo getManifestInfo(ZipContent zipContent) {
<b class="nc">&nbsp;		ZipContent.Entry contentEntry = zipContent.getEntry(MANIFEST_NAME);</b>
<b class="nc">&nbsp;		if (contentEntry == null) {</b>
<b class="nc">&nbsp;			return ManifestInfo.NONE;</b>
&nbsp;		}
&nbsp;		try {
<b class="nc">&nbsp;			try (InputStream inputStream = getInputStream(contentEntry)) {</b>
<b class="nc">&nbsp;				Manifest manifest = new Manifest(inputStream);</b>
<b class="nc">&nbsp;				return new ManifestInfo(manifest);</b>
<b class="nc">&nbsp;			}</b>
&nbsp;		}
<b class="nc">&nbsp;		catch (IOException ex) {</b>
<b class="nc">&nbsp;			throw new UncheckedIOException(ex);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private MetaInfVersionsInfo getMetaInfVersionsInfo() {
<b class="nc">&nbsp;		MetaInfVersionsInfo metaInfVersionsInfo = this.metaInfVersionsInfo;</b>
<b class="nc">&nbsp;		if (metaInfVersionsInfo != null) {</b>
<b class="nc">&nbsp;			return metaInfVersionsInfo;</b>
&nbsp;		}
<b class="nc">&nbsp;		synchronized (this) {</b>
<b class="nc">&nbsp;			ensureOpen();</b>
<b class="nc">&nbsp;			metaInfVersionsInfo = this.resources.zipContent()</b>
<b class="nc">&nbsp;				.getInfo(MetaInfVersionsInfo.class, MetaInfVersionsInfo::get);</b>
<b class="nc">&nbsp;		}</b>
<b class="nc">&nbsp;		this.metaInfVersionsInfo = metaInfVersionsInfo;</b>
<b class="nc">&nbsp;		return metaInfVersionsInfo;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public InputStream getInputStream(ZipEntry entry) throws IOException {
<b class="nc">&nbsp;		Objects.requireNonNull(entry, &quot;entry&quot;);</b>
<b class="nc">&nbsp;		if (entry instanceof NestedJarEntry nestedJarEntry &amp;&amp; nestedJarEntry.isOwnedBy(this)) {</b>
<b class="nc">&nbsp;			return getInputStream(nestedJarEntry.contentEntry());</b>
&nbsp;		}
<b class="nc">&nbsp;		return getInputStream(getNestedJarEntry(entry.getName()).contentEntry());</b>
&nbsp;	}
&nbsp;
&nbsp;	private InputStream getInputStream(ZipContent.Entry contentEntry) throws IOException {
<b class="nc">&nbsp;		int compression = contentEntry.getCompressionMethod();</b>
<b class="nc">&nbsp;		if (compression != ZipEntry.STORED &amp;&amp; compression != ZipEntry.DEFLATED) {</b>
<b class="nc">&nbsp;			throw new ZipException(&quot;invalid compression method&quot;);</b>
&nbsp;		}
<b class="nc">&nbsp;		synchronized (this) {</b>
<b class="nc">&nbsp;			ensureOpen();</b>
<b class="nc">&nbsp;			InputStream inputStream = new JarEntryInputStream(contentEntry);</b>
&nbsp;			try {
<b class="nc">&nbsp;				if (compression == ZipEntry.DEFLATED) {</b>
<b class="nc">&nbsp;					inputStream = new JarEntryInflaterInputStream((JarEntryInputStream) inputStream, this.resources);</b>
&nbsp;				}
<b class="nc">&nbsp;				this.resources.addInputStream(inputStream);</b>
<b class="nc">&nbsp;				return inputStream;</b>
&nbsp;			}
<b class="nc">&nbsp;			catch (RuntimeException ex) {</b>
<b class="nc">&nbsp;				inputStream.close();</b>
<b class="nc">&nbsp;				throw ex;</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public String getComment() {
<b class="nc">&nbsp;		synchronized (this) {</b>
<b class="nc">&nbsp;			ensureOpen();</b>
<b class="nc">&nbsp;			return this.resources.zipContent().getComment();</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public int size() {
<b class="nc">&nbsp;		synchronized (this) {</b>
<b class="nc">&nbsp;			ensureOpen();</b>
<b class="nc">&nbsp;			return this.resources.zipContent().size();</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void close() throws IOException {
<b class="nc">&nbsp;		super.close();</b>
<b class="nc">&nbsp;		if (this.closed) {</b>
&nbsp;			return;
&nbsp;		}
<b class="nc">&nbsp;		this.closed = true;</b>
<b class="nc">&nbsp;		synchronized (this) {</b>
&nbsp;			try {
<b class="nc">&nbsp;				this.cleanup.clean();</b>
&nbsp;			}
<b class="nc">&nbsp;			catch (UncheckedIOException ex) {</b>
<b class="nc">&nbsp;				throw ex.getCause();</b>
<b class="nc">&nbsp;			}</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public String getName() {
<b class="nc">&nbsp;		return this.name;</b>
&nbsp;	}
&nbsp;
&nbsp;	private void ensureOpen() {
<b class="nc">&nbsp;		if (this.closed) {</b>
<b class="nc">&nbsp;			throw new IllegalStateException(&quot;Zip file closed&quot;);</b>
&nbsp;		}
<b class="nc">&nbsp;		if (this.resources.zipContent() == null) {</b>
<b class="nc">&nbsp;			throw new IllegalStateException(&quot;The object is not initialized.&quot;);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Clear any internal caches.
&nbsp;	 */
&nbsp;	public void clearCache() {
<b class="nc">&nbsp;		synchronized (this) {</b>
<b class="nc">&nbsp;			this.lastEntry = null;</b>
<b class="nc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * An individual entry from a {@link NestedJarFile}.
&nbsp;	 */
&nbsp;	private class NestedJarEntry extends java.util.jar.JarEntry {
&nbsp;
<b class="nc">&nbsp;		private static final IllegalStateException CANNOT_BE_MODIFIED_EXCEPTION = new IllegalStateException(</b>
&nbsp;				&quot;Neste jar entries cannot be modified&quot;);
&nbsp;
&nbsp;		private final ZipContent.Entry contentEntry;
&nbsp;
&nbsp;		private final String name;
&nbsp;
&nbsp;		private volatile boolean populated;
&nbsp;
&nbsp;		NestedJarEntry(Entry contentEntry) {
<b class="nc">&nbsp;			this(contentEntry, contentEntry.getName());</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		NestedJarEntry(ZipContent.Entry contentEntry, String name) {</b>
<b class="nc">&nbsp;			super(contentEntry.getName());</b>
<b class="nc">&nbsp;			this.contentEntry = contentEntry;</b>
<b class="nc">&nbsp;			this.name = name;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public long getTime() {
<b class="nc">&nbsp;			populate();</b>
<b class="nc">&nbsp;			return super.getTime();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public LocalDateTime getTimeLocal() {
<b class="nc">&nbsp;			populate();</b>
<b class="nc">&nbsp;			return super.getTimeLocal();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public void setTime(long time) {
<b class="nc">&nbsp;			throw CANNOT_BE_MODIFIED_EXCEPTION;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public void setTimeLocal(LocalDateTime time) {
<b class="nc">&nbsp;			throw CANNOT_BE_MODIFIED_EXCEPTION;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public FileTime getLastModifiedTime() {
<b class="nc">&nbsp;			populate();</b>
<b class="nc">&nbsp;			return super.getLastModifiedTime();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public ZipEntry setLastModifiedTime(FileTime time) {
<b class="nc">&nbsp;			throw CANNOT_BE_MODIFIED_EXCEPTION;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public FileTime getLastAccessTime() {
<b class="nc">&nbsp;			populate();</b>
<b class="nc">&nbsp;			return super.getLastAccessTime();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public ZipEntry setLastAccessTime(FileTime time) {
<b class="nc">&nbsp;			throw CANNOT_BE_MODIFIED_EXCEPTION;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public FileTime getCreationTime() {
<b class="nc">&nbsp;			populate();</b>
<b class="nc">&nbsp;			return super.getCreationTime();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public ZipEntry setCreationTime(FileTime time) {
<b class="nc">&nbsp;			throw CANNOT_BE_MODIFIED_EXCEPTION;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public long getSize() {
<b class="nc">&nbsp;			return this.contentEntry.getUncompressedSize() &amp; 0xFFFFFFFFL;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public void setSize(long size) {
<b class="nc">&nbsp;			throw CANNOT_BE_MODIFIED_EXCEPTION;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public long getCompressedSize() {
<b class="nc">&nbsp;			populate();</b>
<b class="nc">&nbsp;			return super.getCompressedSize();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public void setCompressedSize(long csize) {
<b class="nc">&nbsp;			throw CANNOT_BE_MODIFIED_EXCEPTION;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public long getCrc() {
<b class="nc">&nbsp;			populate();</b>
<b class="nc">&nbsp;			return super.getCrc();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public void setCrc(long crc) {
<b class="nc">&nbsp;			throw CANNOT_BE_MODIFIED_EXCEPTION;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public int getMethod() {
<b class="nc">&nbsp;			populate();</b>
<b class="nc">&nbsp;			return super.getMethod();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public void setMethod(int method) {
<b class="nc">&nbsp;			throw CANNOT_BE_MODIFIED_EXCEPTION;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public byte[] getExtra() {
<b class="nc">&nbsp;			populate();</b>
<b class="nc">&nbsp;			return super.getExtra();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public void setExtra(byte[] extra) {
<b class="nc">&nbsp;			throw CANNOT_BE_MODIFIED_EXCEPTION;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public String getComment() {
<b class="nc">&nbsp;			populate();</b>
<b class="nc">&nbsp;			return super.getComment();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public void setComment(String comment) {
<b class="nc">&nbsp;			throw CANNOT_BE_MODIFIED_EXCEPTION;</b>
&nbsp;		}
&nbsp;
&nbsp;		boolean isOwnedBy(NestedJarFile nestedJarFile) {
<b class="nc">&nbsp;			return NestedJarFile.this == nestedJarFile;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public String getRealName() {
<b class="nc">&nbsp;			return super.getName();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public String getName() {
<b class="nc">&nbsp;			return this.name;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Attributes getAttributes() throws IOException {
<b class="nc">&nbsp;			Manifest manifest = getManifest();</b>
<b class="nc">&nbsp;			return (manifest != null) ? manifest.getAttributes(getName()) : null;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Certificate[] getCertificates() {
<b class="nc">&nbsp;			return getSecurityInfo().getCertificates(contentEntry());</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public CodeSigner[] getCodeSigners() {
<b class="nc">&nbsp;			return getSecurityInfo().getCodeSigners(contentEntry());</b>
&nbsp;		}
&nbsp;
&nbsp;		private SecurityInfo getSecurityInfo() {
<b class="nc">&nbsp;			return NestedJarFile.this.resources.zipContent().getInfo(SecurityInfo.class, SecurityInfo::get);</b>
&nbsp;		}
&nbsp;
&nbsp;		ZipContent.Entry contentEntry() {
<b class="nc">&nbsp;			return this.contentEntry;</b>
&nbsp;		}
&nbsp;
&nbsp;		private void populate() {
<b class="nc">&nbsp;			boolean populated = this.populated;</b>
<b class="nc">&nbsp;			if (!populated) {</b>
<b class="nc">&nbsp;				ZipEntry entry = this.contentEntry.as(ZipEntry::new);</b>
<b class="nc">&nbsp;				super.setMethod(entry.getMethod());</b>
<b class="nc">&nbsp;				super.setTime(entry.getTime());</b>
<b class="nc">&nbsp;				super.setCrc(entry.getCrc());</b>
<b class="nc">&nbsp;				super.setCompressedSize(entry.getCompressedSize());</b>
<b class="nc">&nbsp;				super.setSize(entry.getSize());</b>
<b class="nc">&nbsp;				super.setExtra(entry.getExtra());</b>
<b class="nc">&nbsp;				super.setComment(entry.getComment());</b>
<b class="nc">&nbsp;				this.populated = true;</b>
&nbsp;			}
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * {@link Enumeration} of {@link NestedJarEntry} instances.
&nbsp;	 */
&nbsp;	private class JarEntriesEnumeration implements Enumeration&lt;JarEntry&gt; {
&nbsp;
&nbsp;		private final ZipContent zipContent;
&nbsp;
&nbsp;		private int cursor;
&nbsp;
<b class="nc">&nbsp;		JarEntriesEnumeration(ZipContent zipContent) {</b>
<b class="nc">&nbsp;			this.zipContent = zipContent;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public boolean hasMoreElements() {
<b class="nc">&nbsp;			return this.cursor &lt; this.zipContent.size();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public NestedJarEntry nextElement() {
<b class="nc">&nbsp;			if (!hasMoreElements()) {</b>
<b class="nc">&nbsp;				throw new NoSuchElementException();</b>
&nbsp;			}
<b class="nc">&nbsp;			synchronized (NestedJarFile.this) {</b>
<b class="nc">&nbsp;				ensureOpen();</b>
<b class="nc">&nbsp;				return new NestedJarEntry(this.zipContent.getEntry(this.cursor++));</b>
<b class="nc">&nbsp;			}</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * {@link Spliterator} for {@link ZipContent.Entry} instances.
&nbsp;	 */
&nbsp;	private class ZipContentEntriesSpliterator extends AbstractSpliterator&lt;ZipContent.Entry&gt; {
&nbsp;
&nbsp;		private static final int ADDITIONAL_CHARACTERISTICS = Spliterator.ORDERED | Spliterator.DISTINCT
&nbsp;				| Spliterator.IMMUTABLE | Spliterator.NONNULL;
&nbsp;
&nbsp;		private final ZipContent zipContent;
&nbsp;
&nbsp;		private int cursor;
&nbsp;
<b class="nc">&nbsp;		ZipContentEntriesSpliterator(ZipContent zipContent) {</b>
<b class="nc">&nbsp;			super(zipContent.size(), ADDITIONAL_CHARACTERISTICS);</b>
<b class="nc">&nbsp;			this.zipContent = zipContent;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public boolean tryAdvance(Consumer&lt;? super ZipContent.Entry&gt; action) {
<b class="nc">&nbsp;			if (this.cursor &lt; this.zipContent.size()) {</b>
<b class="nc">&nbsp;				synchronized (NestedJarFile.this) {</b>
<b class="nc">&nbsp;					ensureOpen();</b>
<b class="nc">&nbsp;					action.accept(this.zipContent.getEntry(this.cursor++));</b>
<b class="nc">&nbsp;				}</b>
<b class="nc">&nbsp;				return true;</b>
&nbsp;			}
<b class="nc">&nbsp;			return false;</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * {@link InputStream} to read jar entry content.
&nbsp;	 */
&nbsp;	private class JarEntryInputStream extends InputStream {
&nbsp;
&nbsp;		private final int uncompressedSize;
&nbsp;
&nbsp;		private final CloseableDataBlock content;
&nbsp;
&nbsp;		private long pos;
&nbsp;
&nbsp;		private long remaining;
&nbsp;
&nbsp;		private volatile boolean closed;
&nbsp;
<b class="nc">&nbsp;		JarEntryInputStream(ZipContent.Entry entry) throws IOException {</b>
<b class="nc">&nbsp;			this.uncompressedSize = entry.getUncompressedSize();</b>
<b class="nc">&nbsp;			this.content = entry.openContent();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public int read() throws IOException {
<b class="nc">&nbsp;			byte[] b = new byte[1];</b>
<b class="nc">&nbsp;			return (read(b, 0, 1) == 1) ? b[0] &amp; 0xFF : -1;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public int read(byte[] b, int off, int len) throws IOException {
&nbsp;			int result;
<b class="nc">&nbsp;			synchronized (NestedJarFile.this) {</b>
<b class="nc">&nbsp;				ensureOpen();</b>
<b class="nc">&nbsp;				ByteBuffer dst = ByteBuffer.wrap(b, off, len);</b>
<b class="nc">&nbsp;				int count = this.content.read(dst, this.pos);</b>
<b class="nc">&nbsp;				if (count &gt; 0) {</b>
<b class="nc">&nbsp;					this.pos += count;</b>
<b class="nc">&nbsp;					this.remaining -= count;</b>
&nbsp;				}
<b class="nc">&nbsp;				result = count;</b>
<b class="nc">&nbsp;			}</b>
<b class="nc">&nbsp;			if (this.remaining == 0) {</b>
<b class="nc">&nbsp;				close();</b>
&nbsp;			}
<b class="nc">&nbsp;			return result;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public long skip(long n) throws IOException {
&nbsp;			long result;
<b class="nc">&nbsp;			synchronized (NestedJarFile.this) {</b>
<b class="nc">&nbsp;				result = (n &gt; 0) ? maxForwardSkip(n) : maxBackwardSkip(n);</b>
<b class="nc">&nbsp;				this.pos += result;</b>
<b class="nc">&nbsp;				this.remaining -= result;</b>
<b class="nc">&nbsp;			}</b>
<b class="nc">&nbsp;			if (this.remaining == 0) {</b>
<b class="nc">&nbsp;				close();</b>
&nbsp;			}
<b class="nc">&nbsp;			return result;</b>
&nbsp;		}
&nbsp;
&nbsp;		private long maxForwardSkip(long n) {
<b class="nc">&nbsp;			boolean willCauseOverflow = (this.pos + n) &lt; 0;</b>
<b class="nc">&nbsp;			return (willCauseOverflow || n &gt; this.remaining) ? this.remaining : n;</b>
&nbsp;		}
&nbsp;
&nbsp;		private long maxBackwardSkip(long n) {
<b class="nc">&nbsp;			return Math.max(-this.pos, n);</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public int available() {
<b class="nc">&nbsp;			return (this.remaining &lt; Integer.MAX_VALUE) ? (int) this.remaining : Integer.MAX_VALUE;</b>
&nbsp;		}
&nbsp;
&nbsp;		private void ensureOpen() throws ZipException {
<b class="nc">&nbsp;			if (NestedJarFile.this.closed || this.closed) {</b>
<b class="nc">&nbsp;				throw new ZipException(&quot;ZipFile closed&quot;);</b>
&nbsp;			}
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public void close() throws IOException {
<b class="nc">&nbsp;			if (this.closed) {</b>
&nbsp;				return;
&nbsp;			}
<b class="nc">&nbsp;			this.closed = true;</b>
<b class="nc">&nbsp;			this.content.close();</b>
<b class="nc">&nbsp;			NestedJarFile.this.resources.removeInputStream(this);</b>
&nbsp;		}
&nbsp;
&nbsp;		int getUncompressedSize() {
<b class="nc">&nbsp;			return this.uncompressedSize;</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * {@link ZipInflaterInputStream} to read and inflate jar entry content.
&nbsp;	 */
&nbsp;	private class JarEntryInflaterInputStream extends ZipInflaterInputStream {
&nbsp;
&nbsp;		private final Cleanable cleanup;
&nbsp;
&nbsp;		private volatile boolean closed;
&nbsp;
&nbsp;		JarEntryInflaterInputStream(JarEntryInputStream inputStream, NestedJarFileResources resources) {
<b class="nc">&nbsp;			this(inputStream, resources, resources.getOrCreateInflater());</b>
&nbsp;		}
&nbsp;
&nbsp;		private JarEntryInflaterInputStream(JarEntryInputStream inputStream, NestedJarFileResources resources,
<b class="nc">&nbsp;				Inflater inflater) {</b>
<b class="nc">&nbsp;			super(inputStream, inflater, inputStream.getUncompressedSize());</b>
<b class="nc">&nbsp;			this.cleanup = NestedJarFile.this.cleaner.register(this, resources.createInflatorCleanupAction(inflater));</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public void close() throws IOException {
<b class="nc">&nbsp;			if (this.closed) {</b>
&nbsp;				return;
&nbsp;			}
<b class="nc">&nbsp;			this.closed = true;</b>
<b class="nc">&nbsp;			super.close();</b>
<b class="nc">&nbsp;			NestedJarFile.this.resources.removeInputStream(this);</b>
<b class="nc">&nbsp;			this.cleanup.clean();</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * {@link InputStream} for raw zip data.
&nbsp;	 */
&nbsp;	private class RawZipDataInputStream extends FilterInputStream {
&nbsp;
&nbsp;		private volatile boolean closed;
&nbsp;
<b class="nc">&nbsp;		RawZipDataInputStream(InputStream in) {</b>
<b class="nc">&nbsp;			super(in);</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public void close() throws IOException {
<b class="nc">&nbsp;			if (this.closed) {</b>
&nbsp;				return;
&nbsp;			}
<b class="nc">&nbsp;			this.closed = true;</b>
<b class="nc">&nbsp;			super.close();</b>
<b class="nc">&nbsp;			NestedJarFile.this.resources.removeInputStream(this);</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-04-01 11:12</div>
</div>
</body>
</html>
