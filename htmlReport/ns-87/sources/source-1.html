


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > AbstractWebMvcEndpointHandlerMapping</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.springframework.boot.actuate.endpoint.web.servlet</a>
</div>

<h1>Coverage Summary for Class: AbstractWebMvcEndpointHandlerMapping (org.springframework.boot.actuate.endpoint.web.servlet)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">AbstractWebMvcEndpointHandlerMapping</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/16)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/57)
  </span>
</td>
</tr>
  <tr>
    <td class="name">AbstractWebMvcEndpointHandlerMapping$AbstractWebMvcEndpointHandlerMappingRuntimeHints</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractWebMvcEndpointHandlerMapping$InvalidEndpointBadRequestException</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractWebMvcEndpointHandlerMapping$LinksHandler</td>
  </tr>
  <tr>
    <td class="name">AbstractWebMvcEndpointHandlerMapping$OperationHandler</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractWebMvcEndpointHandlerMapping$ServletSecurityContext</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractWebMvcEndpointHandlerMapping$ServletWebOperation</td>
  </tr>
  <tr>
    <td class="name">AbstractWebMvcEndpointHandlerMapping$ServletWebOperationAdapter</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/13)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/63)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractWebMvcEndpointHandlerMapping$ServletWebOperationAdapter$FluxBodyConverter</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractWebMvcEndpointHandlerMapping$WebMvcEndpointHandlerMethod</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/43)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/139)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2012-2024 the original author or authors.
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *      https://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;
&nbsp;package org.springframework.boot.actuate.endpoint.web.servlet;
&nbsp;
&nbsp;import java.lang.reflect.Method;
&nbsp;import java.nio.charset.StandardCharsets;
&nbsp;import java.security.Principal;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collection;
&nbsp;import java.util.Collections;
&nbsp;import java.util.LinkedHashMap;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.function.Function;
&nbsp;
&nbsp;import jakarta.servlet.http.HttpServletRequest;
&nbsp;import jakarta.servlet.http.HttpServletResponse;
&nbsp;import reactor.core.publisher.Flux;
&nbsp;
&nbsp;import org.springframework.aot.hint.RuntimeHints;
&nbsp;import org.springframework.aot.hint.RuntimeHintsRegistrar;
&nbsp;import org.springframework.aot.hint.annotation.Reflective;
&nbsp;import org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrar;
&nbsp;import org.springframework.beans.factory.InitializingBean;
&nbsp;import org.springframework.boot.actuate.endpoint.InvalidEndpointRequestException;
&nbsp;import org.springframework.boot.actuate.endpoint.InvocationContext;
&nbsp;import org.springframework.boot.actuate.endpoint.OperationArgumentResolver;
&nbsp;import org.springframework.boot.actuate.endpoint.ProducibleOperationArgumentResolver;
&nbsp;import org.springframework.boot.actuate.endpoint.SecurityContext;
&nbsp;import org.springframework.boot.actuate.endpoint.invoke.OperationInvoker;
&nbsp;import org.springframework.boot.actuate.endpoint.web.EndpointMapping;
&nbsp;import org.springframework.boot.actuate.endpoint.web.EndpointMediaTypes;
&nbsp;import org.springframework.boot.actuate.endpoint.web.ExposableWebEndpoint;
&nbsp;import org.springframework.boot.actuate.endpoint.web.WebEndpointResponse;
&nbsp;import org.springframework.boot.actuate.endpoint.web.WebOperation;
&nbsp;import org.springframework.boot.actuate.endpoint.web.WebOperationRequestPredicate;
&nbsp;import org.springframework.boot.actuate.endpoint.web.WebServerNamespace;
&nbsp;import org.springframework.boot.actuate.endpoint.web.servlet.AbstractWebMvcEndpointHandlerMapping.AbstractWebMvcEndpointHandlerMappingRuntimeHints;
&nbsp;import org.springframework.boot.web.context.WebServerApplicationContext;
&nbsp;import org.springframework.context.annotation.ImportRuntimeHints;
&nbsp;import org.springframework.http.HttpHeaders;
&nbsp;import org.springframework.http.HttpMethod;
&nbsp;import org.springframework.http.HttpStatus;
&nbsp;import org.springframework.http.MediaType;
&nbsp;import org.springframework.http.ResponseEntity;
&nbsp;import org.springframework.http.server.ServletServerHttpRequest;
&nbsp;import org.springframework.util.AntPathMatcher;
&nbsp;import org.springframework.util.Assert;
&nbsp;import org.springframework.util.ClassUtils;
&nbsp;import org.springframework.util.ReflectionUtils;
&nbsp;import org.springframework.util.StringUtils;
&nbsp;import org.springframework.web.bind.annotation.RequestBody;
&nbsp;import org.springframework.web.bind.annotation.RequestMethod;
&nbsp;import org.springframework.web.bind.annotation.ResponseBody;
&nbsp;import org.springframework.web.context.WebApplicationContext;
&nbsp;import org.springframework.web.context.support.WebApplicationContextUtils;
&nbsp;import org.springframework.web.cors.CorsConfiguration;
&nbsp;import org.springframework.web.method.HandlerMethod;
&nbsp;import org.springframework.web.server.ResponseStatusException;
&nbsp;import org.springframework.web.servlet.HandlerMapping;
&nbsp;import org.springframework.web.servlet.mvc.method.RequestMappingInfo;
&nbsp;import org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping;
&nbsp;
&nbsp;/**
&nbsp; * A custom {@link HandlerMapping} that makes {@link ExposableWebEndpoint web endpoints}
&nbsp; * available over HTTP using Spring MVC.
&nbsp; *
&nbsp; * @author Andy Wilkinson
&nbsp; * @author Madhura Bhave
&nbsp; * @author Phillip Webb
&nbsp; * @author Brian Clozel
&nbsp; * @since 2.0.0
&nbsp; */
&nbsp;@ImportRuntimeHints(AbstractWebMvcEndpointHandlerMappingRuntimeHints.class)
&nbsp;public abstract class AbstractWebMvcEndpointHandlerMapping extends RequestMappingInfoHandlerMapping
&nbsp;		implements InitializingBean {
&nbsp;
&nbsp;	private final EndpointMapping endpointMapping;
&nbsp;
&nbsp;	private final Collection&lt;ExposableWebEndpoint&gt; endpoints;
&nbsp;
&nbsp;	private final EndpointMediaTypes endpointMediaTypes;
&nbsp;
&nbsp;	private final CorsConfiguration corsConfiguration;
&nbsp;
&nbsp;	private final boolean shouldRegisterLinksMapping;
&nbsp;
<b class="nc">&nbsp;	private final Method handleMethod = ReflectionUtils.findMethod(OperationHandler.class, &quot;handle&quot;,</b>
&nbsp;			HttpServletRequest.class, Map.class);
&nbsp;
<b class="nc">&nbsp;	private RequestMappingInfo.BuilderConfiguration builderConfig = new RequestMappingInfo.BuilderConfiguration();</b>
&nbsp;
&nbsp;	/**
&nbsp;	 * Creates a new {@code WebEndpointHandlerMapping} that provides mappings for the
&nbsp;	 * operations of the given {@code webEndpoints}.
&nbsp;	 * @param endpointMapping the base mapping for all endpoints
&nbsp;	 * @param endpoints the web endpoints
&nbsp;	 * @param endpointMediaTypes media types consumed and produced by the endpoints
&nbsp;	 * @param shouldRegisterLinksMapping whether the links endpoint should be registered
&nbsp;	 */
&nbsp;	public AbstractWebMvcEndpointHandlerMapping(EndpointMapping endpointMapping,
&nbsp;			Collection&lt;ExposableWebEndpoint&gt; endpoints, EndpointMediaTypes endpointMediaTypes,
&nbsp;			boolean shouldRegisterLinksMapping) {
<b class="nc">&nbsp;		this(endpointMapping, endpoints, endpointMediaTypes, null, shouldRegisterLinksMapping);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Creates a new {@code AbstractWebMvcEndpointHandlerMapping} that provides mappings
&nbsp;	 * for the operations of the given endpoints.
&nbsp;	 * @param endpointMapping the base mapping for all endpoints
&nbsp;	 * @param endpoints the web endpoints
&nbsp;	 * @param endpointMediaTypes media types consumed and produced by the endpoints
&nbsp;	 * @param corsConfiguration the CORS configuration for the endpoints or {@code null}
&nbsp;	 * @param shouldRegisterLinksMapping whether the links endpoint should be registered
&nbsp;	 */
&nbsp;	public AbstractWebMvcEndpointHandlerMapping(EndpointMapping endpointMapping,
&nbsp;			Collection&lt;ExposableWebEndpoint&gt; endpoints, EndpointMediaTypes endpointMediaTypes,
<b class="nc">&nbsp;			CorsConfiguration corsConfiguration, boolean shouldRegisterLinksMapping) {</b>
<b class="nc">&nbsp;		this.endpointMapping = endpointMapping;</b>
<b class="nc">&nbsp;		this.endpoints = endpoints;</b>
<b class="nc">&nbsp;		this.endpointMediaTypes = endpointMediaTypes;</b>
<b class="nc">&nbsp;		this.corsConfiguration = corsConfiguration;</b>
<b class="nc">&nbsp;		this.shouldRegisterLinksMapping = shouldRegisterLinksMapping;</b>
<b class="nc">&nbsp;		setOrder(-100);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void afterPropertiesSet() {
<b class="nc">&nbsp;		this.builderConfig = new RequestMappingInfo.BuilderConfiguration();</b>
<b class="nc">&nbsp;		this.builderConfig.setPatternParser(getPatternParser());</b>
<b class="nc">&nbsp;		super.afterPropertiesSet();</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	protected void initHandlerMethods() {
<b class="nc">&nbsp;		for (ExposableWebEndpoint endpoint : this.endpoints) {</b>
<b class="nc">&nbsp;			for (WebOperation operation : endpoint.getOperations()) {</b>
<b class="nc">&nbsp;				registerMappingForOperation(endpoint, operation);</b>
<b class="nc">&nbsp;			}</b>
<b class="nc">&nbsp;		}</b>
<b class="nc">&nbsp;		if (this.shouldRegisterLinksMapping) {</b>
<b class="nc">&nbsp;			registerLinksMapping();</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	protected HandlerMethod createHandlerMethod(Object handler, Method method) {
<b class="nc">&nbsp;		HandlerMethod handlerMethod = super.createHandlerMethod(handler, method);</b>
<b class="nc">&nbsp;		return new WebMvcEndpointHandlerMethod(handlerMethod.getBean(), handlerMethod.getMethod());</b>
&nbsp;	}
&nbsp;
&nbsp;	private void registerMappingForOperation(ExposableWebEndpoint endpoint, WebOperation operation) {
<b class="nc">&nbsp;		WebOperationRequestPredicate predicate = operation.getRequestPredicate();</b>
<b class="nc">&nbsp;		String path = predicate.getPath();</b>
<b class="nc">&nbsp;		String matchAllRemainingPathSegmentsVariable = predicate.getMatchAllRemainingPathSegmentsVariable();</b>
<b class="nc">&nbsp;		if (matchAllRemainingPathSegmentsVariable != null) {</b>
<b class="nc">&nbsp;			path = path.replace(&quot;{*&quot; + matchAllRemainingPathSegmentsVariable + &quot;}&quot;, &quot;**&quot;);</b>
&nbsp;		}
<b class="nc">&nbsp;		registerMapping(endpoint, predicate, operation, path);</b>
&nbsp;	}
&nbsp;
&nbsp;	protected void registerMapping(ExposableWebEndpoint endpoint, WebOperationRequestPredicate predicate,
&nbsp;			WebOperation operation, String path) {
<b class="nc">&nbsp;		ServletWebOperation servletWebOperation = wrapServletWebOperation(endpoint, operation,</b>
&nbsp;				new ServletWebOperationAdapter(operation));
<b class="nc">&nbsp;		registerMapping(createRequestMappingInfo(predicate, path), new OperationHandler(servletWebOperation),</b>
&nbsp;				this.handleMethod);
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Hook point that allows subclasses to wrap the {@link ServletWebOperation} before
&nbsp;	 * it&#39;s called. Allows additional features, such as security, to be added.
&nbsp;	 * @param endpoint the source endpoint
&nbsp;	 * @param operation the source operation
&nbsp;	 * @param servletWebOperation the servlet web operation to wrap
&nbsp;	 * @return a wrapped servlet web operation
&nbsp;	 */
&nbsp;	protected ServletWebOperation wrapServletWebOperation(ExposableWebEndpoint endpoint, WebOperation operation,
&nbsp;			ServletWebOperation servletWebOperation) {
<b class="nc">&nbsp;		return servletWebOperation;</b>
&nbsp;	}
&nbsp;
&nbsp;	private RequestMappingInfo createRequestMappingInfo(WebOperationRequestPredicate predicate, String path) {
<b class="nc">&nbsp;		String subPath = this.endpointMapping.createSubPath(path);</b>
<b class="nc">&nbsp;		List&lt;String&gt; paths = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;		paths.add(subPath);</b>
<b class="nc">&nbsp;		if (!StringUtils.hasLength(subPath)) {</b>
<b class="nc">&nbsp;			paths.add(&quot;/&quot;);</b>
&nbsp;		}
<b class="nc">&nbsp;		return RequestMappingInfo.paths(paths.toArray(new String[0]))</b>
<b class="nc">&nbsp;			.options(this.builderConfig)</b>
<b class="nc">&nbsp;			.methods(RequestMethod.valueOf(predicate.getHttpMethod().name()))</b>
<b class="nc">&nbsp;			.consumes(predicate.getConsumes().toArray(new String[0]))</b>
<b class="nc">&nbsp;			.produces(predicate.getProduces().toArray(new String[0]))</b>
<b class="nc">&nbsp;			.build();</b>
&nbsp;	}
&nbsp;
&nbsp;	private void registerLinksMapping() {
<b class="nc">&nbsp;		String path = this.endpointMapping.getPath();</b>
<b class="nc">&nbsp;		String linksPath = (StringUtils.hasLength(path)) ? this.endpointMapping.createSubPath(&quot;/&quot;) : &quot;/&quot;;</b>
<b class="nc">&nbsp;		RequestMappingInfo mapping = RequestMappingInfo.paths(linksPath)</b>
<b class="nc">&nbsp;			.methods(RequestMethod.GET)</b>
<b class="nc">&nbsp;			.produces(this.endpointMediaTypes.getProduced().toArray(new String[0]))</b>
<b class="nc">&nbsp;			.options(this.builderConfig)</b>
<b class="nc">&nbsp;			.build();</b>
<b class="nc">&nbsp;		LinksHandler linksHandler = getLinksHandler();</b>
<b class="nc">&nbsp;		registerMapping(mapping, linksHandler, ReflectionUtils.findMethod(linksHandler.getClass(), &quot;links&quot;,</b>
&nbsp;				HttpServletRequest.class, HttpServletResponse.class));
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	protected boolean hasCorsConfigurationSource(Object handler) {
<b class="nc">&nbsp;		return this.corsConfiguration != null;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	protected CorsConfiguration initCorsConfiguration(Object handler, Method method, RequestMappingInfo mapping) {
<b class="nc">&nbsp;		return this.corsConfiguration;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	protected boolean isHandler(Class&lt;?&gt; beanType) {
<b class="nc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	protected RequestMappingInfo getMappingForMethod(Method method, Class&lt;?&gt; handlerType) {
<b class="nc">&nbsp;		return null;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	protected void extendInterceptors(List&lt;Object&gt; interceptors) {
<b class="nc">&nbsp;		interceptors.add(new SkipPathExtensionContentNegotiation());</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Return the Handler providing actuator links at the root endpoint.
&nbsp;	 * @return the links handler
&nbsp;	 */
&nbsp;	protected abstract LinksHandler getLinksHandler();
&nbsp;
&nbsp;	/**
&nbsp;	 * Return the web endpoints being mapped.
&nbsp;	 * @return the endpoints
&nbsp;	 */
&nbsp;	public Collection&lt;ExposableWebEndpoint&gt; getEndpoints() {
<b class="nc">&nbsp;		return this.endpoints;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Handler providing actuator links at the root endpoint.
&nbsp;	 */
&nbsp;	@FunctionalInterface
&nbsp;	protected interface LinksHandler {
&nbsp;
&nbsp;		Object links(HttpServletRequest request, HttpServletResponse response);
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * A servlet web operation that can be handled by Spring MVC.
&nbsp;	 */
&nbsp;	@FunctionalInterface
&nbsp;	protected interface ServletWebOperation {
&nbsp;
&nbsp;		Object handle(HttpServletRequest request, Map&lt;String, String&gt; body);
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Adapter class to convert an {@link OperationInvoker} into a
&nbsp;	 * {@link ServletWebOperation}.
&nbsp;	 */
&nbsp;	private static class ServletWebOperationAdapter implements ServletWebOperation {
&nbsp;
&nbsp;		private static final String PATH_SEPARATOR = AntPathMatcher.DEFAULT_PATH_SEPARATOR;
&nbsp;
&nbsp;		private static final List&lt;Function&lt;Object, Object&gt;&gt; BODY_CONVERTERS;
&nbsp;
&nbsp;		static {
<b class="nc">&nbsp;			List&lt;Function&lt;Object, Object&gt;&gt; converters = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;			if (ClassUtils.isPresent(&quot;reactor.core.publisher.Flux&quot;,</b>
<b class="nc">&nbsp;					ServletWebOperationAdapter.class.getClassLoader())) {</b>
<b class="nc">&nbsp;				converters.add(new FluxBodyConverter());</b>
&nbsp;			}
<b class="nc">&nbsp;			BODY_CONVERTERS = Collections.unmodifiableList(converters);</b>
&nbsp;		}
&nbsp;
&nbsp;		private final WebOperation operation;
&nbsp;
<b class="nc">&nbsp;		ServletWebOperationAdapter(WebOperation operation) {</b>
<b class="nc">&nbsp;			this.operation = operation;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Object handle(HttpServletRequest request, @RequestBody(required = false) Map&lt;String, String&gt; body) {
<b class="nc">&nbsp;			HttpHeaders headers = new ServletServerHttpRequest(request).getHeaders();</b>
<b class="nc">&nbsp;			Map&lt;String, Object&gt; arguments = getArguments(request, body);</b>
&nbsp;			try {
<b class="nc">&nbsp;				ServletSecurityContext securityContext = new ServletSecurityContext(request);</b>
<b class="nc">&nbsp;				ProducibleOperationArgumentResolver producibleOperationArgumentResolver = new ProducibleOperationArgumentResolver(</b>
<b class="nc">&nbsp;						() -&gt; headers.get(&quot;Accept&quot;));</b>
<b class="nc">&nbsp;				OperationArgumentResolver serverNamespaceArgumentResolver = OperationArgumentResolver</b>
<b class="nc">&nbsp;					.of(WebServerNamespace.class, () -&gt; {</b>
<b class="nc">&nbsp;						WebApplicationContext applicationContext = WebApplicationContextUtils</b>
<b class="nc">&nbsp;							.getRequiredWebApplicationContext(request.getServletContext());</b>
<b class="nc">&nbsp;						return WebServerNamespace</b>
<b class="nc">&nbsp;							.from(WebServerApplicationContext.getServerNamespace(applicationContext));</b>
&nbsp;					});
<b class="nc">&nbsp;				InvocationContext invocationContext = new InvocationContext(securityContext, arguments,</b>
&nbsp;						serverNamespaceArgumentResolver, producibleOperationArgumentResolver);
<b class="nc">&nbsp;				return handleResult(this.operation.invoke(invocationContext), HttpMethod.valueOf(request.getMethod()));</b>
&nbsp;			}
<b class="nc">&nbsp;			catch (InvalidEndpointRequestException ex) {</b>
<b class="nc">&nbsp;				throw new InvalidEndpointBadRequestException(ex);</b>
&nbsp;			}
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public String toString() {
<b class="nc">&nbsp;			return &quot;Actuator web endpoint &#39;&quot; + this.operation.getId() + &quot;&#39;&quot;;</b>
&nbsp;		}
&nbsp;
&nbsp;		private Map&lt;String, Object&gt; getArguments(HttpServletRequest request, Map&lt;String, String&gt; body) {
<b class="nc">&nbsp;			Map&lt;String, Object&gt; arguments = new LinkedHashMap&lt;&gt;(getTemplateVariables(request));</b>
<b class="nc">&nbsp;			String matchAllRemainingPathSegmentsVariable = this.operation.getRequestPredicate()</b>
<b class="nc">&nbsp;				.getMatchAllRemainingPathSegmentsVariable();</b>
<b class="nc">&nbsp;			if (matchAllRemainingPathSegmentsVariable != null) {</b>
<b class="nc">&nbsp;				arguments.put(matchAllRemainingPathSegmentsVariable, getRemainingPathSegments(request));</b>
&nbsp;			}
<b class="nc">&nbsp;			if (body != null &amp;&amp; HttpMethod.POST.name().equals(request.getMethod())) {</b>
<b class="nc">&nbsp;				arguments.putAll(body);</b>
&nbsp;			}
<b class="nc">&nbsp;			request.getParameterMap()</b>
<b class="nc">&nbsp;				.forEach((name, values) -&gt; arguments.put(name,</b>
<b class="nc">&nbsp;						(values.length != 1) ? Arrays.asList(values) : values[0]));</b>
<b class="nc">&nbsp;			return arguments;</b>
&nbsp;		}
&nbsp;
&nbsp;		private Object getRemainingPathSegments(HttpServletRequest request) {
<b class="nc">&nbsp;			String[] pathTokens = tokenize(request, HandlerMapping.PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE, true);</b>
<b class="nc">&nbsp;			String[] patternTokens = tokenize(request, HandlerMapping.BEST_MATCHING_PATTERN_ATTRIBUTE, false);</b>
<b class="nc">&nbsp;			int numberOfRemainingPathSegments = pathTokens.length - patternTokens.length + 1;</b>
<b class="nc">&nbsp;			Assert.state(numberOfRemainingPathSegments &gt;= 0, &quot;Unable to extract remaining path segments&quot;);</b>
<b class="nc">&nbsp;			String[] remainingPathSegments = new String[numberOfRemainingPathSegments];</b>
<b class="nc">&nbsp;			System.arraycopy(pathTokens, patternTokens.length - 1, remainingPathSegments, 0,</b>
&nbsp;					numberOfRemainingPathSegments);
<b class="nc">&nbsp;			return remainingPathSegments;</b>
&nbsp;		}
&nbsp;
&nbsp;		private String[] tokenize(HttpServletRequest request, String attributeName, boolean decode) {
<b class="nc">&nbsp;			String value = (String) request.getAttribute(attributeName);</b>
<b class="nc">&nbsp;			String[] segments = StringUtils.tokenizeToStringArray(value, PATH_SEPARATOR, false, true);</b>
<b class="nc">&nbsp;			if (decode) {</b>
<b class="nc">&nbsp;				for (int i = 0; i &lt; segments.length; i++) {</b>
<b class="nc">&nbsp;					if (segments[i].contains(&quot;%&quot;)) {</b>
<b class="nc">&nbsp;						segments[i] = StringUtils.uriDecode(segments[i], StandardCharsets.UTF_8);</b>
&nbsp;					}
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			return segments;</b>
&nbsp;		}
&nbsp;
&nbsp;		@SuppressWarnings(&quot;unchecked&quot;)
&nbsp;		private Map&lt;String, String&gt; getTemplateVariables(HttpServletRequest request) {
<b class="nc">&nbsp;			return (Map&lt;String, String&gt;) request.getAttribute(HandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE);</b>
&nbsp;		}
&nbsp;
&nbsp;		private Object handleResult(Object result, HttpMethod httpMethod) {
<b class="nc">&nbsp;			if (result == null) {</b>
<b class="nc">&nbsp;				return new ResponseEntity&lt;&gt;(</b>
<b class="nc">&nbsp;						(httpMethod != HttpMethod.GET) ? HttpStatus.NO_CONTENT : HttpStatus.NOT_FOUND);</b>
&nbsp;			}
<b class="nc">&nbsp;			if (!(result instanceof WebEndpointResponse&lt;?&gt; response)) {</b>
<b class="nc">&nbsp;				return convertIfNecessary(result);</b>
&nbsp;			}
<b class="nc">&nbsp;			MediaType contentType = (response.getContentType() != null) ? new MediaType(response.getContentType())</b>
<b class="nc">&nbsp;					: null;</b>
<b class="nc">&nbsp;			return ResponseEntity.status(response.getStatus())</b>
<b class="nc">&nbsp;				.contentType(contentType)</b>
<b class="nc">&nbsp;				.body(convertIfNecessary(response.getBody()));</b>
&nbsp;		}
&nbsp;
&nbsp;		private Object convertIfNecessary(Object body) {
<b class="nc">&nbsp;			for (Function&lt;Object, Object&gt; converter : BODY_CONVERTERS) {</b>
<b class="nc">&nbsp;				body = converter.apply(body);</b>
<b class="nc">&nbsp;			}</b>
<b class="nc">&nbsp;			return body;</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		private static final class FluxBodyConverter implements Function&lt;Object, Object&gt; {</b>
&nbsp;
&nbsp;			@Override
&nbsp;			public Object apply(Object body) {
<b class="nc">&nbsp;				if (!(body instanceof Flux)) {</b>
<b class="nc">&nbsp;					return body;</b>
&nbsp;				}
<b class="nc">&nbsp;				return ((Flux&lt;?&gt;) body).collectList();</b>
&nbsp;			}
&nbsp;
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Handler for a {@link ServletWebOperation}.
&nbsp;	 */
&nbsp;	private static final class OperationHandler {
&nbsp;
&nbsp;		private final ServletWebOperation operation;
&nbsp;
<b class="nc">&nbsp;		OperationHandler(ServletWebOperation operation) {</b>
<b class="nc">&nbsp;			this.operation = operation;</b>
&nbsp;		}
&nbsp;
&nbsp;		@ResponseBody
&nbsp;		@Reflective
&nbsp;		Object handle(HttpServletRequest request, @RequestBody(required = false) Map&lt;String, String&gt; body) {
<b class="nc">&nbsp;			return this.operation.handle(request, body);</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public String toString() {
<b class="nc">&nbsp;			return this.operation.toString();</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * {@link HandlerMethod} subclass for endpoint information logging.
&nbsp;	 */
&nbsp;	private static class WebMvcEndpointHandlerMethod extends HandlerMethod {
&nbsp;
&nbsp;		WebMvcEndpointHandlerMethod(Object bean, Method method) {
<b class="nc">&nbsp;			super(bean, method);</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public String toString() {
<b class="nc">&nbsp;			return getBean().toString();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public HandlerMethod createWithResolvedBean() {
<b class="nc">&nbsp;			return this;</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Nested exception used to wrap an {@link InvalidEndpointRequestException} and
&nbsp;	 * provide a {@link HttpStatus#BAD_REQUEST} status.
&nbsp;	 */
&nbsp;	private static class InvalidEndpointBadRequestException extends ResponseStatusException {
&nbsp;
&nbsp;		InvalidEndpointBadRequestException(InvalidEndpointRequestException cause) {
<b class="nc">&nbsp;			super(HttpStatus.BAD_REQUEST, cause.getReason(), cause);</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	private static final class ServletSecurityContext implements SecurityContext {
&nbsp;
&nbsp;		private final HttpServletRequest request;
&nbsp;
<b class="nc">&nbsp;		private ServletSecurityContext(HttpServletRequest request) {</b>
<b class="nc">&nbsp;			this.request = request;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Principal getPrincipal() {
<b class="nc">&nbsp;			return this.request.getUserPrincipal();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public boolean isUserInRole(String role) {
<b class="nc">&nbsp;			return this.request.isUserInRole(role);</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
<b class="nc">&nbsp;	static class AbstractWebMvcEndpointHandlerMappingRuntimeHints implements RuntimeHintsRegistrar {</b>
&nbsp;
<b class="nc">&nbsp;		private final ReflectiveRuntimeHintsRegistrar reflectiveRegistrar = new ReflectiveRuntimeHintsRegistrar();</b>
&nbsp;
&nbsp;		@Override
&nbsp;		public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
<b class="nc">&nbsp;			this.reflectiveRegistrar.registerRuntimeHints(hints, OperationHandler.class);</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-04-01 11:12</div>
</div>
</body>
</html>
