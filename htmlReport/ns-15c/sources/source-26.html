


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > StandardConfigDataLocationResolver</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.springframework.boot.context.config</a>
</div>

<h1>Coverage Summary for Class: StandardConfigDataLocationResolver (org.springframework.boot.context.config)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">StandardConfigDataLocationResolver</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    57.1%
  </span>
  <span class="absValue">
    (16/28)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    44.4%
  </span>
  <span class="absValue">
    (56/126)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2012-2023 the original author or authors.
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *      https://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;
&nbsp;package org.springframework.boot.context.config;
&nbsp;
&nbsp;import java.io.File;
&nbsp;import java.util.ArrayDeque;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collection;
&nbsp;import java.util.Collections;
&nbsp;import java.util.Deque;
&nbsp;import java.util.LinkedHashSet;
&nbsp;import java.util.List;
&nbsp;import java.util.Set;
&nbsp;import java.util.regex.Matcher;
&nbsp;import java.util.regex.Pattern;
&nbsp;import java.util.stream.Collectors;
&nbsp;
&nbsp;import org.apache.commons.logging.Log;
&nbsp;
&nbsp;import org.springframework.boot.context.config.LocationResourceLoader.ResourceType;
&nbsp;import org.springframework.boot.context.properties.bind.Binder;
&nbsp;import org.springframework.boot.env.PropertySourceLoader;
&nbsp;import org.springframework.boot.logging.DeferredLogFactory;
&nbsp;import org.springframework.core.Ordered;
&nbsp;import org.springframework.core.env.Environment;
&nbsp;import org.springframework.core.io.ClassPathResource;
&nbsp;import org.springframework.core.io.Resource;
&nbsp;import org.springframework.core.io.ResourceLoader;
&nbsp;import org.springframework.core.io.support.SpringFactoriesLoader;
&nbsp;import org.springframework.core.log.LogMessage;
&nbsp;import org.springframework.util.Assert;
&nbsp;import org.springframework.util.ObjectUtils;
&nbsp;import org.springframework.util.StringUtils;
&nbsp;
&nbsp;/**
&nbsp; * {@link ConfigDataLocationResolver} for standard locations.
&nbsp; *
&nbsp; * @author Madhura Bhave
&nbsp; * @author Phillip Webb
&nbsp; * @author Scott Frederick
&nbsp; * @since 2.4.0
&nbsp; */
&nbsp;public class StandardConfigDataLocationResolver
&nbsp;		implements ConfigDataLocationResolver&lt;StandardConfigDataResource&gt;, Ordered {
&nbsp;
&nbsp;	private static final String PREFIX = &quot;resource:&quot;;
&nbsp;
&nbsp;	static final String CONFIG_NAME_PROPERTY = &quot;spring.config.name&quot;;
&nbsp;
<b class="fc">&nbsp;	static final String[] DEFAULT_CONFIG_NAMES = { &quot;application&quot; };</b>
&nbsp;
<b class="fc">&nbsp;	private static final Pattern URL_PREFIX = Pattern.compile(&quot;^([a-zA-Z][a-zA-Z0-9*]*?:)(.*$)&quot;);</b>
&nbsp;
<b class="fc">&nbsp;	private static final Pattern EXTENSION_HINT_PATTERN = Pattern.compile(&quot;^(.*)\\[(\\.\\w+)\\](?!\\[)$&quot;);</b>
&nbsp;
<b class="fc">&nbsp;	private static final String NO_PROFILE = null;</b>
&nbsp;
&nbsp;	private final Log logger;
&nbsp;
&nbsp;	private final List&lt;PropertySourceLoader&gt; propertySourceLoaders;
&nbsp;
&nbsp;	private final String[] configNames;
&nbsp;
&nbsp;	private final LocationResourceLoader resourceLoader;
&nbsp;
&nbsp;	/**
&nbsp;	 * Create a new {@link StandardConfigDataLocationResolver} instance.
&nbsp;	 * @param logFactory the factory for loggers to use
&nbsp;	 * @param binder a binder backed by the initial {@link Environment}
&nbsp;	 * @param resourceLoader a {@link ResourceLoader} used to load resources
&nbsp;	 */
&nbsp;	public StandardConfigDataLocationResolver(DeferredLogFactory logFactory, Binder binder,
<b class="fc">&nbsp;			ResourceLoader resourceLoader) {</b>
<b class="fc">&nbsp;		this.logger = logFactory.getLog(StandardConfigDataLocationResolver.class);</b>
<b class="fc">&nbsp;		this.propertySourceLoaders = SpringFactoriesLoader.loadFactories(PropertySourceLoader.class,</b>
<b class="fc">&nbsp;				getClass().getClassLoader());</b>
<b class="fc">&nbsp;		this.configNames = getConfigNames(binder);</b>
<b class="fc">&nbsp;		this.resourceLoader = new LocationResourceLoader(resourceLoader);</b>
&nbsp;	}
&nbsp;
&nbsp;	private String[] getConfigNames(Binder binder) {
<b class="fc">&nbsp;		String[] configNames = binder.bind(CONFIG_NAME_PROPERTY, String[].class).orElse(DEFAULT_CONFIG_NAMES);</b>
<b class="fc">&nbsp;		for (String configName : configNames) {</b>
<b class="fc">&nbsp;			validateConfigName(configName);</b>
&nbsp;		}
<b class="fc">&nbsp;		return configNames;</b>
&nbsp;	}
&nbsp;
&nbsp;	private void validateConfigName(String name) {
<b class="fc">&nbsp;		Assert.state(!name.contains(&quot;*&quot;), () -&gt; &quot;Config name &#39;&quot; + name + &quot;&#39; cannot contain &#39;*&#39;&quot;);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public int getOrder() {
<b class="nc">&nbsp;		return Ordered.LOWEST_PRECEDENCE;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public boolean isResolvable(ConfigDataLocationResolverContext context, ConfigDataLocation location) {
<b class="fc">&nbsp;		return true;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public List&lt;StandardConfigDataResource&gt; resolve(ConfigDataLocationResolverContext context,
&nbsp;			ConfigDataLocation location) throws ConfigDataNotFoundException {
<b class="fc">&nbsp;		return resolve(getReferences(context, location.split()));</b>
&nbsp;	}
&nbsp;
&nbsp;	private Set&lt;StandardConfigDataReference&gt; getReferences(ConfigDataLocationResolverContext context,
&nbsp;			ConfigDataLocation[] configDataLocations) {
<b class="fc">&nbsp;		Set&lt;StandardConfigDataReference&gt; references = new LinkedHashSet&lt;&gt;();</b>
<b class="fc">&nbsp;		for (ConfigDataLocation configDataLocation : configDataLocations) {</b>
<b class="fc">&nbsp;			references.addAll(getReferences(context, configDataLocation));</b>
&nbsp;		}
<b class="fc">&nbsp;		return references;</b>
&nbsp;	}
&nbsp;
&nbsp;	private Set&lt;StandardConfigDataReference&gt; getReferences(ConfigDataLocationResolverContext context,
&nbsp;			ConfigDataLocation configDataLocation) {
<b class="fc">&nbsp;		String resourceLocation = getResourceLocation(context, configDataLocation);</b>
&nbsp;		try {
<b class="fc">&nbsp;			if (isDirectory(resourceLocation)) {</b>
<b class="nc">&nbsp;				return getReferencesForDirectory(configDataLocation, resourceLocation, NO_PROFILE);</b>
&nbsp;			}
<b class="fc">&nbsp;			return getReferencesForFile(configDataLocation, resourceLocation, NO_PROFILE);</b>
&nbsp;		}
<b class="fc">&nbsp;		catch (RuntimeException ex) {</b>
<b class="fc">&nbsp;			throw new IllegalStateException(&quot;Unable to load config data from &#39;&quot; + configDataLocation + &quot;&#39;&quot;, ex);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public List&lt;StandardConfigDataResource&gt; resolveProfileSpecific(ConfigDataLocationResolverContext context,
&nbsp;			ConfigDataLocation location, Profiles profiles) {
<b class="fc">&nbsp;		return resolve(getProfileSpecificReferences(context, location.split(), profiles));</b>
&nbsp;	}
&nbsp;
&nbsp;	private Set&lt;StandardConfigDataReference&gt; getProfileSpecificReferences(ConfigDataLocationResolverContext context,
&nbsp;			ConfigDataLocation[] configDataLocations, Profiles profiles) {
<b class="fc">&nbsp;		Set&lt;StandardConfigDataReference&gt; references = new LinkedHashSet&lt;&gt;();</b>
<b class="fc">&nbsp;		for (String profile : profiles) {</b>
<b class="nc">&nbsp;			for (ConfigDataLocation configDataLocation : configDataLocations) {</b>
<b class="nc">&nbsp;				String resourceLocation = getResourceLocation(context, configDataLocation);</b>
<b class="nc">&nbsp;				references.addAll(getReferences(configDataLocation, resourceLocation, profile));</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
<b class="nc">&nbsp;		return references;</b>
&nbsp;	}
&nbsp;
&nbsp;	private String getResourceLocation(ConfigDataLocationResolverContext context,
&nbsp;			ConfigDataLocation configDataLocation) {
<b class="fc">&nbsp;		String resourceLocation = configDataLocation.getNonPrefixedValue(PREFIX);</b>
<b class="fc">&nbsp;		boolean isAbsolute = resourceLocation.startsWith(&quot;/&quot;) || URL_PREFIX.matcher(resourceLocation).matches();</b>
<b class="fc">&nbsp;		if (isAbsolute) {</b>
<b class="nc">&nbsp;			return resourceLocation;</b>
&nbsp;		}
<b class="fc">&nbsp;		ConfigDataResource parent = context.getParent();</b>
<b class="fc">&nbsp;		if (parent instanceof StandardConfigDataResource resource) {</b>
<b class="nc">&nbsp;			String parentResourceLocation = resource.getReference().getResourceLocation();</b>
<b class="nc">&nbsp;			String parentDirectory = parentResourceLocation.substring(0, parentResourceLocation.lastIndexOf(&quot;/&quot;) + 1);</b>
<b class="nc">&nbsp;			return parentDirectory + resourceLocation;</b>
&nbsp;		}
<b class="fc">&nbsp;		return resourceLocation;</b>
&nbsp;	}
&nbsp;
&nbsp;	private Set&lt;StandardConfigDataReference&gt; getReferences(ConfigDataLocation configDataLocation,
&nbsp;			String resourceLocation, String profile) {
<b class="nc">&nbsp;		if (isDirectory(resourceLocation)) {</b>
<b class="nc">&nbsp;			return getReferencesForDirectory(configDataLocation, resourceLocation, profile);</b>
&nbsp;		}
<b class="nc">&nbsp;		return getReferencesForFile(configDataLocation, resourceLocation, profile);</b>
&nbsp;	}
&nbsp;
&nbsp;	private Set&lt;StandardConfigDataReference&gt; getReferencesForDirectory(ConfigDataLocation configDataLocation,
&nbsp;			String directory, String profile) {
<b class="nc">&nbsp;		Set&lt;StandardConfigDataReference&gt; references = new LinkedHashSet&lt;&gt;();</b>
<b class="nc">&nbsp;		for (String name : this.configNames) {</b>
<b class="nc">&nbsp;			Deque&lt;StandardConfigDataReference&gt; referencesForName = getReferencesForConfigName(name, configDataLocation,</b>
&nbsp;					directory, profile);
<b class="nc">&nbsp;			references.addAll(referencesForName);</b>
&nbsp;		}
<b class="nc">&nbsp;		return references;</b>
&nbsp;	}
&nbsp;
&nbsp;	private Deque&lt;StandardConfigDataReference&gt; getReferencesForConfigName(String name,
&nbsp;			ConfigDataLocation configDataLocation, String directory, String profile) {
<b class="nc">&nbsp;		Deque&lt;StandardConfigDataReference&gt; references = new ArrayDeque&lt;&gt;();</b>
<b class="nc">&nbsp;		for (PropertySourceLoader propertySourceLoader : this.propertySourceLoaders) {</b>
<b class="nc">&nbsp;			for (String extension : propertySourceLoader.getFileExtensions()) {</b>
<b class="nc">&nbsp;				StandardConfigDataReference reference = new StandardConfigDataReference(configDataLocation, directory,</b>
&nbsp;						directory + name, profile, extension, propertySourceLoader);
<b class="nc">&nbsp;				if (!references.contains(reference)) {</b>
<b class="nc">&nbsp;					references.addFirst(reference);</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;		}</b>
<b class="nc">&nbsp;		return references;</b>
&nbsp;	}
&nbsp;
&nbsp;	private Set&lt;StandardConfigDataReference&gt; getReferencesForFile(ConfigDataLocation configDataLocation, String file,
&nbsp;			String profile) {
<b class="fc">&nbsp;		Matcher extensionHintMatcher = EXTENSION_HINT_PATTERN.matcher(file);</b>
<b class="fc">&nbsp;		boolean extensionHintLocation = extensionHintMatcher.matches();</b>
<b class="fc">&nbsp;		if (extensionHintLocation) {</b>
<b class="nc">&nbsp;			file = extensionHintMatcher.group(1) + extensionHintMatcher.group(2);</b>
&nbsp;		}
<b class="fc">&nbsp;		for (PropertySourceLoader propertySourceLoader : this.propertySourceLoaders) {</b>
<b class="fc">&nbsp;			String extension = getLoadableFileExtension(propertySourceLoader, file);</b>
<b class="fc">&nbsp;			if (extension != null) {</b>
<b class="nc">&nbsp;				String root = file.substring(0, file.length() - extension.length() - 1);</b>
<b class="nc">&nbsp;				StandardConfigDataReference reference = new StandardConfigDataReference(configDataLocation, null, root,</b>
<b class="nc">&nbsp;						profile, (!extensionHintLocation) ? extension : null, propertySourceLoader);</b>
<b class="nc">&nbsp;				return Collections.singleton(reference);</b>
&nbsp;			}
<b class="fc">&nbsp;		}</b>
<b class="fc">&nbsp;		if (configDataLocation.isOptional()) {</b>
<b class="nc">&nbsp;			return Collections.emptySet();</b>
&nbsp;		}
<b class="fc">&nbsp;		throw new IllegalStateException(&quot;File extension is not known to any PropertySourceLoader. &quot;</b>
&nbsp;				+ &quot;If the location is meant to reference a directory, it must end in &#39;/&#39; or File.separator&quot;);
&nbsp;	}
&nbsp;
&nbsp;	private String getLoadableFileExtension(PropertySourceLoader loader, String file) {
<b class="fc">&nbsp;		for (String fileExtension : loader.getFileExtensions()) {</b>
<b class="fc">&nbsp;			if (StringUtils.endsWithIgnoreCase(file, fileExtension)) {</b>
<b class="nc">&nbsp;				return fileExtension;</b>
&nbsp;			}
&nbsp;		}
<b class="fc">&nbsp;		return null;</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean isDirectory(String resourceLocation) {
<b class="fc">&nbsp;		return resourceLocation.endsWith(&quot;/&quot;) || resourceLocation.endsWith(File.separator);</b>
&nbsp;	}
&nbsp;
&nbsp;	private List&lt;StandardConfigDataResource&gt; resolve(Set&lt;StandardConfigDataReference&gt; references) {
<b class="fc">&nbsp;		List&lt;StandardConfigDataResource&gt; resolved = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;		for (StandardConfigDataReference reference : references) {</b>
<b class="nc">&nbsp;			resolved.addAll(resolve(reference));</b>
<b class="nc">&nbsp;		}</b>
<b class="fc">&nbsp;		if (resolved.isEmpty()) {</b>
<b class="fc">&nbsp;			resolved.addAll(resolveEmptyDirectories(references));</b>
&nbsp;		}
<b class="fc">&nbsp;		return resolved;</b>
&nbsp;	}
&nbsp;
&nbsp;	private Collection&lt;StandardConfigDataResource&gt; resolveEmptyDirectories(
&nbsp;			Set&lt;StandardConfigDataReference&gt; references) {
<b class="fc">&nbsp;		Set&lt;StandardConfigDataResource&gt; empty = new LinkedHashSet&lt;&gt;();</b>
<b class="fc">&nbsp;		for (StandardConfigDataReference reference : references) {</b>
<b class="nc">&nbsp;			if (reference.getDirectory() != null) {</b>
<b class="nc">&nbsp;				empty.addAll(resolveEmptyDirectories(reference));</b>
&nbsp;			}
<b class="nc">&nbsp;		}</b>
<b class="fc">&nbsp;		return empty;</b>
&nbsp;	}
&nbsp;
&nbsp;	private Set&lt;StandardConfigDataResource&gt; resolveEmptyDirectories(StandardConfigDataReference reference) {
<b class="nc">&nbsp;		if (!this.resourceLoader.isPattern(reference.getResourceLocation())) {</b>
<b class="nc">&nbsp;			return resolveNonPatternEmptyDirectories(reference);</b>
&nbsp;		}
<b class="nc">&nbsp;		return resolvePatternEmptyDirectories(reference);</b>
&nbsp;	}
&nbsp;
&nbsp;	private Set&lt;StandardConfigDataResource&gt; resolveNonPatternEmptyDirectories(StandardConfigDataReference reference) {
<b class="nc">&nbsp;		Resource resource = this.resourceLoader.getResource(reference.getDirectory());</b>
<b class="nc">&nbsp;		return (resource instanceof ClassPathResource || !resource.exists()) ? Collections.emptySet()</b>
<b class="nc">&nbsp;				: Collections.singleton(new StandardConfigDataResource(reference, resource, true));</b>
&nbsp;	}
&nbsp;
&nbsp;	private Set&lt;StandardConfigDataResource&gt; resolvePatternEmptyDirectories(StandardConfigDataReference reference) {
<b class="nc">&nbsp;		Resource[] subdirectories = this.resourceLoader.getResources(reference.getDirectory(), ResourceType.DIRECTORY);</b>
<b class="nc">&nbsp;		ConfigDataLocation location = reference.getConfigDataLocation();</b>
<b class="nc">&nbsp;		if (!location.isOptional() &amp;&amp; ObjectUtils.isEmpty(subdirectories)) {</b>
<b class="nc">&nbsp;			String message = String.format(&quot;Config data location &#39;%s&#39; contains no subdirectories&quot;, location);</b>
<b class="nc">&nbsp;			throw new ConfigDataLocationNotFoundException(location, message, null);</b>
&nbsp;		}
<b class="nc">&nbsp;		return Arrays.stream(subdirectories)</b>
<b class="nc">&nbsp;			.filter(Resource::exists)</b>
<b class="nc">&nbsp;			.map((resource) -&gt; new StandardConfigDataResource(reference, resource, true))</b>
<b class="nc">&nbsp;			.collect(Collectors.toCollection(LinkedHashSet::new));</b>
&nbsp;	}
&nbsp;
&nbsp;	private List&lt;StandardConfigDataResource&gt; resolve(StandardConfigDataReference reference) {
<b class="nc">&nbsp;		if (!this.resourceLoader.isPattern(reference.getResourceLocation())) {</b>
<b class="nc">&nbsp;			return resolveNonPattern(reference);</b>
&nbsp;		}
<b class="nc">&nbsp;		return resolvePattern(reference);</b>
&nbsp;	}
&nbsp;
&nbsp;	private List&lt;StandardConfigDataResource&gt; resolveNonPattern(StandardConfigDataReference reference) {
<b class="nc">&nbsp;		Resource resource = this.resourceLoader.getResource(reference.getResourceLocation());</b>
<b class="nc">&nbsp;		if (!resource.exists() &amp;&amp; reference.isSkippable()) {</b>
<b class="nc">&nbsp;			logSkippingResource(reference);</b>
<b class="nc">&nbsp;			return Collections.emptyList();</b>
&nbsp;		}
<b class="nc">&nbsp;		return Collections.singletonList(createConfigResourceLocation(reference, resource));</b>
&nbsp;	}
&nbsp;
&nbsp;	private List&lt;StandardConfigDataResource&gt; resolvePattern(StandardConfigDataReference reference) {
<b class="nc">&nbsp;		List&lt;StandardConfigDataResource&gt; resolved = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;		for (Resource resource : this.resourceLoader.getResources(reference.getResourceLocation(), ResourceType.FILE)) {</b>
<b class="nc">&nbsp;			if (!resource.exists() &amp;&amp; reference.isSkippable()) {</b>
<b class="nc">&nbsp;				logSkippingResource(reference);</b>
&nbsp;			}
&nbsp;			else {
<b class="nc">&nbsp;				resolved.add(createConfigResourceLocation(reference, resource));</b>
&nbsp;			}
&nbsp;		}
<b class="nc">&nbsp;		return resolved;</b>
&nbsp;	}
&nbsp;
&nbsp;	private void logSkippingResource(StandardConfigDataReference reference) {
<b class="nc">&nbsp;		this.logger.trace(LogMessage.format(&quot;Skipping missing resource %s&quot;, reference));</b>
&nbsp;	}
&nbsp;
&nbsp;	private StandardConfigDataResource createConfigResourceLocation(StandardConfigDataReference reference,
&nbsp;			Resource resource) {
<b class="nc">&nbsp;		return new StandardConfigDataResource(reference, resource);</b>
&nbsp;	}
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-04-01 11:12</div>
</div>
</body>
</html>
