


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > SpringBootJoranConfigurator</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.springframework.boot.logging.logback</a>
</div>

<h1>Coverage Summary for Class: SpringBootJoranConfigurator (org.springframework.boot.logging.logback)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">SpringBootJoranConfigurator</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/26)
  </span>
</td>
</tr>
  <tr>
    <td class="name">SpringBootJoranConfigurator$LogbackConfigurationAotContribution</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SpringBootJoranConfigurator$ModelReader</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SpringBootJoranConfigurator$ModelWriter</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/15)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/88)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SpringBootJoranConfigurator$PatternRules</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/35)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/33)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/165)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2012-2023 the original author or authors.
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *      https://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;
&nbsp;package org.springframework.boot.logging.logback;
&nbsp;
&nbsp;import java.io.ByteArrayInputStream;
&nbsp;import java.io.ByteArrayOutputStream;
&nbsp;import java.io.IOException;
&nbsp;import java.io.InputStream;
&nbsp;import java.io.ObjectInputStream;
&nbsp;import java.io.ObjectOutputStream;
&nbsp;import java.io.Serializable;
&nbsp;import java.lang.reflect.Method;
&nbsp;import java.lang.reflect.Modifier;
&nbsp;import java.util.Collection;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.Map;
&nbsp;import java.util.Properties;
&nbsp;import java.util.Set;
&nbsp;import java.util.function.Supplier;
&nbsp;import java.util.stream.Stream;
&nbsp;
&nbsp;import ch.qos.logback.classic.joran.JoranConfigurator;
&nbsp;import ch.qos.logback.core.Context;
&nbsp;import ch.qos.logback.core.CoreConstants;
&nbsp;import ch.qos.logback.core.joran.spi.ElementSelector;
&nbsp;import ch.qos.logback.core.joran.spi.RuleStore;
&nbsp;import ch.qos.logback.core.joran.util.PropertySetter;
&nbsp;import ch.qos.logback.core.joran.util.beans.BeanDescription;
&nbsp;import ch.qos.logback.core.model.ComponentModel;
&nbsp;import ch.qos.logback.core.model.Model;
&nbsp;import ch.qos.logback.core.model.ModelUtil;
&nbsp;import ch.qos.logback.core.model.processor.DefaultProcessor;
&nbsp;import ch.qos.logback.core.model.processor.ModelInterpretationContext;
&nbsp;import ch.qos.logback.core.spi.ContextAware;
&nbsp;import ch.qos.logback.core.spi.ContextAwareBase;
&nbsp;import ch.qos.logback.core.util.AggregationType;
&nbsp;
&nbsp;import org.springframework.aot.generate.GenerationContext;
&nbsp;import org.springframework.aot.hint.MemberCategory;
&nbsp;import org.springframework.aot.hint.SerializationHints;
&nbsp;import org.springframework.aot.hint.TypeReference;
&nbsp;import org.springframework.beans.factory.aot.BeanFactoryInitializationAotContribution;
&nbsp;import org.springframework.beans.factory.aot.BeanFactoryInitializationCode;
&nbsp;import org.springframework.boot.logging.LoggingInitializationContext;
&nbsp;import org.springframework.core.CollectionFactory;
&nbsp;import org.springframework.core.NativeDetector;
&nbsp;import org.springframework.core.io.ByteArrayResource;
&nbsp;import org.springframework.core.io.ClassPathResource;
&nbsp;import org.springframework.core.io.Resource;
&nbsp;import org.springframework.core.io.support.PropertiesLoaderUtils;
&nbsp;import org.springframework.util.ClassUtils;
&nbsp;import org.springframework.util.ReflectionUtils;
&nbsp;import org.springframework.util.function.SingletonSupplier;
&nbsp;
&nbsp;/**
&nbsp; * Extended version of the Logback {@link JoranConfigurator} that adds additional Spring
&nbsp; * Boot rules.
&nbsp; *
&nbsp; * @author Phillip Webb
&nbsp; * @author Andy Wilkinson
&nbsp; */
&nbsp;class SpringBootJoranConfigurator extends JoranConfigurator {
&nbsp;
&nbsp;	private final LoggingInitializationContext initializationContext;
&nbsp;
<b class="nc">&nbsp;	SpringBootJoranConfigurator(LoggingInitializationContext initializationContext) {</b>
<b class="nc">&nbsp;		this.initializationContext = initializationContext;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	protected void sanityCheck(Model topModel) {
<b class="nc">&nbsp;		super.sanityCheck(topModel);</b>
<b class="nc">&nbsp;		performCheck(new SpringProfileIfNestedWithinSecondPhaseElementSanityChecker(), topModel);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	protected void addModelHandlerAssociations(DefaultProcessor defaultProcessor) {
<b class="nc">&nbsp;		defaultProcessor.addHandler(SpringPropertyModel.class,</b>
<b class="nc">&nbsp;				(handlerContext, handlerMic) -&gt; new SpringPropertyModelHandler(this.context,</b>
<b class="nc">&nbsp;						this.initializationContext.getEnvironment()));</b>
<b class="nc">&nbsp;		defaultProcessor.addHandler(SpringProfileModel.class,</b>
<b class="nc">&nbsp;				(handlerContext, handlerMic) -&gt; new SpringProfileModelHandler(this.context,</b>
<b class="nc">&nbsp;						this.initializationContext.getEnvironment()));</b>
<b class="nc">&nbsp;		super.addModelHandlerAssociations(defaultProcessor);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void addElementSelectorAndActionAssociations(RuleStore ruleStore) {
<b class="nc">&nbsp;		super.addElementSelectorAndActionAssociations(ruleStore);</b>
<b class="nc">&nbsp;		ruleStore.addRule(new ElementSelector(&quot;configuration/springProperty&quot;), SpringPropertyAction::new);</b>
<b class="nc">&nbsp;		ruleStore.addRule(new ElementSelector(&quot;*/springProfile&quot;), SpringProfileAction::new);</b>
<b class="nc">&nbsp;		ruleStore.addTransparentPathPart(&quot;springProfile&quot;);</b>
&nbsp;	}
&nbsp;
&nbsp;	boolean configureUsingAotGeneratedArtifacts() {
<b class="nc">&nbsp;		if (!new PatternRules(getContext()).load()) {</b>
<b class="nc">&nbsp;			return false;</b>
&nbsp;		}
<b class="nc">&nbsp;		Model model = new ModelReader().read();</b>
<b class="nc">&nbsp;		processModel(model);</b>
<b class="nc">&nbsp;		registerSafeConfiguration(model);</b>
<b class="nc">&nbsp;		return true;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void processModel(Model model) {
<b class="nc">&nbsp;		super.processModel(model);</b>
<b class="nc">&nbsp;		if (!NativeDetector.inNativeImage() &amp;&amp; isAotProcessingInProgress()) {</b>
<b class="nc">&nbsp;			getContext().putObject(BeanFactoryInitializationAotContribution.class.getName(),</b>
<b class="nc">&nbsp;					new LogbackConfigurationAotContribution(model, getModelInterpretationContext(), getContext()));</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private boolean isAotProcessingInProgress() {
<b class="nc">&nbsp;		return Boolean.getBoolean(&quot;spring.aot.processing&quot;);</b>
&nbsp;	}
&nbsp;
&nbsp;	static final class LogbackConfigurationAotContribution implements BeanFactoryInitializationAotContribution {
&nbsp;
&nbsp;		private final ModelWriter modelWriter;
&nbsp;
&nbsp;		private final PatternRules patternRules;
&nbsp;
&nbsp;		private LogbackConfigurationAotContribution(Model model, ModelInterpretationContext interpretationContext,
<b class="nc">&nbsp;				Context context) {</b>
<b class="nc">&nbsp;			this.modelWriter = new ModelWriter(model, interpretationContext);</b>
<b class="nc">&nbsp;			this.patternRules = new PatternRules(context);</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public void applyTo(GenerationContext generationContext,
&nbsp;				BeanFactoryInitializationCode beanFactoryInitializationCode) {
<b class="nc">&nbsp;			this.modelWriter.writeTo(generationContext);</b>
<b class="nc">&nbsp;			this.patternRules.save(generationContext);</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	private static final class ModelWriter {
&nbsp;
&nbsp;		private static final String MODEL_RESOURCE_LOCATION = &quot;META-INF/spring/logback-model&quot;;
&nbsp;
&nbsp;		private final Model model;
&nbsp;
&nbsp;		private final ModelInterpretationContext modelInterpretationContext;
&nbsp;
<b class="nc">&nbsp;		private ModelWriter(Model model, ModelInterpretationContext modelInterpretationContext) {</b>
<b class="nc">&nbsp;			this.model = model;</b>
<b class="nc">&nbsp;			this.modelInterpretationContext = modelInterpretationContext;</b>
&nbsp;		}
&nbsp;
&nbsp;		private void writeTo(GenerationContext generationContext) {
<b class="nc">&nbsp;			ByteArrayOutputStream bytes = new ByteArrayOutputStream();</b>
<b class="nc">&nbsp;			try (ObjectOutputStream output = new ObjectOutputStream(bytes)) {</b>
<b class="nc">&nbsp;				output.writeObject(this.model);</b>
<b class="nc">&nbsp;			}</b>
<b class="nc">&nbsp;			catch (IOException ex) {</b>
<b class="nc">&nbsp;				throw new RuntimeException(ex);</b>
<b class="nc">&nbsp;			}</b>
<b class="nc">&nbsp;			Resource modelResource = new ByteArrayResource(bytes.toByteArray());</b>
<b class="nc">&nbsp;			generationContext.getGeneratedFiles().addResourceFile(MODEL_RESOURCE_LOCATION, modelResource);</b>
<b class="nc">&nbsp;			generationContext.getRuntimeHints().resources().registerPattern(MODEL_RESOURCE_LOCATION);</b>
<b class="nc">&nbsp;			SerializationHints serializationHints = generationContext.getRuntimeHints().serialization();</b>
<b class="nc">&nbsp;			serializationTypes(this.model).forEach(serializationHints::registerType);</b>
<b class="nc">&nbsp;			reflectionTypes(this.model).forEach((type) -&gt; generationContext.getRuntimeHints()</b>
<b class="nc">&nbsp;				.reflection()</b>
<b class="nc">&nbsp;				.registerType(TypeReference.of(type), MemberCategory.INTROSPECT_PUBLIC_METHODS,</b>
&nbsp;						MemberCategory.INVOKE_PUBLIC_METHODS, MemberCategory.INVOKE_PUBLIC_CONSTRUCTORS));
&nbsp;		}
&nbsp;
&nbsp;		@SuppressWarnings(&quot;unchecked&quot;)
&nbsp;		private Set&lt;Class&lt;? extends Serializable&gt;&gt; serializationTypes(Model model) {
<b class="nc">&nbsp;			Set&lt;Class&lt;? extends Serializable&gt;&gt; modelClasses = new HashSet&lt;&gt;();</b>
<b class="nc">&nbsp;			Class&lt;?&gt; candidate = model.getClass();</b>
<b class="nc">&nbsp;			while (Model.class.isAssignableFrom(candidate)) {</b>
<b class="nc">&nbsp;				if (modelClasses.add((Class&lt;? extends Model&gt;) candidate)) {</b>
<b class="nc">&nbsp;					ReflectionUtils.doWithFields(candidate, (field) -&gt; {</b>
<b class="nc">&nbsp;						if (Modifier.isStatic(field.getModifiers())) {</b>
&nbsp;							return;
&nbsp;						}
<b class="nc">&nbsp;						ReflectionUtils.makeAccessible(field);</b>
<b class="nc">&nbsp;						Object value = field.get(model);</b>
<b class="nc">&nbsp;						if (value != null) {</b>
<b class="nc">&nbsp;							Class&lt;?&gt; fieldType = value.getClass();</b>
<b class="nc">&nbsp;							if (Serializable.class.isAssignableFrom(fieldType)) {</b>
<b class="nc">&nbsp;								modelClasses.add((Class&lt;? extends Serializable&gt;) fieldType);</b>
&nbsp;							}
&nbsp;						}
&nbsp;					});
<b class="nc">&nbsp;					candidate = candidate.getSuperclass();</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			for (Model submodel : model.getSubModels()) {</b>
<b class="nc">&nbsp;				modelClasses.addAll(serializationTypes(submodel));</b>
<b class="nc">&nbsp;			}</b>
<b class="nc">&nbsp;			return modelClasses;</b>
&nbsp;		}
&nbsp;
&nbsp;		private Set&lt;String&gt; reflectionTypes(Model model) {
<b class="nc">&nbsp;			return reflectionTypes(model, () -&gt; null);</b>
&nbsp;		}
&nbsp;
&nbsp;		private Set&lt;String&gt; reflectionTypes(Model model, Supplier&lt;Object&gt; parent) {
<b class="nc">&nbsp;			Set&lt;String&gt; reflectionTypes = new HashSet&lt;&gt;();</b>
<b class="nc">&nbsp;			Class&lt;?&gt; componentType = determineType(model, parent);</b>
<b class="nc">&nbsp;			if (componentType != null) {</b>
<b class="nc">&nbsp;				processComponent(componentType, reflectionTypes);</b>
&nbsp;			}
<b class="nc">&nbsp;			Supplier&lt;Object&gt; componentSupplier = SingletonSupplier.ofNullable(() -&gt; instantiate(componentType));</b>
<b class="nc">&nbsp;			for (Model submodel : model.getSubModels()) {</b>
<b class="nc">&nbsp;				reflectionTypes.addAll(reflectionTypes(submodel, componentSupplier));</b>
<b class="nc">&nbsp;			}</b>
<b class="nc">&nbsp;			return reflectionTypes;</b>
&nbsp;		}
&nbsp;
&nbsp;		private Class&lt;?&gt; determineType(Model model, Supplier&lt;Object&gt; parentSupplier) {
<b class="nc">&nbsp;			String className = (model instanceof ComponentModel componentModel) ? componentModel.getClassName() : null;</b>
<b class="nc">&nbsp;			if (className != null) {</b>
<b class="nc">&nbsp;				return loadImportType(className);</b>
&nbsp;			}
<b class="nc">&nbsp;			String tag = model.getTag();</b>
<b class="nc">&nbsp;			if (tag != null) {</b>
<b class="nc">&nbsp;				className = this.modelInterpretationContext.getDefaultNestedComponentRegistry()</b>
<b class="nc">&nbsp;					.findDefaultComponentTypeByTag(tag);</b>
<b class="nc">&nbsp;				if (className != null) {</b>
<b class="nc">&nbsp;					return loadImportType(className);</b>
&nbsp;				}
<b class="nc">&nbsp;				return inferTypeFromParent(parentSupplier, tag);</b>
&nbsp;			}
<b class="nc">&nbsp;			return null;</b>
&nbsp;		}
&nbsp;
&nbsp;		private Class&lt;?&gt; loadImportType(String className) {
<b class="nc">&nbsp;			return loadComponentType(this.modelInterpretationContext.getImport(className));</b>
&nbsp;		}
&nbsp;
&nbsp;		private Class&lt;?&gt; inferTypeFromParent(Supplier&lt;Object&gt; parentSupplier, String tag) {
<b class="nc">&nbsp;			Object parent = parentSupplier.get();</b>
<b class="nc">&nbsp;			if (parent != null) {</b>
&nbsp;				try {
<b class="nc">&nbsp;					PropertySetter propertySetter = new PropertySetter(</b>
<b class="nc">&nbsp;							this.modelInterpretationContext.getBeanDescriptionCache(), parent);</b>
<b class="nc">&nbsp;					Class&lt;?&gt; typeFromPropertySetter = propertySetter.getClassNameViaImplicitRules(tag,</b>
&nbsp;							AggregationType.AS_COMPLEX_PROPERTY,
<b class="nc">&nbsp;							this.modelInterpretationContext.getDefaultNestedComponentRegistry());</b>
<b class="nc">&nbsp;					return typeFromPropertySetter;</b>
&nbsp;				}
<b class="nc">&nbsp;				catch (Exception ex) {</b>
<b class="nc">&nbsp;					return null;</b>
&nbsp;				}
&nbsp;			}
<b class="nc">&nbsp;			return null;</b>
&nbsp;		}
&nbsp;
&nbsp;		private Class&lt;?&gt; loadComponentType(String componentType) {
&nbsp;			try {
<b class="nc">&nbsp;				return ClassUtils.forName(this.modelInterpretationContext.subst(componentType),</b>
<b class="nc">&nbsp;						getClass().getClassLoader());</b>
&nbsp;			}
<b class="nc">&nbsp;			catch (Throwable ex) {</b>
<b class="nc">&nbsp;				throw new RuntimeException(&quot;Failed to load component type &#39;&quot; + componentType + &quot;&#39;&quot;, ex);</b>
&nbsp;			}
&nbsp;		}
&nbsp;
&nbsp;		private Object instantiate(Class&lt;?&gt; type) {
&nbsp;			try {
<b class="nc">&nbsp;				return type.getConstructor().newInstance();</b>
&nbsp;			}
<b class="nc">&nbsp;			catch (Exception ex) {</b>
<b class="nc">&nbsp;				return null;</b>
&nbsp;			}
&nbsp;		}
&nbsp;
&nbsp;		private void processComponent(Class&lt;?&gt; componentType, Set&lt;String&gt; reflectionTypes) {
<b class="nc">&nbsp;			BeanDescription beanDescription = this.modelInterpretationContext.getBeanDescriptionCache()</b>
<b class="nc">&nbsp;				.getBeanDescription(componentType);</b>
<b class="nc">&nbsp;			reflectionTypes.addAll(parameterTypesNames(beanDescription.getPropertyNameToAdder().values()));</b>
<b class="nc">&nbsp;			reflectionTypes.addAll(parameterTypesNames(beanDescription.getPropertyNameToSetter().values()));</b>
<b class="nc">&nbsp;			reflectionTypes.add(componentType.getCanonicalName());</b>
&nbsp;		}
&nbsp;
&nbsp;		private Collection&lt;String&gt; parameterTypesNames(Collection&lt;Method&gt; methods) {
<b class="nc">&nbsp;			return methods.stream()</b>
<b class="nc">&nbsp;				.filter((method) -&gt; !method.getDeclaringClass().equals(ContextAware.class)</b>
<b class="nc">&nbsp;						&amp;&amp; !method.getDeclaringClass().equals(ContextAwareBase.class))</b>
<b class="nc">&nbsp;				.map(Method::getParameterTypes)</b>
<b class="nc">&nbsp;				.flatMap(Stream::of)</b>
<b class="nc">&nbsp;				.filter((type) -&gt; !type.isPrimitive() &amp;&amp; !type.equals(String.class))</b>
<b class="nc">&nbsp;				.map((type) -&gt; type.isArray() ? type.getComponentType() : type)</b>
<b class="nc">&nbsp;				.map(Class::getName)</b>
<b class="nc">&nbsp;				.toList();</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
<b class="nc">&nbsp;	private static final class ModelReader {</b>
&nbsp;
&nbsp;		private Model read() {
<b class="nc">&nbsp;			try (InputStream modelInput = getClass().getClassLoader()</b>
<b class="nc">&nbsp;				.getResourceAsStream(ModelWriter.MODEL_RESOURCE_LOCATION)) {</b>
<b class="nc">&nbsp;				try (ObjectInputStream input = new ObjectInputStream(modelInput)) {</b>
<b class="nc">&nbsp;					Model model = (Model) input.readObject();</b>
<b class="nc">&nbsp;					ModelUtil.resetForReuse(model);</b>
<b class="nc">&nbsp;					return model;</b>
<b class="nc">&nbsp;				}</b>
<b class="nc">&nbsp;			}</b>
<b class="nc">&nbsp;			catch (Exception ex) {</b>
<b class="nc">&nbsp;				throw new RuntimeException(&quot;Failed to load model from &#39;&quot; + ModelWriter.MODEL_RESOURCE_LOCATION + &quot;&#39;&quot;,</b>
&nbsp;						ex);
&nbsp;			}
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	private static final class PatternRules {
&nbsp;
&nbsp;		private static final String RESOURCE_LOCATION = &quot;META-INF/spring/logback-pattern-rules&quot;;
&nbsp;
&nbsp;		private final Context context;
&nbsp;
<b class="nc">&nbsp;		private PatternRules(Context context) {</b>
<b class="nc">&nbsp;			this.context = context;</b>
&nbsp;		}
&nbsp;
&nbsp;		private boolean load() {
&nbsp;			try {
<b class="nc">&nbsp;				ClassPathResource resource = new ClassPathResource(RESOURCE_LOCATION);</b>
<b class="nc">&nbsp;				if (!resource.exists()) {</b>
<b class="nc">&nbsp;					return false;</b>
&nbsp;				}
<b class="nc">&nbsp;				Properties properties = PropertiesLoaderUtils.loadProperties(resource);</b>
<b class="nc">&nbsp;				Map&lt;String, String&gt; patternRuleRegistry = getRegistryMap();</b>
<b class="nc">&nbsp;				for (String word : properties.stringPropertyNames()) {</b>
<b class="nc">&nbsp;					patternRuleRegistry.put(word, properties.getProperty(word));</b>
<b class="nc">&nbsp;				}</b>
<b class="nc">&nbsp;				return true;</b>
&nbsp;			}
<b class="nc">&nbsp;			catch (Exception ex) {</b>
<b class="nc">&nbsp;				throw new RuntimeException(ex);</b>
&nbsp;			}
&nbsp;		}
&nbsp;
&nbsp;		@SuppressWarnings(&quot;unchecked&quot;)
&nbsp;		private Map&lt;String, String&gt; getRegistryMap() {
<b class="nc">&nbsp;			Map&lt;String, String&gt; patternRuleRegistry = (Map&lt;String, String&gt;) this.context</b>
<b class="nc">&nbsp;				.getObject(CoreConstants.PATTERN_RULE_REGISTRY);</b>
<b class="nc">&nbsp;			if (patternRuleRegistry == null) {</b>
<b class="nc">&nbsp;				patternRuleRegistry = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;				this.context.putObject(CoreConstants.PATTERN_RULE_REGISTRY, patternRuleRegistry);</b>
&nbsp;			}
<b class="nc">&nbsp;			return patternRuleRegistry;</b>
&nbsp;		}
&nbsp;
&nbsp;		private void save(GenerationContext generationContext) {
<b class="nc">&nbsp;			Map&lt;String, String&gt; registryMap = getRegistryMap();</b>
<b class="nc">&nbsp;			generationContext.getGeneratedFiles().addResourceFile(RESOURCE_LOCATION, () -&gt; asInputStream(registryMap));</b>
<b class="nc">&nbsp;			generationContext.getRuntimeHints().resources().registerPattern(RESOURCE_LOCATION);</b>
<b class="nc">&nbsp;			for (String ruleClassName : registryMap.values()) {</b>
<b class="nc">&nbsp;				generationContext.getRuntimeHints()</b>
<b class="nc">&nbsp;					.reflection()</b>
<b class="nc">&nbsp;					.registerType(TypeReference.of(ruleClassName), MemberCategory.INVOKE_PUBLIC_CONSTRUCTORS);</b>
<b class="nc">&nbsp;			}</b>
&nbsp;		}
&nbsp;
&nbsp;		private InputStream asInputStream(Map&lt;String, String&gt; patternRuleRegistry) {
<b class="nc">&nbsp;			Properties properties = CollectionFactory.createSortedProperties(true);</b>
<b class="nc">&nbsp;			patternRuleRegistry.forEach(properties::setProperty);</b>
<b class="nc">&nbsp;			ByteArrayOutputStream bytes = new ByteArrayOutputStream();</b>
&nbsp;			try {
<b class="nc">&nbsp;				properties.store(bytes, &quot;&quot;);</b>
&nbsp;			}
<b class="nc">&nbsp;			catch (IOException ex) {</b>
<b class="nc">&nbsp;				throw new RuntimeException(ex);</b>
<b class="nc">&nbsp;			}</b>
<b class="nc">&nbsp;			return new ByteArrayInputStream(bytes.toByteArray());</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-28 21:28</div>
</div>
</body>
</html>
