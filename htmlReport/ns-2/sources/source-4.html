


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > BeanDefinitionLoader</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.springframework.boot</a>
</div>

<h1>Coverage Summary for Class: BeanDefinitionLoader (org.springframework.boot)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">BeanDefinitionLoader</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/19)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/90)
  </span>
</td>
</tr>
  <tr>
    <td class="name">BeanDefinitionLoader$ClassExcludeFilter</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BeanDefinitionLoader$GroovyBeanDefinitionSource</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/21)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/96)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2012-2023 the original author or authors.
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *      https://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;
&nbsp;package org.springframework.boot;
&nbsp;
&nbsp;import java.io.IOException;
&nbsp;import java.lang.reflect.Constructor;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.Set;
&nbsp;import java.util.regex.Pattern;
&nbsp;
&nbsp;import groovy.lang.Closure;
&nbsp;
&nbsp;import org.springframework.beans.BeanUtils;
&nbsp;import org.springframework.beans.factory.BeanDefinitionStoreException;
&nbsp;import org.springframework.beans.factory.groovy.GroovyBeanDefinitionReader;
&nbsp;import org.springframework.beans.factory.support.AbstractBeanDefinitionReader;
&nbsp;import org.springframework.beans.factory.support.BeanDefinitionReader;
&nbsp;import org.springframework.beans.factory.support.BeanDefinitionRegistry;
&nbsp;import org.springframework.beans.factory.support.BeanNameGenerator;
&nbsp;import org.springframework.beans.factory.xml.XmlBeanDefinitionReader;
&nbsp;import org.springframework.context.annotation.AnnotatedBeanDefinitionReader;
&nbsp;import org.springframework.context.annotation.ClassPathBeanDefinitionScanner;
&nbsp;import org.springframework.core.env.ConfigurableEnvironment;
&nbsp;import org.springframework.core.io.ClassPathResource;
&nbsp;import org.springframework.core.io.Resource;
&nbsp;import org.springframework.core.io.ResourceLoader;
&nbsp;import org.springframework.core.io.support.PathMatchingResourcePatternResolver;
&nbsp;import org.springframework.core.io.support.ResourcePatternResolver;
&nbsp;import org.springframework.core.type.filter.AbstractTypeHierarchyTraversingFilter;
&nbsp;import org.springframework.core.type.filter.TypeFilter;
&nbsp;import org.springframework.util.Assert;
&nbsp;import org.springframework.util.ClassUtils;
&nbsp;import org.springframework.util.ObjectUtils;
&nbsp;import org.springframework.util.StringUtils;
&nbsp;
&nbsp;/**
&nbsp; * Loads bean definitions from underlying sources, including XML and JavaConfig. Acts as a
&nbsp; * simple facade over {@link AnnotatedBeanDefinitionReader},
&nbsp; * {@link XmlBeanDefinitionReader} and {@link ClassPathBeanDefinitionScanner}. See
&nbsp; * {@link SpringApplication} for the types of sources that are supported.
&nbsp; *
&nbsp; * @author Phillip Webb
&nbsp; * @author Vladislav Kisel
&nbsp; * @author Sebastien Deleuze
&nbsp; * @see #setBeanNameGenerator(BeanNameGenerator)
&nbsp; */
&nbsp;class BeanDefinitionLoader {
&nbsp;
<b class="nc">&nbsp;	private static final Pattern GROOVY_CLOSURE_PATTERN = Pattern.compile(&quot;.*\\$_.*closure.*&quot;);</b>
&nbsp;
&nbsp;	private final Object[] sources;
&nbsp;
&nbsp;	private final AnnotatedBeanDefinitionReader annotatedReader;
&nbsp;
&nbsp;	private final AbstractBeanDefinitionReader xmlReader;
&nbsp;
&nbsp;	private final BeanDefinitionReader groovyReader;
&nbsp;
&nbsp;	private final ClassPathBeanDefinitionScanner scanner;
&nbsp;
&nbsp;	private ResourceLoader resourceLoader;
&nbsp;
&nbsp;	/**
&nbsp;	 * Create a new {@link BeanDefinitionLoader} that will load beans into the specified
&nbsp;	 * {@link BeanDefinitionRegistry}.
&nbsp;	 * @param registry the bean definition registry that will contain the loaded beans
&nbsp;	 * @param sources the bean sources
&nbsp;	 */
<b class="nc">&nbsp;	BeanDefinitionLoader(BeanDefinitionRegistry registry, Object... sources) {</b>
<b class="nc">&nbsp;		Assert.notNull(registry, &quot;Registry must not be null&quot;);</b>
<b class="nc">&nbsp;		Assert.notEmpty(sources, &quot;Sources must not be empty&quot;);</b>
<b class="nc">&nbsp;		this.sources = sources;</b>
<b class="nc">&nbsp;		this.annotatedReader = new AnnotatedBeanDefinitionReader(registry);</b>
<b class="nc">&nbsp;		this.xmlReader = new XmlBeanDefinitionReader(registry);</b>
<b class="nc">&nbsp;		this.groovyReader = (isGroovyPresent() ? new GroovyBeanDefinitionReader(registry) : null);</b>
<b class="nc">&nbsp;		this.scanner = new ClassPathBeanDefinitionScanner(registry);</b>
<b class="nc">&nbsp;		this.scanner.addExcludeFilter(new ClassExcludeFilter(sources));</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Set the bean name generator to be used by the underlying readers and scanner.
&nbsp;	 * @param beanNameGenerator the bean name generator
&nbsp;	 */
&nbsp;	void setBeanNameGenerator(BeanNameGenerator beanNameGenerator) {
<b class="nc">&nbsp;		this.annotatedReader.setBeanNameGenerator(beanNameGenerator);</b>
<b class="nc">&nbsp;		this.scanner.setBeanNameGenerator(beanNameGenerator);</b>
<b class="nc">&nbsp;		this.xmlReader.setBeanNameGenerator(beanNameGenerator);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Set the resource loader to be used by the underlying readers and scanner.
&nbsp;	 * @param resourceLoader the resource loader
&nbsp;	 */
&nbsp;	void setResourceLoader(ResourceLoader resourceLoader) {
<b class="nc">&nbsp;		this.resourceLoader = resourceLoader;</b>
<b class="nc">&nbsp;		this.scanner.setResourceLoader(resourceLoader);</b>
<b class="nc">&nbsp;		this.xmlReader.setResourceLoader(resourceLoader);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Set the environment to be used by the underlying readers and scanner.
&nbsp;	 * @param environment the environment
&nbsp;	 */
&nbsp;	void setEnvironment(ConfigurableEnvironment environment) {
<b class="nc">&nbsp;		this.annotatedReader.setEnvironment(environment);</b>
<b class="nc">&nbsp;		this.scanner.setEnvironment(environment);</b>
<b class="nc">&nbsp;		this.xmlReader.setEnvironment(environment);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Load the sources into the reader.
&nbsp;	 */
&nbsp;	void load() {
<b class="nc">&nbsp;		for (Object source : this.sources) {</b>
<b class="nc">&nbsp;			load(source);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private void load(Object source) {
<b class="nc">&nbsp;		Assert.notNull(source, &quot;Source must not be null&quot;);</b>
<b class="nc">&nbsp;		if (source instanceof Class&lt;?&gt; clazz) {</b>
<b class="nc">&nbsp;			load(clazz);</b>
&nbsp;			return;
&nbsp;		}
<b class="nc">&nbsp;		if (source instanceof Resource resource) {</b>
<b class="nc">&nbsp;			load(resource);</b>
&nbsp;			return;
&nbsp;		}
<b class="nc">&nbsp;		if (source instanceof Package pack) {</b>
<b class="nc">&nbsp;			load(pack);</b>
&nbsp;			return;
&nbsp;		}
<b class="nc">&nbsp;		if (source instanceof CharSequence sequence) {</b>
<b class="nc">&nbsp;			load(sequence);</b>
&nbsp;			return;
&nbsp;		}
<b class="nc">&nbsp;		throw new IllegalArgumentException(&quot;Invalid source type &quot; + source.getClass());</b>
&nbsp;	}
&nbsp;
&nbsp;	private void load(Class&lt;?&gt; source) {
<b class="nc">&nbsp;		if (isGroovyPresent() &amp;&amp; GroovyBeanDefinitionSource.class.isAssignableFrom(source)) {</b>
&nbsp;			// Any GroovyLoaders added in beans{} DSL can contribute beans here
<b class="nc">&nbsp;			GroovyBeanDefinitionSource loader = BeanUtils.instantiateClass(source, GroovyBeanDefinitionSource.class);</b>
<b class="nc">&nbsp;			((GroovyBeanDefinitionReader) this.groovyReader).beans(loader.getBeans());</b>
&nbsp;		}
<b class="nc">&nbsp;		if (isEligible(source)) {</b>
<b class="nc">&nbsp;			this.annotatedReader.register(source);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private void load(Resource source) {
<b class="nc">&nbsp;		if (source.getFilename().endsWith(&quot;.groovy&quot;)) {</b>
<b class="nc">&nbsp;			if (this.groovyReader == null) {</b>
<b class="nc">&nbsp;				throw new BeanDefinitionStoreException(&quot;Cannot load Groovy beans without Groovy on classpath&quot;);</b>
&nbsp;			}
<b class="nc">&nbsp;			this.groovyReader.loadBeanDefinitions(source);</b>
&nbsp;		}
&nbsp;		else {
<b class="nc">&nbsp;			this.xmlReader.loadBeanDefinitions(source);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private void load(Package source) {
<b class="nc">&nbsp;		this.scanner.scan(source.getName());</b>
&nbsp;	}
&nbsp;
&nbsp;	private void load(CharSequence source) {
<b class="nc">&nbsp;		String resolvedSource = this.scanner.getEnvironment().resolvePlaceholders(source.toString());</b>
&nbsp;		// Attempt as a Class
&nbsp;		try {
<b class="nc">&nbsp;			load(ClassUtils.forName(resolvedSource, null));</b>
&nbsp;			return;
&nbsp;		}
<b class="nc">&nbsp;		catch (IllegalArgumentException | ClassNotFoundException ex) {</b>
&nbsp;			// swallow exception and continue
&nbsp;		}
&nbsp;		// Attempt as Resources
<b class="nc">&nbsp;		if (loadAsResources(resolvedSource)) {</b>
&nbsp;			return;
&nbsp;		}
&nbsp;		// Attempt as package
<b class="nc">&nbsp;		Package packageResource = findPackage(resolvedSource);</b>
<b class="nc">&nbsp;		if (packageResource != null) {</b>
<b class="nc">&nbsp;			load(packageResource);</b>
&nbsp;			return;
&nbsp;		}
<b class="nc">&nbsp;		throw new IllegalArgumentException(&quot;Invalid source &#39;&quot; + resolvedSource + &quot;&#39;&quot;);</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean loadAsResources(String resolvedSource) {
<b class="nc">&nbsp;		boolean foundCandidate = false;</b>
<b class="nc">&nbsp;		Resource[] resources = findResources(resolvedSource);</b>
<b class="nc">&nbsp;		for (Resource resource : resources) {</b>
<b class="nc">&nbsp;			if (isLoadCandidate(resource)) {</b>
<b class="nc">&nbsp;				foundCandidate = true;</b>
<b class="nc">&nbsp;				load(resource);</b>
&nbsp;			}
&nbsp;		}
<b class="nc">&nbsp;		return foundCandidate;</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean isGroovyPresent() {
<b class="nc">&nbsp;		return ClassUtils.isPresent(&quot;groovy.lang.MetaClass&quot;, null);</b>
&nbsp;	}
&nbsp;
&nbsp;	private Resource[] findResources(String source) {
<b class="nc">&nbsp;		ResourceLoader loader = (this.resourceLoader != null) ? this.resourceLoader</b>
<b class="nc">&nbsp;				: new PathMatchingResourcePatternResolver();</b>
&nbsp;		try {
<b class="nc">&nbsp;			if (loader instanceof ResourcePatternResolver resolver) {</b>
<b class="nc">&nbsp;				return resolver.getResources(source);</b>
&nbsp;			}
<b class="nc">&nbsp;			return new Resource[] { loader.getResource(source) };</b>
&nbsp;		}
<b class="nc">&nbsp;		catch (IOException ex) {</b>
<b class="nc">&nbsp;			throw new IllegalStateException(&quot;Error reading source &#39;&quot; + source + &quot;&#39;&quot;);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private boolean isLoadCandidate(Resource resource) {
<b class="nc">&nbsp;		if (resource == null || !resource.exists()) {</b>
<b class="nc">&nbsp;			return false;</b>
&nbsp;		}
<b class="nc">&nbsp;		if (resource instanceof ClassPathResource classPathResource) {</b>
&nbsp;			// A simple package without a &#39;.&#39; may accidentally get loaded as an XML
&nbsp;			// document if we&#39;re not careful. The result of getInputStream() will be
&nbsp;			// a file list of the package content. We double-check here that it&#39;s not
&nbsp;			// actually a package.
<b class="nc">&nbsp;			String path = classPathResource.getPath();</b>
<b class="nc">&nbsp;			if (path.indexOf(&#39;.&#39;) == -1) {</b>
&nbsp;				try {
<b class="nc">&nbsp;					return getClass().getClassLoader().getDefinedPackage(path) == null;</b>
&nbsp;				}
<b class="nc">&nbsp;				catch (Exception ex) {</b>
&nbsp;					// Ignore
&nbsp;				}
&nbsp;			}
&nbsp;		}
<b class="nc">&nbsp;		return true;</b>
&nbsp;	}
&nbsp;
&nbsp;	private Package findPackage(CharSequence source) {
<b class="nc">&nbsp;		Package pkg = getClass().getClassLoader().getDefinedPackage(source.toString());</b>
<b class="nc">&nbsp;		if (pkg != null) {</b>
<b class="nc">&nbsp;			return pkg;</b>
&nbsp;		}
&nbsp;		try {
&nbsp;			// Attempt to find a class in this package
<b class="nc">&nbsp;			ResourcePatternResolver resolver = new PathMatchingResourcePatternResolver(getClass().getClassLoader());</b>
<b class="nc">&nbsp;			Resource[] resources = resolver</b>
<b class="nc">&nbsp;				.getResources(ClassUtils.convertClassNameToResourcePath(source.toString()) + &quot;/*.class&quot;);</b>
<b class="nc">&nbsp;			for (Resource resource : resources) {</b>
<b class="nc">&nbsp;				String className = StringUtils.stripFilenameExtension(resource.getFilename());</b>
<b class="nc">&nbsp;				load(Class.forName(source + &quot;.&quot; + className));</b>
<b class="nc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;		}
<b class="nc">&nbsp;		catch (Exception ex) {</b>
&nbsp;			// swallow exception and continue
<b class="nc">&nbsp;		}</b>
<b class="nc">&nbsp;		return getClass().getClassLoader().getDefinedPackage(source.toString());</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Check whether the bean is eligible for registration.
&nbsp;	 * @param type candidate bean type
&nbsp;	 * @return true if the given bean type is eligible for registration, i.e. not a groovy
&nbsp;	 * closure nor an anonymous class
&nbsp;	 */
&nbsp;	private boolean isEligible(Class&lt;?&gt; type) {
<b class="nc">&nbsp;		return !(type.isAnonymousClass() || isGroovyClosure(type) || hasNoConstructors(type));</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean isGroovyClosure(Class&lt;?&gt; type) {
<b class="nc">&nbsp;		return GROOVY_CLOSURE_PATTERN.matcher(type.getName()).matches();</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean hasNoConstructors(Class&lt;?&gt; type) {
<b class="nc">&nbsp;		Constructor&lt;?&gt;[] constructors = type.getDeclaredConstructors();</b>
<b class="nc">&nbsp;		return ObjectUtils.isEmpty(constructors);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Simple {@link TypeFilter} used to ensure that specified {@link Class} sources are
&nbsp;	 * not accidentally re-added during scanning.
&nbsp;	 */
&nbsp;	private static class ClassExcludeFilter extends AbstractTypeHierarchyTraversingFilter {
&nbsp;
<b class="nc">&nbsp;		private final Set&lt;String&gt; classNames = new HashSet&lt;&gt;();</b>
&nbsp;
&nbsp;		ClassExcludeFilter(Object... sources) {
<b class="nc">&nbsp;			super(false, false);</b>
<b class="nc">&nbsp;			for (Object source : sources) {</b>
<b class="nc">&nbsp;				if (source instanceof Class&lt;?&gt;) {</b>
<b class="nc">&nbsp;					this.classNames.add(((Class&lt;?&gt;) source).getName());</b>
&nbsp;				}
&nbsp;			}
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		protected boolean matchClassName(String className) {
<b class="nc">&nbsp;			return this.classNames.contains(className);</b>
&nbsp;		}
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Source for Bean definitions defined in Groovy.
&nbsp;	 */
&nbsp;	@FunctionalInterface
&nbsp;	protected interface GroovyBeanDefinitionSource {
&nbsp;
&nbsp;		Closure&lt;?&gt; getBeans();
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-04-01 11:12</div>
</div>
</body>
</html>
